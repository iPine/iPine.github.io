<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>iPine</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://ipine.github.io/"/>
  <updated>2018-06-11T12:49:24.762Z</updated>
  <id>http://ipine.github.io/</id>
  
  <author>
    <name>iPine</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>冒泡排序</title>
    <link href="http://ipine.github.io/2018-06-11/"/>
    <id>http://ipine.github.io/2018-06-11/</id>
    <published>2018-06-11T12:27:00.000Z</published>
    <updated>2018-06-11T12:49:24.762Z</updated>
    
    <content type="html"><![CDATA[<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><h4 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h4><blockquote><p>理论：<br>    1.比较轮数n-1。<br>    2.比较次数n-1。<br>    3.符合某个条件交换位置。</p></blockquote><blockquote><p>核心： 双重for循环。</p></blockquote><p><strong>步骤：</strong></p><p>1 .双重for循环。</p><p>2 .指定轮数和次数。</p><p>3 .判断是否符合标准。如果符合标准交换位置。</p><h3 id="版本比较"><a href="#版本比较" class="headerlink" title="版本比较"></a>版本比较</h3><p> 将数组元素从小到大排序：</p><h4 id="初始版"><a href="#初始版" class="headerlink" title="初始版"></a>初始版</h4><p>按照前面的步骤很容易写出以下代码：</p><pre><code>var arr = [7,6,5,4,3,2,1];//1.双重for循环。(外循环控制轮数)  for(var i=0;i&lt;arr.length-1;i++){    //2.指定轮数和次数（内循环控制次数）    for(var j=0;j&lt;arr.length-1;j++){        //3.判断是否符合标准。如果符合标准交换位置。                           if(arr[j] &gt; arr[j+1]){            var temp = arr[j];            arr[j] = arr[j+1];            arr[j+1] = temp;        }    }}</code></pre><blockquote><p><strong>改进思路</strong>：每比较一轮，就少比较一次。（每一轮都会比较出一个最大值，后一轮就没有必要再比较那个值了，所以每比较一轮，就少比较一次。）</p></blockquote><h4 id="改进版"><a href="#改进版" class="headerlink" title="改进版"></a>改进版</h4><pre><code>var arr = [7,6,5,4,3,2,1];    var m = 0;    var n = 0;for(var i=0;i&lt;arr.length-1;i++){    for(var j=0;j&lt;arr.length-1-i;j++){                       if(arr[j] &gt; arr[j+1]){            var temp = arr[j];            arr[j] = arr[j+1];            arr[j+1] = temp;        }        m++;//记录比较次数    }    n++;//记录比较轮数}console.log(arr);console.log(m);console.log(n);</code></pre><blockquote><p><strong>再升级思路</strong>：如果比较完，提前结束比较。（判断，如果本次比较没有移动任何元素，那么说明已经比较完成。）</p></blockquote><h4 id="升级版"><a href="#升级版" class="headerlink" title="升级版"></a>升级版</h4><pre><code>var arr = [1, 2, 3, 4, 5, 6, 7];var m = 0;var n = 0;for(var i=0;i&lt;arr.length-1;i++){    //开闭原则。（写在第一个for循环里，是为了每轮比较先初始化bool变量变为true。）    var bool = true;    for(var j=0;j&lt;arr.length-1-i;j++){        if(arr[j] &gt; arr[j+1]){            var temp = arr[j];            arr[j] = arr[j+1];            arr[j+1] = temp;            //如果有交换，则bool置false。            bool = false;        }        m++;    }    n++;    //如果本轮比较没有任何元素相互交换位置，那么说明已经比较完成，可以跳出循环。    if(bool){        break;    }}console.log(arr);console.log(m);console.log(n);</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;冒泡排序&quot;&gt;&lt;a href=&quot;#冒泡排序&quot; class=&quot;headerlink&quot; title=&quot;冒泡排序&quot;&gt;&lt;/a&gt;冒泡排序&lt;/h3&gt;&lt;h4 id=&quot;基本思想&quot;&gt;&lt;a href=&quot;#基本思想&quot; class=&quot;headerlink&quot; title=&quot;基本思想&quot;&gt;&lt;/a
      
    
    </summary>
    
      <category term="technique summary" scheme="http://ipine.github.io/categories/technique-summary/"/>
    
    
      <category term="排序算法" scheme="http://ipine.github.io/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>js实现before :after伪类样式修改</title>
    <link href="http://ipine.github.io/2018-06-06/"/>
    <id>http://ipine.github.io/2018-06-06/</id>
    <published>2018-06-06T03:25:00.000Z</published>
    <updated>2018-06-06T06:44:23.856Z</updated>
    
    <content type="html"><![CDATA[<p>为了能对区块的产生有一个更直观的认识，想让最新区块的产生有一个动画的展示效果（从无到有的弹入）。这里用js的<code>animate</code>函数来实现。之前有提到每个区块都用了伪类来添加样式，所以这里还需要对伪类样式作一些修改。</p><h3 id="伪类样式修改方案"><a href="#伪类样式修改方案" class="headerlink" title="伪类样式修改方案"></a>伪类样式修改方案</h3><h4 id="元素的before和after伪类的样式修改方案"><a href="#元素的before和after伪类的样式修改方案" class="headerlink" title="元素的before和after伪类的样式修改方案"></a>元素的before和after伪类的样式修改方案</h4><p>要实现某个元素的before和after伪类的样式修改，方法有4种。CSS中并不能直接选择某一个元素的<code>:before</code>和<code>:after</code>伪类元素。</p><h4 id="举个栗子说明4种方案"><a href="#举个栗子说明4种方案" class="headerlink" title="举个栗子说明4种方案"></a>举个栗子说明4种方案</h4><h4 id="HTML结构"><a href="#HTML结构" class="headerlink" title="HTML结构"></a>HTML结构</h4><pre><code>&lt;div class=&quot;box&quot;&gt;Hello,it&apos;s me.&lt;/div&gt;</code></pre><h4 id="CSS样式"><a href="#CSS样式" class="headerlink" title="CSS样式"></a>CSS样式</h4><pre><code>.box:after{    content: &apos;&apos;,    font-weight: bold}</code></pre><h4 id="方案1"><a href="#方案1" class="headerlink" title="方案1"></a>方案1</h4><p>使用js或者jQuery改变，为元素添加类</p><pre><code>.blue:after{    content: &apos;&apos;,    background-color: blue}$(&apos;div&apos;).addClass(&apos;blue&apos;);</code></pre><h4 id="方案2"><a href="#方案2" class="headerlink" title="方案2"></a>方案2</h4><p>在存在的style文档中动态插入样式</p><pre><code>document.styleSheet[0].addRule(&apos;.box:after&apos;,&apos;background-color:blue&apos;);document.styleSheet[0].insertRule(&apos;.box:after{background-color:blue}&apos;,0);</code></pre><h4 id="方案3"><a href="#方案3" class="headerlink" title="方案3"></a>方案3</h4><p>创建一份新的样式表，并使用js或jQuery将其插入到head标签中</p><pre><code>var style = document.creatElement(&apos;style&apos;);document.head.appendChild(style);sheet = style.sheet;sheet.addRule(&apos;.box:after&apos;,&apos;background-color:blue&apos;);sheet.insetRule(&apos;.box:after{background-color:blue}&apos;,0);&lt;!-- 插入操作 --&gt;$(&apos;&lt;style&gt;.box:after{background-color:blue}&lt;/style&gt;&apos;).appendTo(&apos;head&apos;);</code></pre><h4 id="方案4"><a href="#方案4" class="headerlink" title="方案4"></a>方案4</h4><p>使用HTML5的<code>data-</code>属性，在属性中使用<code>attr()</code>动态修改<br>先给div标签增加<code>data-attr = &#39;orange&#39;</code>属性，然后用jQuery修改该属性值</p><pre><code>.box:after{        content: &apos;&apos;,        font-weight: bold,        data-attr: &apos;orange&apos;    }$(&apos;div&apos;).attr(&apos;data-attr&apos;,&apos;blue&apos;);</code></pre><h3 id="我的练习"><a href="#我的练习" class="headerlink" title="我的练习"></a>我的练习</h3><h4 id="最新区块修改伪类样式"><a href="#最新区块修改伪类样式" class="headerlink" title="最新区块修改伪类样式"></a>最新区块修改伪类样式</h4><p>说明：每个区块在展示时，因为有额外的图片和时间信息需要展示，所以借助了伪类<code>before</code>和<code>after</code> <a href="https://ipine.github.io/2018-05-20/">具体实现可Pick我</a>。</p><ul><li>原来的做法：在CSS中选择要应用伪类的元素，然后设置伪类样式</li></ul><p><img src="http://p8ay1ez22.bkt.clouddn.com/18-6-6/72925655.jpg" alt="图1"></p><blockquote><p>图1 直接选择要应用伪类的元素，然后设置样式</p></blockquote><ul><li>现在的做法：给某个类名设置伪类样式，然后将该类名添加给需要该样式的元素。用的是上面提到的4个方案中的方案1，这是比较简洁和方便的做法。</li></ul><blockquote><p>注意：<code>after</code>伪类显示区块产生时间，需要通过js设置<code>data-content</code>属性值，CSS用<code>content</code>属性，获取属性<code>data-content</code>的值</p></blockquote><p><img src="http://p8ay1ez22.bkt.clouddn.com/18-6-6/56336466.jpg" alt="图2"></p><blockquote><p>图2 给某个类名应用伪类样式，before类设置小三角图片，after类显示区块产生时间</p></blockquote><h3 id="动态弹入效果"><a href="#动态弹入效果" class="headerlink" title="动态弹入效果"></a>动态弹入效果</h3><p>动态展示的最新区块，其HTML结构与其他区块不同，且还需要改变它的伪类样式。</p><h4 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h4><h5 id="动态添加节点"><a href="#动态添加节点" class="headerlink" title="动态添加节点"></a>动态添加节点</h5><p>首先把最新区块与其他区块分开。最新区块在页面加载完时是没有的，在写入区块信息之前，动态添加最新区块的节点。最新区块的HTML结构相比于其他区块，多了一层大的div.bnew，作用是为了显示链条的背景图，小三角，区块的产生时间(用到了<code>before</code>和<code>after</code>伪类，如图2所示)。因为每次刷新都需要动态添加最新区块的节点，因而在添加前需要把上一次的节点remove掉，所以具体实现如下所示。</p><p><img src="http://p8ay1ez22.bkt.clouddn.com/18-6-6/12410357.jpg" alt="图3"></p><blockquote><p>图3 jQUery动态操作节点</p></blockquote><h5 id="动画方法"><a href="#动画方法" class="headerlink" title="动画方法"></a>动画方法</h5><p>动画实现用到的是jQuery的animate()方法，语法包含4个参数</p><pre><code>$(selector).animate(styles,speed,easing,callback)</code></pre><p>参数的具体设置如下：</p><p>1 .首先动态修改<code>style</code>参数。通过<code>marginLeft</code>来控制进入方向；<code>width</code>来控制显示范围；<code>opacity</code>控制初始的隐藏状态；<br>2 .然后填加动画时间为2000ms。</p><p>具体如图4所示。<br><img src="http://p8ay1ez22.bkt.clouddn.com/18-6-6/92604390.jpg" alt="图4"></p><blockquote><p>图4 给最新区块<code>div.bnew</code>添加动画</p></blockquote><p>初始的<code>div.bnew</code>的CSS样式</p><p><img src="http://p8ay1ez22.bkt.clouddn.com/18-6-6/93921793.jpg" alt="图5"></p><blockquote><p>图5 初始的<code>div.bnew</code>样式设置</p></blockquote><blockquote><p>注：因为在animate方法中，<code>display</code>属性无法起作用，所以在初始的样式设置中要用<code>opacity</code>属性。</p></blockquote><p>3 .注意<code>easing</code>参数的设置，内置的只有2种，如下所示。</p><p><img src="http://p8ay1ez22.bkt.clouddn.com/18-6-6/17971145.jpg" alt="图6"></p><p>若要用到其他的运动轨迹需要添加库，然后引用，这里引用的是<code>easeOutBounce</code>。<a href="https://easings.net/zh-tw" target="_blank" rel="noopener">详细参数引用可Pick我</a></p><p><img src="http://p8ay1ez22.bkt.clouddn.com/18-6-6/7066421.jpg" alt="图7"></p><p>4 .最后回调函数<code>callback</code>的设置。为<code>div.bnew</code>添加类名<code>bnewT</code>（伪类样式的设置）放在这里，如图4所示。</p><h4 id="实现效果"><a href="#实现效果" class="headerlink" title="实现效果"></a>实现效果</h4><p><img src="http://p8ay1ez22.bkt.clouddn.com/18-6-6/2353727.jpg" alt="效果图"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;为了能对区块的产生有一个更直观的认识，想让最新区块的产生有一个动画的展示效果（从无到有的弹入）。这里用js的&lt;code&gt;animate&lt;/code&gt;函数来实现。之前有提到每个区块都用了伪类来添加样式，所以这里还需要对伪类样式作一些修改。&lt;/p&gt;
&lt;h3 id=&quot;伪类样式修改
      
    
    </summary>
    
      <category term="technique summary" scheme="http://ipine.github.io/categories/technique-summary/"/>
    
    
      <category term="javascript" scheme="http://ipine.github.io/tags/javascript/"/>
    
      <category term="css" scheme="http://ipine.github.io/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>《白说》</title>
    <link href="http://ipine.github.io/2018-06-03/"/>
    <id>http://ipine.github.io/2018-06-03/</id>
    <published>2018-06-03T11:52:00.000Z</published>
    <updated>2018-06-05T09:28:27.157Z</updated>
    
    <content type="html"><![CDATA[<p>繁忙的5月，在并不忙的最后几天读了《白说》。这是我第一次读白岩松老师的书，我是个很难在短时间内读完一本书的人（武侠小说除外 0.0），但这次很快就看完了。可能这跟《白说》是本类似于鸡汤的演讲集有关。白岩松作为央视的著名主持人，肯定做过很多演讲，这本书其实就是把他所讲的相同主题的演讲内容组合在一起，总共二十来篇。</p><p>他说。他姓白，所以这本书叫《白说》。他说，说了也白说，但不说，白不说。读完《白说》，我觉得很多地方都没“白说”，下面是摘录的部分读书笔记。</p><hr><h3 id="主题：漂亮的失败是另一种成功"><a href="#主题：漂亮的失败是另一种成功" class="headerlink" title="主题：漂亮的失败是另一种成功"></a>主题：漂亮的失败是另一种成功</h3><blockquote><p>白说：人如果一直处于“成功”的状态，慢慢也就麻了，所谓温水中的青蛙，你觉得一切都是理所当然。反倒是时常降临的失败与挫折，是上帝对你的一个提醒，让你从“失败”这门课里，接受某些教育。</p></blockquote><p> 人处于一帆风顺的境地，久了，可能会觉得生活太平淡反而没有什么意思。偶尔的一些逆境，让人学会某些东西，然后体验生活的不同味道。”生命远非人智所及，它由伟大的孤寂中诞生，只有从苦难中才能触及。只有困厄与苦难才能使心眼打开，看到那不为他人所知的一切”。拥抱失败与痛苦，直面现实，才能触及到生命的本质。</p><blockquote><p>白说：很多人的失败感，不是来自自己的感受，而是别人的眼光与当下世俗的标准。然后方寸大乱，然后就真觉得自己失败了。如果你不为别人的眼光与标准活着，失败的感受会在我们生活中消失大半。</p></blockquote><p> 无论做什么事，都应该建立自己的标准与目标，别让别人的眼光打扰自己的情绪和感受，信自己才是王道。</p><h3 id="主题：沟通世界不是非黑即白"><a href="#主题：沟通世界不是非黑即白" class="headerlink" title="主题：沟通世界不是非黑即白"></a>主题：沟通世界不是非黑即白</h3><blockquote><p>白说：国外的新闻报道几乎已成共识：通过具体人物，表达宏大事件。没有主人公就没有事件，就会让新闻可信度，尤其是吸引力降低。所以，你首先要明白，新闻写作传播，就是一个写故事和讲故事的过程。不要在“故事”和“虚构”之间画等号—真实的事情，也需要通过“讲故事”的方式进行传播。我们在对外、对内的宣传当中，有相当多的失败就是因为不会讲故事。花了很多钱出了很多力，却没有好的效果。</p></blockquote><p>以前也一直认为故事就等于虚构，不够贴近生活。现在才知道，生活需要我们有讲一个好故事的能力。同样一个笑话，为什么别人讲，就好好笑，自己讲，空气中弥漫的尽是尴尬。传播信息本质上也是一个讲故事的过程，学习，工作时常需要作报告和分享，这些就能体现出一个人讲故事的能力。如何讲才能更通俗易懂，更能吸引听者听下去，这些都是是需要花很多时间思考和准备的。柏拉图说： “谁会讲故事谁就拥有世界”。与人交流，学会讲故事，才能掌握主动权。</p><h3 id="主题：智商很高，情商却低"><a href="#主题：智商很高，情商却低" class="headerlink" title="主题：智商很高，情商却低"></a>主题：智商很高，情商却低</h3><blockquote><p>国家治理体系和治理能力的现代化，不仅包括依法治国，其中必然也包括提升整个社会的情商，尤其是执政者的情商。一个国家的良性运转，一个社会要达成和谐，情商必不可少，甚至高于智商。情商对于中国的执政者、媒体格外重要。中国老百姓最受用的一个词是“态度”，不管受多大委屈，如果你的情商很高，带着爱、带着温暖走到他的身边，人家立即眼泪一抹，“放心，我自力更生。”啥委屈都扔一边了。</p></blockquote><p>读到这段话的时候，感触挺深的。因为正好碰到自己遇到不公平待遇，就感觉自己其实也很受用“态度”一词，不管受多大委屈，只有别人态度诚恳，说话不那么伤人，我就觉得这些都没啥了，多大的事可能都不是事了：），可能也只有高情商的人才会想到这样做。想起之前读的一本书《所谓情商高就是会说话》，说话不只是一种“感觉”，说话还是是一种技术，同一个意思，换一个表达，效果却全然不一样。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;繁忙的5月，在并不忙的最后几天读了《白说》。这是我第一次读白岩松老师的书，我是个很难在短时间内读完一本书的人（武侠小说除外 0.0），但这次很快就看完了。可能这跟《白说》是本类似于鸡汤的演讲集有关。白岩松作为央视的著名主持人，肯定做过很多演讲，这本书其实就是把他所讲的相同主
      
    
    </summary>
    
      <category term="read" scheme="http://ipine.github.io/categories/read/"/>
    
    
      <category term="reading notes" scheme="http://ipine.github.io/tags/reading-notes/"/>
    
  </entry>
  
  <entry>
    <title>判断一个数是否是2的幂</title>
    <link href="http://ipine.github.io/2018-05-30/"/>
    <id>http://ipine.github.io/2018-05-30/</id>
    <published>2018-05-30T13:59:00.000Z</published>
    <updated>2018-05-31T03:04:41.640Z</updated>
    
    <content type="html"><![CDATA[<h2 id="最近在看《技术之瞳》，编程语言部分有一个笔试题目"><a href="#最近在看《技术之瞳》，编程语言部分有一个笔试题目" class="headerlink" title=" 最近在看《技术之瞳》，编程语言部分有一个笔试题目"></a> 最近在看《技术之瞳》，编程语言部分有一个笔试题目</h2><h3 id="Q：请填写一个表达式，用于判断一个数是否是2的幂？"><a href="#Q：请填写一个表达式，用于判断一个数是否是2的幂？" class="headerlink" title="Q：请填写一个表达式，用于判断一个数是否是2的幂？"></a>Q：请填写一个表达式，用于判断一个数是否是2的幂？</h3><h3 id="A：首先要考虑数的正负，其次判断是否为2的幂，最好的办法是利用位运算技巧。"><a href="#A：首先要考虑数的正负，其次判断是否为2的幂，最好的办法是利用位运算技巧。" class="headerlink" title="A：首先要考虑数的正负，其次判断是否为2的幂，最好的办法是利用位运算技巧。"></a>A：首先要考虑数的正负，其次判断是否为2的幂，最好的办法是利用位运算技巧。</h3><pre><code>n&gt;0? (n&amp;(n-1))==0:false</code></pre><h3 id="Key"><a href="#Key" class="headerlink" title="Key"></a>Key</h3><h4 id="将2的幂次方写成二进制形式后，很容易就会发现有一个特点："><a href="#将2的幂次方写成二进制形式后，很容易就会发现有一个特点：" class="headerlink" title="将2的幂次方写成二进制形式后，很容易就会发现有一个特点："></a>将2的幂次方写成二进制形式后，很容易就会发现有一个特点：</h4><blockquote><p>二进制中只有一个1，并且1后面跟了n个0。如果将这个数减去1后会发现，那个1会变为0，而原来的n个0会变为1。</p></blockquote><h4 id="举栗子说明"><a href="#举栗子说明" class="headerlink" title="举栗子说明"></a>举栗子说明</h4><pre><code>十进制   二进制 2        10 4        100 8        1000 16       10000 ...       ... 2-1      01 4-1      011 8-1      0111 16-1     01111</code></pre><blockquote><p>因此将原来的数与其减去1后的数字进行<code>&amp;</code>运算,为零，则原来的数是2的幂。</p></blockquote><h3 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h3><ul><li><code>&amp;</code> 按位与运算符：两位同时为1，结果才为1，否则为0。</li></ul><h4 id="作用："><a href="#作用：" class="headerlink" title="作用："></a>作用：</h4><p> 1 . 清零；想让某个数清零，则另找一个数（原数为1的位置，新数为0），两个数作与运算。<br> 2 . 取一个数中的某些位；若想取低字节位，则可和8个1作与运算。<br> 3 . 保留指定位；若23，即10111，想保留左起的2,3,5位，则可和01101（13）作与运算。</p><ul><li><code>|</code> 按位或运算符：两位中有一个为1，结果就为1。</li></ul><h4 id="作用：-1"><a href="#作用：-1" class="headerlink" title="作用："></a>作用：</h4><p> 1 . 按位或运算常用来对一个数据的某些位定值为1；若想使18，即10010的低4位改为1，则只需和13（1101）进行按位或运算即可。</p><ul><li><code>^</code> 异或运算符：两位值不同，结果为1，否则为0。</li></ul><h4 id="作用：-2"><a href="#作用：-2" class="headerlink" title="作用："></a>作用：</h4><p> 1 . 交换两个值，不用临时变量；</p><h5 id="举栗子说明-1"><a href="#举栗子说明-1" class="headerlink" title="举栗子说明"></a>举栗子说明</h5><pre><code>a=3 (011), b=5 (101);      a=a^b;                  b=a^b;               b=a^b;        </code></pre><h5 id="另一种方式"><a href="#另一种方式" class="headerlink" title="另一种方式"></a>另一种方式</h5><pre><code>a=a+b; b=a-b;a=a-b;</code></pre><ul><li><code>~</code> 取反运算符：将0变1，1变0；用于求整数的二进制反码。</li></ul><ul><li><code>&lt;&lt;</code> 左移运算符：各二进制位全部左移若干位，左边丢弃，右边补0。</li></ul><ul><li><code>&gt;&gt;</code> 右移运算符：各二进制位全部右移若干位，正数左补0，负数左补1，右边丢弃。</li></ul><ul><li>两个不同长度的数据进行位运算时，系统会将二者按右端对齐，然后进行位运算。短的那个数据如果是负数，左边补1，否则补0。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;最近在看《技术之瞳》，编程语言部分有一个笔试题目&quot;&gt;&lt;a href=&quot;#最近在看《技术之瞳》，编程语言部分有一个笔试题目&quot; class=&quot;headerlink&quot; title=&quot; 最近在看《技术之瞳》，编程语言部分有一个笔试题目&quot;&gt;&lt;/a&gt; 最近在看《技术之瞳》，编
      
    
    </summary>
    
      <category term="technique summary" scheme="http://ipine.github.io/categories/technique-summary/"/>
    
    
      <category term="面试题" scheme="http://ipine.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
      <category term="code" scheme="http://ipine.github.io/tags/code/"/>
    
  </entry>
  
  <entry>
    <title>CSS :before :after应用</title>
    <link href="http://ipine.github.io/2018-05-20/"/>
    <id>http://ipine.github.io/2018-05-20/</id>
    <published>2018-05-20T12:06:00.000Z</published>
    <updated>2018-05-20T12:46:17.646Z</updated>
    
    <content type="html"><![CDATA[<p>前面总结过将<a href="http://ipine.github.io/2018-05-13/">Flex布局</a>应用在区块图的布局中，现在需要在区块<code>.block</code>之间显示每个块产生的时间间隔，以及一个小三角符号。这里总结用伪元素<code>:before</code> ，<code>:after</code> 来实现该效果。</p><h3 id="伪元素"><a href="#伪元素" class="headerlink" title="伪元素"></a>伪元素</h3><h4 id="基本语法格式"><a href="#基本语法格式" class="headerlink" title="基本语法格式"></a>基本语法格式</h4><blockquote><p>selector:pseudo-element {property:value;}<br>  selector.class:pseudo-element {property:value;}</p></blockquote><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>方便给某些选择器添加特殊效果。</p><h4 id="before"><a href="#before" class="headerlink" title=":before"></a>:before</h4><p>用来给指定的元素的内容之前插入新内容；</p><h4 id="after"><a href="#after" class="headerlink" title=":after"></a>:after</h4><p>用来给指定的元素的内容之后插入新内容。</p><h4 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h4><pre><code>.first:before{    content: &apos;It\&apos;s &apos;;    color: blue;}&lt;p class=&quot;first&quot;&gt;me&lt;/p&gt;</code></pre><ul><li>效果：</li></ul><p><img src="http://p8ay1ez22.bkt.clouddn.com/18-5-20/44955663.jpg" alt="例1"></p><h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><ul><li><p>通过伪元素 <code>:before</code> ，<code>:after</code>添加的新内容区域默认的<code>display</code> 属性值为<code>inline</code>。可以像修改其他元素一样修改它的样式，可以将它的 <code>display</code> 属性值来改为 <code>block</code>。</p></li><li><p>对于伪元素 <code>:before</code> 和 <code>:after</code> ，属性 <code>content</code> <strong>必须设置</strong>。</p></li><li><p>属性 <code>content</code> 的值可以是多类型的</p></li></ul><h5 id="再举栗子"><a href="#再举栗子" class="headerlink" title="再举栗子"></a>再举栗子</h5><p> 1 . 可以是一张图片的url </p><pre><code>content: url( &quot;img/me.png&quot; )</code></pre><p> 2 . 可以配合伪类使用，常配合伪类 :hover </p><pre><code>.first:hover:before{    content:&apos;It\&apos;s &apos;;    color:red; }&lt;p class=&quot;first&quot;&gt;me&lt;/p&gt;</code></pre><p>注意两者使用的顺序，伪类 <code>:hover</code> 在前，伪元素<code>:before</code>在后，如果顺序改为 <code>.before:before:hover</code> ,则无效。</p><ul><li>效果：</li></ul><p><img src="http://p8ay1ez22.bkt.clouddn.com/18-5-20/54128140.jpg" alt="例2"></p><blockquote><p>鼠标移上去就显示It’s，且颜色是红色</p></blockquote><p>3 . 配合取值函数attr()使用</p><pre><code>a:before{     content: attr(title);}&lt;a href=&quot;http://www.taobao.com&quot; title=&quot;我的最爱&quot;&gt;买买买&lt;/a&gt;</code></pre><ul><li>效果：</li></ul><p><img src="http://p8ay1ez22.bkt.clouddn.com/18-5-20/3773922.jpg" alt="例3"></p><h3 id="我的练习"><a href="#我的练习" class="headerlink" title="我的练习"></a>我的练习</h3><h4 id="最终效果图"><a href="#最终效果图" class="headerlink" title="最终效果图"></a>最终效果图</h4><p><img src="http://p8ay1ez22.bkt.clouddn.com/18-5-20/51524863.jpg" alt="图1"></p><blockquote><p>图1 两个红色线框中的内容为实现效果</p></blockquote><h4 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h4><h5 id="HTML结构"><a href="#HTML结构" class="headerlink" title="HTML结构"></a>HTML结构</h5><p><img src="http://p8ay1ez22.bkt.clouddn.com/18-5-20/30610342.jpg" alt="图2"></p><blockquote><p>图2 3个大的横排div，每个横排大div里，假设都有5个<code>.block</code>区块div</p></blockquote><h5 id="CSS设置"><a href="#CSS设置" class="headerlink" title="CSS设置"></a>CSS设置</h5><p>以<code>.rowMiddle</code>行里的<code>.block</code>为例，用<code>:before</code>控制小三角的显示和位置；用<code>:after</code>控制区块产生的间隔时间的显示和位置</p><p>/<em><code>.rowMiddle</code>中每个<code>.block</code>后面的小三角符号的处理，控制 <code>:before</code></em>/</p><pre><code>.rowMiddle .block:not(:first-child)::before{    content: &apos;&apos;;    display: block;    width: 9px;     height: 9px;    background-image: url(../images/chainicon1.png);    background-repeat: no-repeat;    position: absolute;    top: 60%;    left: -20%;}</code></pre><p>/<em><code>.rowMiddle</code>中每个<code>.block</code>的产生时间间隔，控制 <code>:after</code></em>/</p><pre><code>.rowMiddle .block:not(:first-child)::after{    content: attr(data-content);    font-size: 12px;    display: block;    width: 36px;     height: 15px;    line-height: 15px;    position: absolute;    top: 30%;    left: -27%;}</code></pre><blockquote><p>注：attr(data-content)中 <code>data-content</code>的值通过js计算得到。每个<code>.block</code>的产生时间间隔不同，在js中为每个<code>.block</code>添加一个<code>.timewait</code>类，并设置属性<code>data-content</code>的值。</p></blockquote><h5 id="JS代码"><a href="#JS代码" class="headerlink" title="JS代码"></a>JS代码</h5><pre><code>$(&quot;.rowMiddle .block&quot;).each(function(i){    // 控制after伪类,为每个block添加不同的产生时间信息    // CSS中的.attr只能应用在伪类中的content属性    var timeWait = 0;        timeWait = blockData[4+i].time - blockData[5+i].time;        $(this).addClass(&apos;timewait&apos;).attr(&apos;data-content&apos;,timeWait+&apos;秒&apos;);});</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前面总结过将&lt;a href=&quot;http://ipine.github.io/2018-05-13/&quot;&gt;Flex布局&lt;/a&gt;应用在区块图的布局中，现在需要在区块&lt;code&gt;.block&lt;/code&gt;之间显示每个块产生的时间间隔，以及一个小三角符号。这里总结用伪元素&lt;code&gt;
      
    
    </summary>
    
      <category term="technique summary" scheme="http://ipine.github.io/categories/technique-summary/"/>
    
    
      <category term="javascript" scheme="http://ipine.github.io/tags/javascript/"/>
    
      <category term="css" scheme="http://ipine.github.io/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>报告：多维数据的感知互补视图评估</title>
    <link href="http://ipine.github.io/2018-05-17/"/>
    <id>http://ipine.github.io/2018-05-17/</id>
    <published>2018-05-17T07:59:00.000Z</published>
    <updated>2018-05-20T06:53:24.883Z</updated>
    
    <content type="html"><![CDATA[<h1 id="报告：多维数据的感知互补视图评估"><a href="#报告：多维数据的感知互补视图评估" class="headerlink" title="报告：多维数据的感知互补视图评估"></a>报告：多维数据的感知互补视图评估</h1><ul><li>论文原文：An Evaluation of Perceptually Complementary Views for Multivariate Data</li><li>作者：Chunlei Chang,Tim Dwyer,Kim Marriott</li><li>发表刊物/会议： <a href="http://itolab.is.ocha.ac.jp/pvis2018/" target="_blank" rel="noopener">PVis 2018</a></li></ul><h2 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h2><p>各个领域越来越多的自动化数据收集，因此越来越复杂的高维数据变得可用。有效的可视化和分析工具也越来越重要。多维数据的可视化技术和方法有很多，比如经典的MDS，PCA，但是这类方法在数据降维的过程中难免会损失原始数据的信息。而既能保证数据信息不丢失又能展示所有维度的信息，应用最广泛的是散点图矩阵<code>（SPLOMs）</code>和平行坐标图<code>（PCPs）</code>。</p><h3 id="本文工作"><a href="#本文工作" class="headerlink" title="本文工作"></a>本文工作</h3><p>评估散点图矩阵（SPLOM）、平行坐标图（PCP）、以及这两种技术的并排组合图（ Combined ）在可视化多维数据时的各自优势。</p><h3 id="重点贡献"><a href="#重点贡献" class="headerlink" title="重点贡献"></a>重点贡献</h3><p>1 . 总结6个用户分析多维数据时需要解决的Tasks；<br>2 . 总结5种志愿者在使用组合图时常用的策略；</p><ul><li><strong>论文作者为什么会想到评估组合视图呢？</strong></li></ul><blockquote><p>思路来源于一篇感知互补网络可视化的评估论文（CHI 2017 Evaluating perceptually<br>complementary views for network exploration tasks），这篇论文比较网络的单个矩阵视图、节点链接视图、以及它们的并排组合，发现并排组合的综合视图有明显的优势。但是现在还没有人做过这种组合视图的评估工作。 </p></blockquote><blockquote><p>注：感知互补视图，不同于多视图，在感觉上是互补的，即它们都展示相同的信息，但是对不同类型的分析任务有不同的和互补的支持。</p></blockquote><ul><li><strong>本文的组合视图与以往研究工作中的组合视图有什么区别呢？</strong></li></ul><blockquote><p>以往做法：使用复杂的视觉和交互设计将两种不同技术组合成单个可视化方案<br>  本文：更为直接地做法将两种技术视图并排放在一起</p></blockquote><ul><li><strong>主要研究的问题？</strong></li></ul><blockquote><p>Q1：PCP或SPLOM各自适合哪些任务？<br>  Q2：解决复杂任务时组合视图有没有优势？<br>  Q3：用户是否意识到不同视图的优点？ 如果有，他们用什么策略来解决分析任务。</p></blockquote><h2 id="视觉编码及交互设计"><a href="#视觉编码及交互设计" class="headerlink" title="视觉编码及交互设计"></a>视觉编码及交互设计</h2><h3 id="视觉编码"><a href="#视觉编码" class="headerlink" title="视觉编码"></a>视觉编码</h3><ul><li>PCP：每个数据项都被编码为一条折线，标签命名轴表示数据维度和范围；</li><li>SPLOM：每个数据项由多个圆点表示，对角线上的空白单元格用来显示维度标签，数据范围标记在左边和底边。</li></ul><p><img src="http://p8ay1ez22.bkt.clouddn.com/18-5-20/51062033.jpg" alt="图1"></p><blockquote><p>图1：可视化技术介绍</p></blockquote><h3 id="交互设计"><a href="#交互设计" class="headerlink" title="交互设计"></a>交互设计</h3><ul><li>鼠标悬浮数据项，高亮，该数据点的相关信息展示在旁边</li><li>范围过滤，选择范围内的数据项高亮</li><li>组合视图Brush（两个视图的联动），包括上面两个交互技术的应用</li><li><p>平行坐标轴和矩阵重排序</p><p><strong> 维度排序步骤：</strong><br>1 .点击PCP的轴或者散点图的轴启动拖拽<br>2 .将选定的轴拖动到所需的位置。<br>3 .释放鼠标，两个视图更新</p></li></ul><p><img src="http://p8ay1ez22.bkt.clouddn.com/18-5-20/15907245.jpg" alt="图2"></p><blockquote><p>图2 组合视图中轴的重排序</p></blockquote><h2 id="实验研究过程"><a href="#实验研究过程" class="headerlink" title="实验研究过程"></a>实验研究过程</h2><p>首先总结Tasks，确定6个通用任务，来源于以往基于PCP和SPLOM的评估工作。</p><p>实验参与者需要回答每个任务后面的具体问题。问题是基于实验中使用的数据。</p><ul><li>实验数据：学生成绩数据，6个维度，包含姓名、性别和4门学科的分数。</li></ul><h3 id="Best-Performer"><a href="#Best-Performer" class="headerlink" title="Best-Performer"></a>Best-Performer</h3><ul><li>Q： 哪个学生的平均分数最高？</li></ul><h3 id="Subset-Tracing"><a href="#Subset-Tracing" class="headerlink" title="Subset-Tracing"></a>Subset-Tracing</h3><ul><li>Q： 年龄在22岁，科学分数少于75分但是数学分数最高的学生姓名是？</li></ul><h3 id="Object-Comparison"><a href="#Object-Comparison" class="headerlink" title="Object-Comparison"></a>Object-Comparison</h3><ul><li>Q： 在所有4门学科中，标记3个数据为黄色，1个数据为蓝，要求找出标记为黄色的学生哪个与标记为蓝色的学生平均分最为相近？</li></ul><h3 id="Outlier-Detection"><a href="#Outlier-Detection" class="headerlink" title="Outlier-Detection"></a>Outlier-Detection</h3><ul><li>Q： 找出工程得分高于其他三门课程的学生（最为明显的那一个）？</li></ul><h3 id="Correlation-Estimation"><a href="#Correlation-Estimation" class="headerlink" title="Correlation-Estimation"></a>Correlation-Estimation</h3><ul><li>Q： 哪两门学科最为正相关？</li></ul><h3 id="Cluster-Identification"><a href="#Cluster-Identification" class="headerlink" title="Cluster-Identification"></a>Cluster-Identification</h3><ul><li>Q： 在哪对维度上有明显的簇？（找视觉上聚在一起的点或线）</li></ul><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><h3 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h3><p> 人造的学生成绩数据，共15个。3个训练集，12个用于正式实验。</p><ul><li>包括两个难易程度：容易6个、难6个。通过数据密度和答案选对的难易程度来控制题目的难易程度。</li><li>容易：100-120个数据项；正确答案与候选答案之间相差较远。</li><li>难：180-200个数据项；正确答案与几个候选答案之间很接近。</li></ul><h3 id="参与者"><a href="#参与者" class="headerlink" title="参与者"></a>参与者</h3><p> 实验分成A、B两个部分进行，每部分完成3个任务，时间花费在45分钟左右。参加A部分的人完成前3个任务，参加B部分的人完成后3个任务。</p><ul><li>每个参与者需要完成：3（任务）<em>12（数据）</em>3（可视化）次试验。</li></ul><h4 id="实验参与人员结构："><a href="#实验参与人员结构：" class="headerlink" title="实验参与人员结构："></a>实验参与人员结构：</h4><p> 全部来自于大学里的学生或工作人员。</p><ul><li>参加A部分的人，21名，8女13男；</li><li>参加B部分的人，30名，9女21男；</li><li>其中有9个人，同时参与两部分实验；</li><li>年龄在19岁-55岁，平均年龄为29岁。</li></ul><h3 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h3><h4 id="电脑配置"><a href="#电脑配置" class="headerlink" title="电脑配置"></a>电脑配置</h4><ul><li>英特尔酷睿i7 MacBook Pro（2016）和24英寸屏幕（1920×1080）</li></ul><h4 id="使用Tobii-X3-120眼动仪"><a href="#使用Tobii-X3-120眼动仪" class="headerlink" title="使用Tobii X3-120眼动仪"></a>使用Tobii X3-120眼动仪</h4><ul><li>跟踪参与者眼睛在屏幕上的移动情况，收集数据，为后面分析参与者使用组合视图时使用的策略作准备。</li></ul><h4 id="交互方式"><a href="#交互方式" class="headerlink" title="交互方式"></a>交互方式</h4><ul><li>通过鼠标和键盘进行答题和操作。</li></ul><h3 id="实验设计"><a href="#实验设计" class="headerlink" title="实验设计"></a>实验设计</h3><ul><li>分成A，B两部分：A：完成前3个任务；B：完成后3个任务；</li><li>为了实验条件平衡，每部分的参与者又分成2组，一组先用单独的一种可视化，后用组合可视化；另一组先用组合可视化，后用单独的可视化；对于同一个数据集，参与者在用不同可视化技术回答问题时，通过改变数据中学生的姓名和维度的排列顺序来避免可视化技术之间的影响；</li><li>每个参与者的问题顺序随机；</li><li>屏幕上方有计时条，参与者最多有30s使用可视化的时间；若在30s之内有答案，可按空格键停止计时；</li><li>屏幕弹出答案选项，包括几个候选答案，以及“太难”、“都不是”选项。</li></ul><h3 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h3><p> 1 .背景知识调查，调查参与者以往对两种可视化方法是否了解过。结果如图3所示。对于PCP技术，49%的人从未见过；而对于SPLOM技术，43%的人偶尔使用。</p><p><img src="http://p8ay1ez22.bkt.clouddn.com/18-5-20/96842735.jpg" alt="图3"></p><blockquote><p>图3 参与者背景知识调查结果</p></blockquote><p> 2 .眼动仪校准<br> 要求参与者对眼动仪进行校准，用时不超过30秒。</p><p> 3 .训练<br> 包括内容：</p><ul><li>指导每个参与者如何用可视化完成任务；</li><li>每个任务有3个实例，训练之后给出正确答案；</li><li>通过第一个实例来演示交互技术；正确通过一个实例后才能进入下一个实例；</li><li><p>告诉参与者答题时间的限制，要尽可能快和准地完成实验。</p><p>4 .正式实验<br>为每个参与者，呈现3种视图，每个视图都包含3个任务，每个任务包含12个不同数据集的问题。</p><p>5 . 收集反馈</p></li><li>收集参与者对3种可视化方法在每个任务上的排名；</li><li>收集参与者对每个可视化方法的优缺点评论。</li></ul><h2 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h2><h3 id="数据分析"><a href="#数据分析" class="headerlink" title="数据分析"></a>数据分析</h3><h4 id="数据收集"><a href="#数据收集" class="headerlink" title="数据收集"></a>数据收集</h4><ul><li>每次试验的完成时间</li><li>每次试验的准确率</li><li>眼睛和鼠标的移动数据</li><li>对于每个任务，参与者对可视化技术的主观偏好</li></ul><h4 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h4><ul><li>移除6次不合理数据，完成时间小于1s</li><li>移除选“太难” 或“都没有” 的试验</li></ul><h4 id="统计分析"><a href="#统计分析" class="headerlink" title="统计分析"></a>统计分析</h4><ul><li>数据不服从正态分布，使用Friedman test检验数据的总体差异性</li><li>由于移除了不合理的数据导致样本量不等，成对差异比较使用Mann-Whitney U test</li></ul><h3 id="眼动仪数据分析"><a href="#眼动仪数据分析" class="headerlink" title="眼动仪数据分析"></a>眼动仪数据分析</h3><p> 通过分析眼动仪数据来了解参与者使用<strong>组合视图</strong>采用的策略。</p><h4 id="数据收集-1"><a href="#数据收集-1" class="headerlink" title="数据收集"></a>数据收集</h4><p> 组合视图中的每次试验，测量参与者花在观察两个AOI（兴趣区域），即PCP和SPLOM上各自的停留和访问持续时间，用于检查和识别参与者策略。 </p><h4 id="策略分类结果，总共分为5种，如图4所示。"><a href="#策略分类结果，总共分为5种，如图4所示。" class="headerlink" title="策略分类结果，总共分为5种，如图4所示。"></a>策略分类结果，总共分为5种，如图4所示。</h4><ul><li>只看SPLOM，每次在PCP上停留时间不超过1s。</li><li>只看PCP，每次在SPLOM上停留时间不超过1s。</li><li>先看SPLOM，后看PCP，每次来回切换的停留时间不超过1s。</li><li>先看PCP，后看SPLOM，每次来回切换的停留时间不超过1s。</li><li>参与者视线在两个视图上频繁切换。</li></ul><p><img src="http://p8ay1ez22.bkt.clouddn.com/18-5-20/75032469.jpg" alt="图4"></p><blockquote><p>图4 组合视图中5种常见的使用策略</p></blockquote><h3 id="任务结果"><a href="#任务结果" class="headerlink" title="任务结果"></a>任务结果</h3><h4 id="T1：Best-Performer"><a href="#T1：Best-Performer" class="headerlink" title="T1：Best-Performer"></a>T1：Best-Performer</h4><ul><li>时间，3种技术无显著差异</li><li>准确率，PCP和Combined视图显著高于SPM</li><li>参与者更喜欢用PCP视图</li><li>眼追踪数据表明，参与者花在PCP上的时间多于SPLOM</li></ul><h4 id="T2：Subset-Tracing"><a href="#T2：Subset-Tracing" class="headerlink" title="T2：Subset-Tracing"></a>T2：Subset-Tracing</h4><ul><li>时间，PCP和Combined视图显著快于SPLOM</li><li>准确率，SPLOM显著最差</li><li>参与者更喜欢用PCP视图</li><li>眼追踪数据表明，Combined视图中，参与者花在PCP上的时间更多</li></ul><h4 id="T3：Object-Comparison"><a href="#T3：Object-Comparison" class="headerlink" title="T3：Object-Comparison"></a>T3：Object-Comparison</h4><ul><li>时间，3种技术无显著差异</li><li>准确率，SPLOM显著最差</li><li>参与者更喜欢用Combined视图</li><li>眼追踪数据表明，表明频繁切换视图策略最受欢迎，单独使用PCP与先使用PCP的比例相同，无人单独使用SPLOM</li></ul><h4 id="T4-Outlier-Detection"><a href="#T4-Outlier-Detection" class="headerlink" title="T4: Outlier-Detection"></a>T4: Outlier-Detection</h4><ul><li>时间，PCP显著多于SPLOM和Combined视图</li><li>准确率，SPLOM和Combined视图显著高于PCP</li><li>参与者更喜欢用Combined视图</li><li>眼追踪数据表明，频繁切换和先使用SPLOM最受欢迎</li></ul><h4 id="T5-Correlation-Estimation"><a href="#T5-Correlation-Estimation" class="headerlink" title="T5: Correlation-Estimation"></a>T5: Correlation-Estimation</h4><ul><li>时间，PCP显著多于SPLOM和Combined视图</li><li>准确率，所有技术之间都有显著性，SPLOM&gt;C&gt;PCP</li><li>参与者更喜欢用SPLOM视图</li><li>眼追踪数据表明，无人单独使用PCP，单独使用SPLOM的人最多</li></ul><h4 id="T6-Cluster-Identification"><a href="#T6-Cluster-Identification" class="headerlink" title="T6: Cluster-Identification"></a>T6: Cluster-Identification</h4><ul><li>时间，SPLOM显著快于其余两个</li><li>准确率，Combined视图最高，其次是SPLOM，最后是PCP</li><li>参与者更喜欢用SPLOM视图</li><li>眼追踪数据表明，只使用SPLOM的人最多，无人只使用PCP</li></ul><blockquote><p>图5，图6，图7，图8展示了相关结果</p></blockquote><p><img src="http://p8ay1ez22.bkt.clouddn.com/18-5-20/17397410.jpg" alt="图5"></p><blockquote><p>图5 按任务分类的三种可视化技术中每一种的平均结果。黄色背景表明该值与相同指标下的其他值有显著差异；黑色加粗字体表明是该指标下的最优值。</p></blockquote><p><img src="http://p8ay1ez22.bkt.clouddn.com/18-5-20/12855836.jpg" alt="图6"></p><blockquote><p>图6 按任务分类的三种可视化技术中每一种的完成时间的平均值和标准偏差。</p></blockquote><p><img src="http://p8ay1ez22.bkt.clouddn.com/18-5-20/52541686.jpg" alt="图7"></p><blockquote><p>图7 按任务分类的三种可视化技术中每一种的准确率平均值和标准偏差。</p></blockquote><p><img src="http://p8ay1ez22.bkt.clouddn.com/18-5-20/82786381.jpg" alt="图8"></p><blockquote><p>图8 (a)每个任务下，参与者在Combined视图中的偏好选择；(b)每个任务下，参与者在Combined视图中使用的策略情况。</p></blockquote><h4 id="视图使用情况对比"><a href="#视图使用情况对比" class="headerlink" title="视图使用情况对比"></a>视图使用情况对比</h4><p> 组合视图中，参与者花费在每个视图中的时间对比图，如图9所示。</p><blockquote><p>发现：在前3个任务中，多数参与者使用PCP 1st and Parallel Use两种策略；后3个任务，则多数参与者使用SPLOM 1st and Parallel Use 两种策略</p></blockquote><p><img src="http://p8ay1ez22.bkt.clouddn.com/18-5-20/19142179.jpg" alt="图9"></p><blockquote><p>图9 用于查看Combined视图中每个视图的相对时长（栏高度）；1-3是训练任务。</p></blockquote><h2 id="结论总结"><a href="#结论总结" class="headerlink" title="结论总结"></a>结论总结</h2><p> 提出PCP和SPLOM的组合表示，主要探讨并评估多维数据的感知互补视图的影响。</p><ul><li><p><strong>PCP和SPLOM视图在感知上是互补的。</strong></p><p>SPLOM点可视化可以帮助参与者理解整体（后3个Tasks）,PCP线可视化帮助参与者识别单个观察点，两种结合既可以解决整体任务又可以解决细节任务。</p></li><li><p><strong>并排放置感知互补的视图是获得两者优点的有效方法。</strong></p><p>以往用复杂的设计和交互手段使两个技术结合成一种可视化方案并不是没有效果，但是这种效果普通参与者无法体验。更为直接的方法就是让两个视图并排放置在一起，本文的实验结果证明了这种做法是有效的。</p></li><li><p><strong>基于眼动追踪数据，针对组合视图确定了五种常用视图使用策略。</strong></p></li><li><p><strong>有些人在没有意识的情况下使用互补视图的优势。</strong></p><p>参与者给出的每个任务下对技术的主观偏好与眼动仪追踪数据分析的结果并不完全一致，使用组合视图时，参与者主观偏好某一种可视化技术，但是眼动仪数据表明他们使用组合策略时间更久。这说明参与者其实在没有意识的情况下已经体验了互补视图的优势。</p></li><li><p><strong>当一个视图对于特定任务明显比另一视图更好时，使用组合视图会有更多的时间开销。</strong></p><p>例如分析任务5，SPLOM视图明显比PCP更适合。当使用Combined视图时，会花费更多的时间，但是准确率仍然能够保证。</p></li></ul><h2 id="缺陷与未来工作"><a href="#缺陷与未来工作" class="headerlink" title="缺陷与未来工作"></a>缺陷与未来工作</h2><h3 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h3><ul><li><p>尽管得出组合视图在6个任务中的5个上都表现好，但是标准偏差比较高。</p></li><li><p>整个实验使用的数据密度(100-200)太小，数据结构单一。意味着碰到数据密度很大，或者其他数据结构时，本文的实验结果不一定适用。</p></li></ul><h3 id="未来研究方向"><a href="#未来研究方向" class="headerlink" title="未来研究方向"></a>未来研究方向</h3><ul><li><p>研究互补性对其他类型数据集的影响（例如，对于分层数据和动态网络）。</p></li><li><p>哪些视图可以产生互补效应？有没有有效的分类？一个视图以数据项为中心（例如PCP和节点链接图）和一个视图以关系为中心（如SPLOM和邻接矩阵），这是不是一种有效的分类呢？还需要更多的研究。</p></li><li><p>可以进一步研究训练对人们使用组合图的有效性的影响。有经验的参与者知道利用Combined视图的优势，而无经验的用户则可能只会使用单个视图，说明训练对人们的策略使用是有影响的。还可以进一步确定组合图的使用是否有助于人们学习更有效地使用单个视图。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;报告：多维数据的感知互补视图评估&quot;&gt;&lt;a href=&quot;#报告：多维数据的感知互补视图评估&quot; class=&quot;headerlink&quot; title=&quot;报告：多维数据的感知互补视图评估&quot;&gt;&lt;/a&gt;报告：多维数据的感知互补视图评估&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;论文原文：An 
      
    
    </summary>
    
      <category term="可视化论文 summary" scheme="http://ipine.github.io/categories/%E5%8F%AF%E8%A7%86%E5%8C%96%E8%AE%BA%E6%96%87-summary/"/>
    
    
      <category term="reading notes" scheme="http://ipine.github.io/tags/reading-notes/"/>
    
      <category term="paper" scheme="http://ipine.github.io/tags/paper/"/>
    
  </entry>
  
  <entry>
    <title>Flex布局</title>
    <link href="http://ipine.github.io/2018-05-13/"/>
    <id>http://ipine.github.io/2018-05-13/</id>
    <published>2018-05-13T12:59:00.000Z</published>
    <updated>2018-05-19T14:02:32.332Z</updated>
    
    <content type="html"><![CDATA[<p>最近在做一个关于区块链可视化的前端页面练习，尝试了flex布局，作个简单的summary。</p><h3 id="网页布局"><a href="#网页布局" class="headerlink" title="网页布局"></a>网页布局</h3><p>区块图展示部分刚开始使用的是布局的传统解决方案: 基于盒状模型，依赖<code>display</code>属性+<code>position</code>属性+<code>float</code>属性，后来发现Flex弹性布局更好用，垂直方向居中完全不是问题，盒子换行放置也很easy。</p><p>Flex布局即是一种弹性布局。任何一个容器都可以指定为Flex布局<code>（display:flex）</code>，行内元素也可以使用<code>（display:inline-flex）</code>。</p><blockquote><p>注意：设为Flex布局以后，子元素的float,clear,和vertical-align属性将失去作用。</p></blockquote><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>采用 Flex 布局的元素，称为 Flex 容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称”项目”。</p><h4 id="容器的属性"><a href="#容器的属性" class="headerlink" title="容器的属性"></a>容器的属性</h4><p><img src="http://p8ay1ez22.bkt.clouddn.com/18-5-19/84888199.jpg" alt="容器"></p><p>每个属性对应的含义是：</p><p> • 项目排列方向；可取四个值： <code>row | row-reverse | column | column-reverse</code><br> • 项目是否换行，怎么换；可取三个值： <code>nowrap | wrap | wrap-reverse</code><br> • 前2个属性的简写; 取值： <code>&lt;flex-direction&gt; || &lt;flex-wrap&gt;</code><br> • 项目在主轴上的对齐方式，与主轴的方向有关；可取五个值： <code>flex-start | flex-end | center | space-between | space-around</code><br> • 项目在交叉轴上的对齐方式,与交叉轴的方向有关；可取五个值： <code>flex-start | flex-end | center | baseline | stretch</code><br> • 多根轴线的对齐方式，若项目只有一根轴线，该属性不起作用；可取六个值： <code>flex-start | flex-end | center | space-between | space-around | stretch</code></p><h4 id="项目的属性"><a href="#项目的属性" class="headerlink" title="项目的属性"></a>项目的属性</h4><p><img src="http://p8ay1ez22.bkt.clouddn.com/18-5-19/10672781.jpg" alt="项目"></p><p>每个属性对应的含义是：</p><p> • 项目排列顺序，值越小，排列越靠前；默认为0<br> • 有多余空间时，项目是否放大；默认为0，不放大<br> • 空间不够时，项目是否缩小；默认为1，缩小<br> • 分配多余空间之前，项目占据的主轴空间；默认为auto,即原本大小<br> • <code>flex-grow</code>, <code>flex-shrink</code> 和 <code>flex-basis</code>属性的简写（优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值），常用的两个快捷值： <code>auto(1 1 auto)和none(0 0 auto)</code><br> • 允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性；默认值为auto</p><h3 id="我的布局"><a href="#我的布局" class="headerlink" title="我的布局"></a>我的布局</h3><h4 id="HTML结构"><a href="#HTML结构" class="headerlink" title="HTML结构"></a>HTML结构</h4><p> 1 . 包含所有区块的大div -&gt;.d3layout（容器）；<br> 2 . 大div里包含3个次大div -&gt;.block-row（既是容器又是项目）；<br> 3 . 每个次大div里包含5个或者2个小div -&gt; .block/.block_0（项目）；</p><p><img src="http://p8ay1ez22.bkt.clouddn.com/18-5-19/19741905.jpg" alt="HTML结构"></p><h4 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h4><h5 id="第一层的大div"><a href="#第一层的大div" class="headerlink" title="第一层的大div"></a>第一层的大div</h5><pre><code>.d3layout{    width: 935px;    margin: 20px 0;    height: 740px;/*flex布局容器*/    display: flex;    flex-flow: row wrap;    justify-content: flex-start;    align-items: flex-start;    align-content: space-around;}</code></pre><h5 id="第二层的次大div"><a href="#第二层的次大div" class="headerlink" title="第二层的次大div"></a>第二层的次大div</h5><pre><code>.rowTop,.rowMiddle,.rowBottom{    height: 202px;    width: 935px;/*flex布局项目*/    flex: auto; /*（1，1，auto）*//*flex布局容器*/    display: flex;    flex-flow: row wrap;    justify-content: space-between;    align-items: center;}</code></pre><h5 id="第三层的小div"><a href="#第三层的小div" class="headerlink" title="第三层的小div"></a>第三层的小div</h5><pre><code>.block_0{    width: 703px;    height: 180px;  /*flex布局项目*/     flex: 0 1 auto;}.block{    width: 145px;    height: 180px;/*flex布局项目*/    flex: 0 1 auto;}</code></pre><h4 id="布局效果"><a href="#布局效果" class="headerlink" title="布局效果"></a>布局效果</h4><p>黑色为大div；红色为次大div；灰色为小div</p><p><img src="http://p8ay1ez22.bkt.clouddn.com/18-5-19/86157629.jpg" alt="效果图"></p><p>最终在实践过程中，又添了一层，灰色小div.block里还包括上下两个div，仍然用的flex布局。</p><p>注：<a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html?^%$" target="_blank" rel="noopener">基本概念参考来源</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近在做一个关于区块链可视化的前端页面练习，尝试了flex布局，作个简单的summary。&lt;/p&gt;
&lt;h3 id=&quot;网页布局&quot;&gt;&lt;a href=&quot;#网页布局&quot; class=&quot;headerlink&quot; title=&quot;网页布局&quot;&gt;&lt;/a&gt;网页布局&lt;/h3&gt;&lt;p&gt;区块图展示部分刚开
      
    
    </summary>
    
      <category term="technique summary" scheme="http://ipine.github.io/categories/technique-summary/"/>
    
    
      <category term="javascript" scheme="http://ipine.github.io/tags/javascript/"/>
    
      <category term="css" scheme="http://ipine.github.io/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>Twice linear</title>
    <link href="http://ipine.github.io/2018-05-07/"/>
    <id>http://ipine.github.io/2018-05-07/</id>
    <published>2018-05-07T13:34:00.000Z</published>
    <updated>2018-05-07T13:41:14.054Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>Consider a sequence u where u is defined as follows:<br>1 . The number u(0) = 1 is the first one in u.<br>2 . For each x in u, then y = 2 <em> x + 1 and z = 3 </em> x + 1 must be in utoo.<br>3 . There are no other numbers in u.<br>Ex: u = [1, 3, 4, 7, 9, 10, 13, 15, 19, 21, 22, 27, …]<br>1 gives 3 and 4, then 3 gives 7 and 10, 4 gives 9 and 13, then 7 gives 15 and 22 and so on…</p><ul><li>Task: Given parameter n the function dbl_linear (or dblLinear…) returns the element u(n) of the ordered (with &lt;) sequence u.</li><li>Example: dbl_linear(10) should return 22</li><li>Note: Focus attention on efficiency</li></ul><h3 id="我的代码"><a href="#我的代码" class="headerlink" title="我的代码"></a>我的代码</h3><pre><code>function dblLinear(n) {    // your code    var res = [1];    var i=0,j=0;    while(res.length &lt;= n){      var y = res[i]*2+1;      var z = res[j]*3+1;      if(y&lt;z){        res.push(y);        i++;      }else if(y==z){        res.push(y);        i++;        j++;      }else{        res.push(z);        j++;      }    }    return res[n];}</code></pre><h3 id="Clever"><a href="#Clever" class="headerlink" title="Clever"></a>Clever</h3><pre><code>function dblLinear(n) { var ai = 0, bi = 0, eq = 0; var sequence = [1]; while (ai + bi &lt; n + eq) {  var y = 2 * sequence[ai] + 1;  var z = 3 * sequence[bi] + 1; if (y &lt; z) {   sequence.push(y);  ai++;  } else if (y &gt; z) {  sequence.push(z);  bi++; } else {   sequence.push(y);  ai++; bi++; eq++;  }} return sequence.pop();}</code></pre><h3 id="Key"><a href="#Key" class="headerlink" title="Key"></a>Key</h3><ul><li>考虑效率问题，就不能将所有值都放入数组，再来排序，去重；且这种解法，不好控制循环的次数；</li><li>想到在push元素进数组时就按从小到大的顺序放入，且遇到相同的元素就只push一次进数组</li><li>具体思路就是每次将y和z中较小的一个放入数组，同时其对应的计数器+1；若y和z相等，放任意一个进数组，两个计算器都+1</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;Consider a sequence u where u is defined as follows:&lt;br&gt;1 . Th
      
    
    </summary>
    
      <category term="technique" scheme="http://ipine.github.io/categories/technique/"/>
    
    
      <category term="javascript" scheme="http://ipine.github.io/tags/javascript/"/>
    
      <category term="codewars" scheme="http://ipine.github.io/tags/codewars/"/>
    
  </entry>
  
  <entry>
    <title>Adding Big Numbers</title>
    <link href="http://ipine.github.io/2018-05-06/"/>
    <id>http://ipine.github.io/2018-05-06/</id>
    <published>2018-05-06T12:31:00.000Z</published>
    <updated>2018-05-06T12:57:11.607Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>We need to sum big numbers and we require your help.<br>Write a function that returns the sum of two numbers. The input numbers are strings and the function must return a string.<br>Example<br>add(“123”, “321”); -&gt; “444”<br>add(“11”, “99”); -&gt; “110”</p><p>Notes</p><ul><li>The input numbers are big.</li><li>The input is a string of only digits</li><li>The numbers are positives</li></ul><h3 id="我的代码"><a href="#我的代码" class="headerlink" title="我的代码"></a>我的代码</h3><pre><code>function add(a, b) {  var arra =a.split(&apos;&apos;);  var arrb =b.split(&apos;&apos;);  var len = a.length &gt; b.length?a.length:b.length;  var result = [];  var count = 0;  for(i=0; i&lt;len; i++){    var temp;    if(i&gt;=a.length){      temp = Number(arrb.pop()) + count;    }else if(i&gt;=b.length){      temp = Number(arra.pop()) + count;    }else{      temp = (Number(arra.pop()) + Number(arrb.pop())) + count;    }    temp &gt;= 10?[temp,count]=[temp-10,1]:count=0;    result.push(temp);  }  result.push(count); // console.log(result);  return result.reverse().join(&apos;&apos;).replace(/^0+/,&apos;&apos;);//   return Number(a) + Number(b); // Fix this!}</code></pre><h3 id="Clever"><a href="#Clever" class="headerlink" title="Clever"></a>Clever</h3><pre><code>function add (a, b) { var res = &apos;&apos;, c = 0 ; a = a.split(&apos;&apos;); b = b.split(&apos;&apos;); while (a.length || b.length || c) {   c += ~~a.pop() + ~~b.pop();  res = c % 10 + res;  c = c &gt; 9; }  return res; }</code></pre><h3 id="Key"><a href="#Key" class="headerlink" title="Key"></a>Key</h3><p>1 . 思路是将a和b的最后一位相加，如果相加的结果大于10，取个位数部分，进位值<code>count+1</code>；并将结果放入到数组中。<br>2 . 要一位一位相加，需要把a和b两个字符串转成字符串数组，用到<code>.split()</code>函数。<br>3 . 还要注意判断a串和b串哪个更长，最后循环完后需要将最后一次的进位值放入数组。<br>4 . 以上步骤得到的数组不是最终结果，还要先<code>翻转</code>，再将字符串数组<code>变成字符串</code>，最后用<code>.replace()</code>方法将首位的0去掉。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;We need to sum big numbers and we require your help.&lt;br&gt;Write 
      
    
    </summary>
    
      <category term="technique" scheme="http://ipine.github.io/categories/technique/"/>
    
    
      <category term="javascript" scheme="http://ipine.github.io/tags/javascript/"/>
    
      <category term="codewars" scheme="http://ipine.github.io/tags/codewars/"/>
    
  </entry>
  
  <entry>
    <title>Find the missing term in an Arithmetic Progression</title>
    <link href="http://ipine.github.io/2018-05-02/"/>
    <id>http://ipine.github.io/2018-05-02/</id>
    <published>2018-05-02T05:42:00.000Z</published>
    <updated>2018-05-02T06:20:58.128Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>An Arithmetic Progression is defined as one in which there is a constant difference between the consecutive terms of a given series of numbers. You are provided with consecutive elements of an Arithmetic Progression. There is however one hitch: exactly one term from the original series is missing from the set of numbers which have been given to you. The rest of the given series is the same as the original AP. Find the missing term.<br>You have to write the function findMissing(list), list will always be at least 3 numbers. The missing term will never be the first or last one.</p><p>Example :<br>findMissing([1,3,5,9,11]) == 7</p><blockquote><p>PS: This is a sample question of the facebook engineer challenge on interviewstreet. I found it quite fun to solve on paper using math, derive the algo that way.</p></blockquote><h3 id="我的代码"><a href="#我的代码" class="headerlink" title="我的代码"></a>我的代码</h3><pre><code>var findMissing = function (list) {   var len = list.length;  var x = Math.abs((list[1]-list[0])) &lt; Math.abs((list[len-1]-list[len-2])) ? Math.abs((list[1]-list[0])):Math.abs((list[len-1]-list[len-2]));  console.log(x);  for(i=0; i&lt;len; i++){    if(list[len-1] &gt; list[0]){      if(list.indexOf(list[i]+x) == -1)      return list[i]+x;    }else if(list[len-1] &lt; list[0]){      if(list.indexOf(list[i]-x) == -1)      return list[i]-x;    }  }}</code></pre><h3 id="Clever"><a href="#Clever" class="headerlink" title="Clever"></a>Clever</h3><pre><code>var findMissing = function (list) {     var step = (list[list.length - 1] - list[0]) / (list.length);     return list.filter(function(val, index) { return val !== (list[0] + index * step); })[0] - step; }</code></pre><h3 id="Key"><a href="#Key" class="headerlink" title="Key"></a>Key</h3><ul><li><p>关键点1要找到等差值，利用题目中给的信息：第一个和最后一个数不会缺失；将这两个数分别与它们的后一个和前一个数相减，小的那个差就是等差值；</p></li><li><p>关键点2要注意数列中可能有负数，按照关键点1求等差值的做法，则求解的时候要取绝对值；且需要判断数列是递增还是递减；</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;An Arithmetic Progression is defined as one in which there is 
      
    
    </summary>
    
      <category term="technique" scheme="http://ipine.github.io/categories/technique/"/>
    
    
      <category term="javascript" scheme="http://ipine.github.io/tags/javascript/"/>
    
      <category term="codewars" scheme="http://ipine.github.io/tags/codewars/"/>
    
  </entry>
  
  <entry>
    <title>Range Extraction</title>
    <link href="http://ipine.github.io/2018-05-01/"/>
    <id>http://ipine.github.io/2018-05-01/</id>
    <published>2018-05-01T05:30:00.000Z</published>
    <updated>2018-05-01T11:47:36.530Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>A format for expressing an ordered list of integers is to use a comma separated list of either<br>• individual integers<br>• or a range of integers denoted by the starting integer separated from the end integer in the range by a dash, ‘-‘. The range includes all integers in the interval including both endpoints. It is not considered a range unless it spans at least 3 numbers. For example (“12, 13, 15-17”)<br>Complete the solution so that it takes a list of integers in increasing order and returns a correctly formatted string in the range format.</p><p>Example:<br>solution([-6, -3, -2, -1, 0, 1, 3, 4, 5, 7, 8, 9, 10, 11, 14, 15, 17, 18, 19, 20]);<br>// returns “-6,-3-1,3-5,7-11,14,15,17-20”</p><h3 id="我的代码"><a href="#我的代码" class="headerlink" title="我的代码"></a>我的代码</h3><pre><code>function solution(list){ // TODO: complete solution  var str = [];  for (i = 0; i &lt; list.length; i++) {    if ((list[i]+1) !== list[i+1]) {//完全没有连续的情况      str += list[i].toString() + &apos;,&apos;;    } else if ((list[i]+1) === list[i+1] &amp;&amp; (list[i+1]+1) === list[i+2] &amp;&amp; (list[i-1]+1) !== list[i]) {//有2个及其以上连续的情况      str += list[i].toString() + &apos;-&apos;;    } else if (str[str.length-1] === &apos;-&apos; &amp;&amp; (list[i]+1) !== list[i+1]) {//判断是否是range的最后一个元素      str += list[i].toString() + &apos;,&apos;;    } else if ((list[i]-1) === list[i-1] &amp;&amp; (list[i]+1) === list[i+1]) {      //属于range中的元素    } else if ((list[i]-1) === list[i-1] &amp;&amp; (list[i-1]-1) === list[i-2]) {//只有2个连续的情况      str += list[i].toString() + &apos;,&apos;;    } else {//新range开头      str += list[i].toString() + &apos;,&apos;;    }  }   return str.slice(0, -1);//去掉最后的逗号}</code></pre><h3 id="Clever"><a href="#Clever" class="headerlink" title="Clever"></a>Clever</h3><pre><code>function solution(list){ for(var i = 0; i &lt; list.length; i++){  var j = i;  while(list[j] - list[j+1] == -1)   j++;  if(j != i &amp;&amp; j-i&gt;1)  list.splice(i, j-i+1, list[i] +&apos;-&apos;+list[j]);  } return list.join();}</code></pre><h3 id="Key"><a href="#Key" class="headerlink" title="Key"></a>Key</h3><ul><li><p><code>.slice()</code> 方法可返回一个新的数组，包含从 start 到 end （不包括该元素）的 arrayObject 中的元素。（含头不含尾）</p><blockquote><p>语法：arrayObject.slice(start,end)</p></blockquote></li><li><p>用到了<code>.splice()</code>方法，替换数组中的内容。</p><blockquote><p>参数包含:（起始下标，替换长度，替换内容）</p></blockquote></li><li><p><code>i</code>记录range开始位置，<code>j</code>记录range结束位置。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;A format for expressing an ordered list of integers is to use 
      
    
    </summary>
    
      <category term="technique" scheme="http://ipine.github.io/categories/technique/"/>
    
    
      <category term="javascript" scheme="http://ipine.github.io/tags/javascript/"/>
    
      <category term="codewars" scheme="http://ipine.github.io/tags/codewars/"/>
    
  </entry>
  
  <entry>
    <title>Sudoku Solution Validator</title>
    <link href="http://ipine.github.io/2018-04-30/"/>
    <id>http://ipine.github.io/2018-04-30/</id>
    <published>2018-04-30T05:29:00.000Z</published>
    <updated>2018-05-06T10:41:57.798Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>Sudoku Background：<br>Sudoku is a game played on a 9x9 grid. The goal of the game is to fill all cells of the grid with digits from 1 to 9, so that each column, each row, and each of the nine 3x3 sub-grids (also known as blocks) contain all of the digits from 1 to 9. </p><p><img src="http://p8ay1ez22.bkt.clouddn.com/18-5-6/15442296.jpg" alt="题目描述"></p><h3 id="我的代码"><a href="#我的代码" class="headerlink" title="我的代码"></a>我的代码</h3><pre><code>function validSolution(board){  //TODO  var flag = 1;  for(j=0; j&lt;9; j++){    var sumcol = 0;    var sum = 0;// 计算列和是否为45    for(i=0; i&lt;9; i++){      sumcol += board[i][j];    }    if(sumcol != 45){        flag = 0;        break;    }// 计算行和是否为45，利用数组的方法求和    board[j].some(function(item,i){      sum += item;    })    if(sum != 45){      flag = 0;      break;    }  }// 计算前9个宫格的和是否为45  var sumgrid = 0;  for(k=0; k&lt;3; k++){       for(l=0; l&lt;3; l++){      sumgrid += board[k][l];    }  }  if(sumgrid != 45){    flag = 0;  }  if(flag){    return true;  }else{    return false;  }}</code></pre><h3 id="Clever"><a href="#Clever" class="headerlink" title="Clever"></a>Clever</h3><pre><code>function equals45(n){ return n == 45;} function validSolution(board){var sumh = [0,0,0,0,0,0,0,0,0]; var sumv = [0,0,0,0,0,0,0,0,0]; osums = [[0,0,0],[0,0,0],[0,0,0]]; for (var i=0;i&lt;9;i++){  for (var j=0;j&lt;9;j++){  sumh[i] += board[i][j];   sumv[j] += board[i][j]; // 这里我认为应该是board[j][i]  osums[Math.floor(i/3)][Math.floor(j/3)] += board[i][j];  } } for (var i=0;i&lt;3;i++) if (!osums[i].every(equals45))   return false;return (sumh.every(equals45) &amp;&amp; sumv.every(equals45)); }</code></pre><h3 id="Key"><a href="#Key" class="headerlink" title="Key"></a>Key</h3><ul><li><code>every()</code>方法只有数组中每一项执行回调函数结果合部为true才会返回，不然就会返回false。</li></ul><p><a href="http://www.jb51.net/article/81360.htm" target="_blank" rel="noopener">常见的数组操作方法</a></p><p>-这个题的做法实质上是不能正确验证是否是数独解。因为若每个cell都是5，满足行、列、每个9宫格的和为45的条件，但不满足数独解的条件。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;Sudoku Background：&lt;br&gt;Sudoku is a game played on a 9x9 grid. T
      
    
    </summary>
    
      <category term="technique" scheme="http://ipine.github.io/categories/technique/"/>
    
    
      <category term="javascript" scheme="http://ipine.github.io/tags/javascript/"/>
    
      <category term="codewars" scheme="http://ipine.github.io/tags/codewars/"/>
    
  </entry>
  
  <entry>
    <title>Directions Reduction</title>
    <link href="http://ipine.github.io/2018-04-28/"/>
    <id>http://ipine.github.io/2018-04-28/</id>
    <published>2018-04-28T13:33:00.000Z</published>
    <updated>2018-04-30T12:05:46.753Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>Write a function which will take an array of strings and return an array of strings with the needless directions removed (WEST and EAST, NORTH and SOUTH cancel each other out).<br>If everything cancels out, return an empty array (stay in place);</p><p>For example:</p><blockquote><p>dirReduc([“NORTH”, “SOUTH”, “SOUTH”, “EAST”, “WEST”, “NORTH”, “WEST”]) =&gt; [“WEST”]<br>dirReduc([“NORTH”, “SOUTH”, “SOUTH”, “EAST”, “WEST”, “NORTH”]) =&gt; []</p></blockquote><h3 id="我的代码"><a href="#我的代码" class="headerlink" title="我的代码"></a>我的代码</h3><pre><code>function dirReduc(arr){  // ...  for(i=0; i&lt;arr.length; i++){    if(arr[i] == &quot;NORTH&quot;){      arr[i] = 1;    }else if(arr[i] == &quot;SOUTH&quot;){      arr[i] = -1;    }else if(arr[i] == &quot;EAST&quot;){      arr[i] = 2;    }else if(arr[i] == &quot;WEST&quot;){      arr[i] = -2;    }  }//   console.log(arr);  for(i=0; i&lt;arr.length; i++){        if(arr[i] + arr[i+1] == 0){        arr.splice(i,2);        i -=2;        continue;      }   }  for(i=0; i&lt;arr.length; i++){    if(arr[i] == 1){      arr[i] = &quot;NORTH&quot;;    }else if(arr[i] == -1){      arr[i] = &quot;SOUTH&quot;;    }else if(arr[i] == 2){      arr[i] = &quot;EAST&quot;;    }else if(arr[i] == -2){      arr[i] = &quot;WEST&quot;;    }  }  return arr;}</code></pre><h3 id="Clever"><a href="#Clever" class="headerlink" title="Clever"></a>Clever</h3><pre><code>function dirReduc(arr) { var str = arr.join(&apos;&apos;), pattern = /NORTHSOUTH|EASTWEST|SOUTHNORTH|WESTEAST/;  while (pattern.test(str))   str = str.replace(pattern,&apos;&apos;); return str.match(/(NORTH|SOUTH|EAST|WEST)/g)||[]; }</code></pre><h3 id="Key"><a href="#Key" class="headerlink" title="Key"></a>Key</h3><ul><li><p>如何考虑重复判断数组arr里是否还有符合要求的字符对？<br>解决办法：下标i回到0，跳出当前循环，又从第一个元素开始判断剩余数组中的内容，重复这个过程，直到没有符合条件的元素</p></li><li><p>删除的数组的某一项用：<code>splice(index,len,[item])</code><br><em>注：该方法会改变原始数组</em><br>splice有3个参数，它也可以用来替换/删除/添加数组内某一个或者几个值<br><code>index</code>:数组开始下标（要删除的元素的下标）<br><code>len</code>: 替换/删除的长度<br><code>item</code>:替换的值，删除操作的话 item为空</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;Write a function which will take an array of strings and retur
      
    
    </summary>
    
      <category term="technique" scheme="http://ipine.github.io/categories/technique/"/>
    
    
      <category term="javascript" scheme="http://ipine.github.io/tags/javascript/"/>
    
      <category term="codewars" scheme="http://ipine.github.io/tags/codewars/"/>
    
  </entry>
  
  <entry>
    <title>BuildTower</title>
    <link href="http://ipine.github.io/2018-04-27/"/>
    <id>http://ipine.github.io/2018-04-27/</id>
    <published>2018-04-27T06:49:00.000Z</published>
    <updated>2018-05-06T10:43:01.941Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>Build a tower like this:<br>    <img src="http://p8ay1ez22.bkt.clouddn.com/18-5-6/66768733.jpg" alt="题目描述"></p><h3 id="我的代码"><a href="#我的代码" class="headerlink" title="我的代码"></a>我的代码</h3><pre><code>function towerBuilder(nFloors) {  // build here  var arr = [];  for(var i=0; i&lt;=nFloors-1; i++){    var stars = i*2+1;    var space = nFloors-1-i;    arr.push(&quot; &quot;.repeat(space) + &quot;*&quot;.repeat(stars) + &quot; &quot;.repeat(space));  }  return arr;  }</code></pre><h3 id="Clever"><a href="#Clever" class="headerlink" title="Clever"></a>Clever</h3><p>分别计算出空格个数和星星个数，将这些字符连接起来成串，放入字符串数组中。</p><h3 id="Key"><a href="#Key" class="headerlink" title="Key"></a>Key</h3><ul><li>如何生成重复字符？ <code>&quot;字符&quot;.repeat(n)</code> 方法</li><li>如何将字符放入数组: 每次单考虑字符串数组中的一个元素，每个元素都是一串字符，用<code>+</code>连接形成字符串（元素），再使用<code>arr.push()</code> 方法将每个元素依次放入数组。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;Build a tower like this:&lt;br&gt;    &lt;img src=&quot;http://p8ay1ez22.bkt
      
    
    </summary>
    
      <category term="technique" scheme="http://ipine.github.io/categories/technique/"/>
    
    
      <category term="javascript" scheme="http://ipine.github.io/tags/javascript/"/>
    
      <category term="codewars" scheme="http://ipine.github.io/tags/codewars/"/>
    
  </entry>
  
  <entry>
    <title>统计数组中元素出现的次数</title>
    <link href="http://ipine.github.io/2018-04-26/"/>
    <id>http://ipine.github.io/2018-04-26/</id>
    <published>2018-04-26T05:50:00.000Z</published>
    <updated>2018-05-06T10:45:40.167Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="http://p8ay1ez22.bkt.clouddn.com/18-5-6/88042726.jpg" alt="题目描述"></p><h3 id="我的代码"><a href="#我的代码" class="headerlink" title="我的代码"></a>我的代码</h3><pre><code>function deleteNth(arr,n){  // ...  var re = [];  var arr1 = {};  for(i=0; i&lt;arr.length; i++){    !arr1[arr[i]] ? arr1[arr[i]] = 1 : arr1[arr[i]] += 1;    if(arr1[arr[i]] &lt;= n)      re.push(arr[i]);  }  return re;}</code></pre><h3 id="Clever"><a href="#Clever" class="headerlink" title="Clever"></a>Clever</h3><pre><code>function deleteNth(arr,x){    var obj = {};    return arr.filter(function(number){        obj[number] = obj[number] ? obj[number] + 1 : 1        return obj[number] &lt;= x    });}</code></pre><h3 id="Key"><a href="#Key" class="headerlink" title="Key"></a>Key</h3><ul><li><p>定义统计数组中每个元素出现的次数的变量应该是个对象：<code>var arr1 = {}</code>; 而不是一个数组 var arr1 = []; （这样每个元素对应一个出现次数，之后就可检索出，出现某个次数的元素）</p></li><li><p>给一个数组(var re = [];)赋值：不是var re = [0];而是应该用<code>.push()</code>方法，<code>re.push(arr[i])</code>;</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;http://p8ay1ez22.bkt.clouddn.com/18-5-6/88042726.jpg
      
    
    </summary>
    
      <category term="technique" scheme="http://ipine.github.io/categories/technique/"/>
    
    
      <category term="javascript" scheme="http://ipine.github.io/tags/javascript/"/>
    
      <category term="codewars" scheme="http://ipine.github.io/tags/codewars/"/>
    
  </entry>
  
  <entry>
    <title>论文摘要写作思路实践</title>
    <link href="http://ipine.github.io/2018-04-23/"/>
    <id>http://ipine.github.io/2018-04-23/</id>
    <published>2018-04-23T11:09:00.000Z</published>
    <updated>2018-04-25T12:41:56.042Z</updated>
    
    <content type="html"><![CDATA[<h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>第一篇论文是一篇评估论文，在最后改稿阶段，重写了摘要。导师说摘要写得太平淡，读起来像流水账，没有达到发表的标准。<br>正好我那几天读了一篇教人如何写摘要的文章，其中说到摘要写作是有结构可遵循的。于是利用这个机会，就把看到的写作结构拿来实践一番。</p><hr><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><blockquote><p> • 第一句：介绍论文的主题<br> • 第二句：总结以前的工作<br> • 第三句：指出目前的研究有哪些不足之处（没能解决的问题）<br>   前4句介绍想法<br> • 第五句：详细说明研究，解释如何工作的，并讨论你应用它的各种方法<br> • 第六句：总结出为什么你的研究很重要</p></blockquote><h4 id="具体如下："><a href="#具体如下：" class="headerlink" title="具体如下："></a>具体如下：</h4><p>  1 . 引入。思考文章的主题是什么？用一种读者能理解的方式来表达。</p><p>  2 .陈述研究的问题。关键的研究问题是什么？同样，用一个句子表达。第一句话介绍了整个主题，所以现在可以在这个问题上继续讨论，集中在那个主题中的一个关键问题上。</p><p>  3 .用一句话总结为什么至今还没有人能充分的回答/解决你要研究的问题。<br>记住，关键是不要列举人们尝试失败的各种方式，重点是要去说明有一种方法是其他人都没有尝试过的，而这正是你的研究所做的事情。</p><p>  4 .用一句话来解释如何解决这个研究问题的。你在你的研究中采用了什么创新的方法？</p><p>  5 .再一句话说明，你是如何来根据你的想法来实施并完成这项研究的。你是通过科学的实验吗？还是构建了一个软件？或是进行案例研究？这句可能是整个摘要最长的句子。</p><p>  6 .结尾句子，重点放在研究的主要影响是什么？为什么其他人要关心你的研究呢？他们能做什么来进一步研究你的工作。</p><h3 id="我的实践"><a href="#我的实践" class="headerlink" title="我的实践"></a>我的实践</h3><h4 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h4><p><code>1</code><strong>Fuzzy clustering</strong> assigns a probability of membership for a datum to a cluster, which veritably reflects real-world clustering scenarios but significantly increases the complexity of understanding fuzzy clusters. <code>2</code><strong>Many studies</strong> have demonstrated that visualization techniques for multi-dimensional data are beneficial to understand fuzzy clusters. <code>3</code>However, no empirical evidence exists on the effectiveness and efficiency of these visualization techniques <strong>in solving analytical tasks featured by fuzzy clustering</strong>. <code>4</code><strong>In this paper</strong>, we conduct a controlled experiment to evaluate the ability of fuzzy cluster analysis to use four multi-dimensional visualization techniques, namely, parallel coordinate plot, scatterplot matrix, principal component analysis, and Radviz. <code>5</code><strong>First</strong>, we deﬁne the analytical tasks and their representative questions specific to fuzzy cluster analysis. <strong>Then</strong>, we design objective questionnaires to compare the accuracy, time, and satisfaction in using the four techniques to solve the questions. <strong>We also</strong> design subjective questionnaires to collect the experience of volunteers with the four techniques in terms of ease of use, informativeness, and helpfulness. <code>6</code> With a complete experiment process and a detailed result analysis, we test against four hypotheses that are formulated on the basis of our experience, and <strong>provide instructive guidance</strong> for analysts in selecting appropriate and efficient visualization techniques to analyze fuzzy clusters.</p><hr><p>这个摘要基本达到了上面提到的6句话结构，除了第5部分，因为不能用一句话写完，因而用了连词衔接几句话。</p><p><em>PS: 这是论文摘要的最终版本。中途经历了很多次修改，自己改，导师也改，才写出不像流水账的感觉：）</em></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;原因&quot;&gt;&lt;a href=&quot;#原因&quot; class=&quot;headerlink&quot; title=&quot;原因&quot;&gt;&lt;/a&gt;原因&lt;/h3&gt;&lt;p&gt;第一篇论文是一篇评估论文，在最后改稿阶段，重写了摘要。导师说摘要写得太平淡，读起来像流水账，没有达到发表的标准。&lt;br&gt;正好我那几天读了一篇
      
    
    </summary>
    
      <category term="method" scheme="http://ipine.github.io/categories/method/"/>
    
    
      <category term="paper" scheme="http://ipine.github.io/tags/paper/"/>
    
  </entry>
  
  <entry>
    <title>论文Latex排版-初入坑</title>
    <link href="http://ipine.github.io/2018-03-27/"/>
    <id>http://ipine.github.io/2018-03-27/</id>
    <published>2018-03-27T09:35:11.000Z</published>
    <updated>2018-05-02T06:17:28.765Z</updated>
    
    <content type="html"><![CDATA[<h3 id="入坑缘由"><a href="#入坑缘由" class="headerlink" title="入坑缘由"></a><strong>入坑缘由</strong></h3><p>在第一篇研究生投稿论文进入尾声之即，开始学习用<strong>Latex</strong>排版。在此之前，只会用<em>word</em>，别谈什么工具整理参考文献，一切全凭耐心，手动操作。</p><h3 id="模板说明"><a href="#模板说明" class="headerlink" title="模板说明"></a><strong>模板说明</strong></h3><p>由于准备投稿的会议对排版格式有要求，所以在<a href="http://junctionpublishing.org/vgtc/Tasks/camera.html" target="_blank" rel="noopener"><em>官网</em></a>下了参考模板。</p><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a><strong>准备</strong></h3><ul><li>(La)Tex编辑器：Texworks</li><li>格式要求说明/参考模板</li><li>一篇paper</li></ul><h3 id="启动编辑器"><a href="#启动编辑器" class="headerlink" title="启动编辑器"></a><strong>启动编辑器</strong></h3><p>我安装的是Tex Live套装，里面包含texworks。启动方法：</p><blockquote><p>搜索应用程序TeXworks 或者 启动命令窗口cmd，输入TeXworks回车<br>使用texworks的原因及具体的texworks界面介绍<a href="https://liam0205.me/2014/09/08/latex-introduction/" target="_blank" rel="noopener"><em>请参见这里</em></a>。</p></blockquote><p>几乎所有设置都保持默认，只需根据自己需求在工具栏选择排版工具。我主要用到的排版工具是 <em>pdfLaTeX</em> 和 <em>BibTeX</em>。</p><h3 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a><strong>遇到的问题</strong></h3><p> 1 . 注释，引用，引号，斜体，加粗，换行，章节格式，Section简写，行内公式编辑等基本规则<br> 2 . 图片和表格如何引用，单栏和双栏图片如何设置<br> 3 . 表格绘制，版面占据调整，行距，居中怎么实现<br> 4 . 参考文献排版</p><h4 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a><strong>基本语法</strong></h4><p>章节和段落是 <code>\section{} , \subsection{} , \paragraph {}</code><br>有参考模板可以直接将内容替换成自己的，格式就会是预设效果。花括号里写上要使用该格式的内容。</p><p>注释是<code>%</code>，引用<code>\cite{}</code>，加粗 <code>\textbf{}</code>，斜体 <code>\emph{}</code>，换行是双反斜杠 <code>\\</code>，引号包括前引号<code>~</code>和后引号 <code>&#39;&#39;</code>， 章节缩写，根据章节层级数不同而略有区别，例如：section3 ， 缩写引用格式为，<code>\sectionautorefname{}</code> ,花括号里写上具体章节数3 ，得到的最终效果为<code>Sect.3</code>。 再往下一级走，只需添加<code>sub</code>前缀。</p><p>此次论文只有行内公式，具体格式为双美元符内编辑公式<code>$...$</code>，至于公式符号及运算符号,可<a href="https://blog.csdn.net/ying_xu/article/details/51240291" target="_blank" rel="noopener"><em>参考整理</em></a>。</p><h4 id="图片及表格引用，单双栏设置"><a href="#图片及表格引用，单双栏设置" class="headerlink" title="图片及表格引用，单双栏设置"></a><strong>图片及表格引用，单双栏设置</strong></h4><p>不用手动给图片和表格编号，使用<code>\aotoref{}</code>标签即可自动编号，花括号内填<code>label</code>内自己定义的名称。以一个图为例：</p><pre><code>\begin{figure*}[tb] %[tb]表示表格放置在页面上的位置，需要特别注意这里的*号，%若没有它，那么图片会浮在文字上方。添加`*`号，使后面width设置成文本宽度生效\centering % avoid the use of \begin{center}...\end{center} and use \centering instead (more compact) 水平居中设置\includegraphics[scale=1,width=\textwidth]{Fig3.png} %scale设置缩放比例，width设置图片占据的宽度，这里设置成与文本同宽，即双栏；最后一个花括号写要加载的图片名称，默认路径是放在pictures文件夹\caption{} %这里写图题 \label{fig:3} %这里自己定义，引用时用\end{figure*}</code></pre><p>width的宽度还可以为<code>\columnwidth</code>，即为单栏宽度。表格引用与图片类似。</p><h4 id="表格绘制"><a href="#表格绘制" class="headerlink" title="表格绘制"></a><strong>表格绘制</strong></h4><p>目前尝试过的方式有两种：</p><ul><li>手动写LaTeX语法</li><li>线上生成LaTeX语法</li><li>所见即所得方式</li></ul><p>对于手动方式绘制表格，即按照语法，在编辑框内添加。例如添加下图所示的一个三线表：<br><img src="https://i.loli.net/2018/03/25/5ab7a0f41aa75.png" alt="TIM截图20180325211429.png"></p><p>基本语法格式为：</p><pre><code> \begin{table}[tb]\renewcommand\arraystretch{1.5} %控制行距\caption{Datasets used for evaluation.} \label{tab:tabele-2}\scriptsize% \centering% %下面一句是控制整个表格的位置，只占据单栏\resizebox{\columnwidth}{!}{%\begin{tabu}{%lccc} %控制单元格内容居中方式 \toprule\textbf{Datasets} &amp; \textbf{Data Items} &amp; \textbf{Dimensions} &amp; \textbf{Clusters}\\ \midruleIris\cite{F1}(for training) &amp; 150 &amp; 4 &amp; 3 \\Glass\cite{F1} &amp; 214 &amp; 9 &amp; 6 \\Dermatology\cite{F1} &amp; 259 &amp; 34 &amp; 6  \\Heart Disease\cite{F1}(for training) &amp; 303 &amp; 14 &amp; 5 \\Synthetic\cite{F2} &amp; 750 &amp; 12 &amp; 4  \\Concretec\cite{F1} &amp; 1030 &amp; 9 &amp; 4  \\Pendigitsc\cite{F3} &amp; 2498 &amp; 63 &amp; 10  \\ \bottomrule\end{tabu}%}\end{table}</code></pre><p>手动键入以上示例代码还能接受，当表格复杂时，手动绘制线条和控制跨行跨列就显得繁琐，也容易出错。于是有了第二种方式，线上生成LaTeX代码。使用的线上生成LaTeX表格的工具叫<em><a href="http://www.tablesgenerator.com/latex_tables#" target="_blank" rel="noopener">Tables Generator</a></em>，界面简洁，操作方式简单。粘贴或上传表格数据后，表格样式设计与excel操作类似，设计完成后，下方会自动生成LaTeX代码。然后将代码粘贴到相应排版内容处就OK了。</p><p>排版“大表格”时出现了一些问题：</p><p> 1 . 占据双栏，表格太大（宽），页面放不下，且浮在文字上方，用<code>*</code>也解决不了问题；<br> 2 . 占据单栏，大表格变成了mini表格，整体缩小了一两倍；</p><p><strong>解决办法：</strong> 在求助冬哥后，从他发给我的一篇帖子里找到灵感,问题在于一行文字太长没有换行 <img src="https://i.loli.net/2018/03/26/5ab84d2582a35.png" alt="TIM截图20180325214634.png"><br><a href="http://blog.163.com/chen_dawn/blog/static/1125063201318115613703" target="_blank" rel="noopener">原贴参见这里</a><br>强制换行之后，表格基本合格了，但仍然存在问题：</p><ul><li>按照模板预设的格式单元格内容应该垂直居中，实际效果没有；</li><li>单元格太窄，显得字体很挤</li></ul><p>解决这两个问题的过程中，发现了一篇帖子，推“所见即所得”的插入表格法。于是有了下面第三种方式的尝试。主要步骤有3步：</p><p>   1 . 用excel排版好表格，保存成.pdf格式<br>   2 . 用pdfcrop工具（LaTeX工具包内）将刚保存的PDF文件中图片边上的白色剪裁掉。方法如下：<br>将要剪裁的pdf文件与pdfcrop.exe放在同一个文件夹下；然后打开cmd命令行，通过cd进入所在的文件夹；<em>(快捷打开方式：删除当前目录路径，键入cmd，回车）</em> 最后输入<code>pdfcrop input.pdf output.pdf</code><br><code>input.pdf</code> 和 <code>output.pdf</code> 是输入和输出的pdf文件名，改为自己的文件名即可。点击回车之后，output.pdf就会出现在当前文件夹下。 </p><ol start="3"><li><p>在latex中插入“表格”。具体而言，与插入图片的源码类似：</p><p>  \begin{table}<br>  \centering<br>  \includegraphics[width=0.75 \textwidth]{output.pdf}<br>  \caption{Table Caption}<br>  \label{tab:tab-for-table}<br>  \end{table}</p></li></ol><p>采用第三种方式可以解决上面两个问题。但是排版出来的效果图不是很满意，绘制的线条从excel转成pdf时，样式发生了改变，线条看起来比较粗，跟预设效果不一致。</p><p>最终找到了两个问题的解决办法：</p><ul><li>问题1，垂直居中问题主要出现在多行控制的单元格，于是在代码里改变了其所控制的行数，使其居中。后面的<code>{*}</code>控制宽度，*表示自适应<br><img src="https://i.loli.net/2018/03/25/5ab7b1174287d.png" alt="TIM截图20180325222351.png"></li><li>问题2，可以给表格设置行距解决：<br><img src="https://i.loli.net/2018/03/25/5ab7b2f96e642.png" alt="TIM截图20180325223205.png"></li></ul><h4 id="参考文献排版"><a href="#参考文献排版" class="headerlink" title="参考文献排版"></a><strong>参考文献排版</strong></h4><ul><li>参考文献涉及到<em>BibTeX</em>工具。</li><li>操作流程及原理讲解<a href="https://zhuanlan.zhihu.com/p/25013341?refer=jeldor-latex" target="_blank" rel="noopener"><em>请参见这里</em></a></li></ul><p><strong>说明</strong><br> 1 . 根据不同要求，采用的文献引用格式不同，<code>\bibliographystyle{abbrv-doi}</code><br> 2 . 文献数据库名自己定义，<code>\bibliography{&lt;文献数据库名&gt;}</code><br> 3 . 文献数据库是一个<code>.bib</code>文件，里面的内容，可以使用在线工具<a href="https://search.crossref.org/?q=%20Advances%20in%20fuzzy%20clustering%20and%20its%20applications" target="_blank" rel="noopener"><em>Crossref</em></a> 生成<br> 4 . 参考文献生成的编译顺序：</p><blockquote><p>pdfLaTeX -&gt; BibTeX -&gt; pdfLaTeX -&gt; pdfLaTeX</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;入坑缘由&quot;&gt;&lt;a href=&quot;#入坑缘由&quot; class=&quot;headerlink&quot; title=&quot;入坑缘由&quot;&gt;&lt;/a&gt;&lt;strong&gt;入坑缘由&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;在第一篇研究生投稿论文进入尾声之即，开始学习用&lt;strong&gt;Latex&lt;/strong&gt;
      
    
    </summary>
    
      <category term="method" scheme="http://ipine.github.io/categories/method/"/>
    
    
      <category term="tool" scheme="http://ipine.github.io/tags/tool/"/>
    
      <category term="paper" scheme="http://ipine.github.io/tags/paper/"/>
    
  </entry>
  
  <entry>
    <title>表达自己的需求</title>
    <link href="http://ipine.github.io/2018-03-25/"/>
    <id>http://ipine.github.io/2018-03-25/</id>
    <published>2018-03-25T09:06:00.000Z</published>
    <updated>2018-04-16T03:45:19.512Z</updated>
    
    <content type="html"><![CDATA[<h3 id="《人性的弱点》"><a href="#《人性的弱点》" class="headerlink" title="《人性的弱点》"></a><em>《人性的弱点》</em></h3><p>&emsp;&emsp;我们要学会表达真实的自己，遇到不开心的事要主动跟朋友说；为难的工作要主动跟领导说；碍于情面不敢说出口的拒绝要勇敢说出来，只有这样，我们才能与他人建立真实的关系，交到真心的朋友。不然我们永远只能孤身一人扮演“热心肠好人”。<br>&emsp;&emsp;我们要在说话与行动前，多想想自己的需求，要问自己：“我这样说自己会快乐吗？”“我这么做自己会幸福吗？”<br>在我们以往的人生中，把太多注意力放在了别人身上，现在我们要重新聚焦于自己，爱自己、关心自己，为此</p><blockquote><p>我们必须建立一个个原则，要有原则地拒绝和坚持，而不是无底线地迎合和付出。</p></blockquote><p>&emsp;&emsp;只有这样，我们才能让别人看到自己的底线，清楚自己的原则，才能从人情世故中获得真正的解脱。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;《人性的弱点》&quot;&gt;&lt;a href=&quot;#《人性的弱点》&quot; class=&quot;headerlink&quot; title=&quot;《人性的弱点》&quot;&gt;&lt;/a&gt;&lt;em&gt;《人性的弱点》&lt;/em&gt;&lt;/h3&gt;&lt;p&gt;&amp;emsp;&amp;emsp;我们要学会表达真实的自己，遇到不开心的事要主动跟朋友说；为
      
    
    </summary>
    
      <category term="read" scheme="http://ipine.github.io/categories/read/"/>
    
    
      <category term="reading notes" scheme="http://ipine.github.io/tags/reading-notes/"/>
    
  </entry>
  
  <entry>
    <title>黑客与画家</title>
    <link href="http://ipine.github.io/2018-02-27/"/>
    <id>http://ipine.github.io/2018-02-27/</id>
    <published>2018-02-27T13:04:00.000Z</published>
    <updated>2018-04-30T08:45:38.927Z</updated>
    
    <content type="html"><![CDATA[<p> 以下内容是阅读《黑客与画家》时，摘录的关于计算机的一些基础知识。</p><hr><h3 id="低级语言"><a href="#低级语言" class="headerlink" title="低级语言"></a>低级语言</h3><h4 id="什么叫机器语言"><a href="#什么叫机器语言" class="headerlink" title="什么叫机器语言"></a>什么叫机器语言</h4><p> 计算机和其他机器一样，也有一张操作命令清单。比如，可以命令计算机把两个数相加。这种操作命令的总和就是计算机的机器语言（machine language）。</p><h4 id="什么叫汇编语言"><a href="#什么叫汇编语言" class="headerlink" title="什么叫汇编语言"></a>什么叫汇编语言</h4><p> 命令清单还是一样，只是将语言换成更人性化的表达，如计算机中的加，用机器语言表达就是11001101，汇编中就是<code>add</code>。</p><blockquote><p>机器语言和汇编语言的共同问题就是，只能让大多数计算机做一些很简单的事情。</p></blockquote><h4 id="为什么使用低级语言"><a href="#为什么使用低级语言" class="headerlink" title="为什么使用低级语言"></a>为什么使用低级语言</h4><p>当考虑效率问题时。</p><blockquote><p>如果你非常关注运行速度，那么最好使用接近机器的语言。</p></blockquote><p>比如说，C 语言就是一种低层次语言，很接近硬件，几乎堪称可移植的汇编语言。大多数操作系统都是用C语言写的。</p><p><em>那么问题来了，硬件速度越来越快了，底层次语言的作用越来越小，为什么不抛弃C语言呢？</em></p><p><em>原因：人们可能想保留缓存区溢出攻击，使得程序员保持警惕！</em></p><h4 id="缓存区溢出攻击"><a href="#缓存区溢出攻击" class="headerlink" title="缓存区溢出攻击"></a>缓存区溢出攻击</h4><p>当你在C语言中为输入的内容分配出一片内存（<code>缓存</code>）时，它会被分配在当前运行代码的<code>返回地址</code>旁边。</p><ul><li><code>返回地址</code>：指的是一块特定内存，当前代码运行完毕以后，就要运行这块内存中包含的代码。</li><li><code>缓冲区(buffer）</code>: 一个内存区域，用来保存程序需要的输入数据，或者将程序的输出数据累积起来，到一定数量后再输出。</li></ul><p>假定有人打算入侵你的计算机，他们猜出你会为某种输入分配256字节的<code>缓存</code>，于是他们就提交<strong>多于256字节的内容</strong>，目的是覆盖旁边的<code>返回地址</code>。那么，当前代码运行完毕之后，程序的控制权就交给了他们指定的内存地址。这个地址通常是缓存的首地址，当中放的是入侵者事前编好的机器码。于是，入侵者的程序就运行在你的计算机上了。</p><p>在C语言中，一旦接受用户输入的时候<strong>没有检查输入长度</strong>，就创造出了一个安全漏洞。利用这种漏洞的攻击行为就被称为<code>缓存区溢出攻击</code>。</p><blockquote><p>如果使用更抽象的高级语言，上面的事情是不可能发生的。</p></blockquote><h3 id="高级语言-与低级语言的关系"><a href="#高级语言-与低级语言的关系" class="headerlink" title="高级语言,与低级语言的关系"></a>高级语言,与低级语言的关系</h3><p>简便方式书写程序所用的语言就是高级语言，其优点是使得程序更具有可移植性，而不同计算机的机器语言是不一样的。</p><p>高级语言（简便方式书写的程序，就像一行<code>if</code> 语句）可以通过编译器转变为低级语言（硬件可以理解的语言）。</p><h3 id="编译器与解释器区别"><a href="#编译器与解释器区别" class="headerlink" title="编译器与解释器区别"></a>编译器与解释器区别</h3><p><code>编译器</code> 不是低级语言唯一的实现方法，另一种方法是使用<code>解释器</code>。</p><ul><li>解释器： 实时地将代码解释为相应的机器语言，然后一行行运行。</li><li>编译器： 先将整个程序全部翻译成机器语言，然后再运行。</li></ul><blockquote><p>当编程语言变得很抽象时，就可完全脱离硬件，但是问题是太抽象的话，能解决的问题太少。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt; 以下内容是阅读《黑客与画家》时，摘录的关于计算机的一些基础知识。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;低级语言&quot;&gt;&lt;a href=&quot;#低级语言&quot; class=&quot;headerlink&quot; title=&quot;低级语言&quot;&gt;&lt;/a&gt;低级语言&lt;/h3&gt;&lt;h4 id=&quot;什么叫机器语言&quot;&gt;&lt;a
      
    
    </summary>
    
      <category term="read" scheme="http://ipine.github.io/categories/read/"/>
    
    
      <category term="reading notes" scheme="http://ipine.github.io/tags/reading-notes/"/>
    
  </entry>
  
  <entry>
    <title>黑客与画家</title>
    <link href="http://ipine.github.io/2018-01-19/"/>
    <id>http://ipine.github.io/2018-01-19/</id>
    <published>2018-01-19T11:27:00.000Z</published>
    <updated>2018-04-30T08:06:54.400Z</updated>
    
    <content type="html"><![CDATA[<p> 以下内容是阅读《黑客与画家》时，我摘录的一些个人觉得有意思和值得回味的观点。</p><hr><ul><li><h3 id="Popular-的解释"><a href="#Popular-的解释" class="headerlink" title="Popular 的解释"></a><em>Popular</em> 的解释</h3></li></ul><blockquote><p>“受欢迎”的英语单词是popular，这个词还有另一个意思，“大众化的，多数人的”，比如popular support（民意的支持）。此处使用了双关语，作者既是说青少年的行为目的是为了得到同伴的关注和称赞，也是说青少年这样做是为了与群体保持一致。</p></blockquote><ul><li><h3 id="老成-的真实意思"><a href="#老成-的真实意思" class="headerlink" title="老成 的真实意思"></a><em>老成</em> 的真实意思</h3></li></ul><blockquote><p>成年人使用“老成”（tact）这个词，含义似乎就是“闭上嘴巴，不要说话”。我以为它与“缄默”（tacit）和“不苟言笑”（taciturn）有着相同的词根，字面意思就是安静。我就对自己发誓，我绝不要变成“老成”的人，没有人能够让我闭上嘴巴。可是事实上，这个词的词根与“触觉”（tactile）相同，它真正的意思是熟练的碰触。“老成”的反义词是“笨拙”（clumsy）。 </p></blockquote><ul><li><h3 id="创造-优美的事物"><a href="#创造-优美的事物" class="headerlink" title="创造 优美的事物"></a>创造 <em>优美的事物</em></h3></li></ul><blockquote><p>与其说优秀的软件设计师是工程师，还不如说是建筑师[插图]在英语中，“建筑师”（architect）和“架构师”（architect）是同一个词，所以这里用的是双关语，意思是优秀程序员不仅负责建造，还负责架构。后一句中的“建筑学”（architecture）也是这种双关用法，同时指“架构学”（architecture）。</p></blockquote><blockquote><p>优美的软件并不总是论文的合适题材。</p></blockquote><p>1 .首先，科学研究必须具有原创性。<br>2 .其次，科学研究必须是能够产生大量成果的，而那些不成熟的、障碍重重的领域最容易写出许多篇论文，因为你可以写那些为了完成工作、你不得不克服的障碍。没有什么比一个错误的前提更容易产生大量待解决的问题了。</p><p>创造优美事物的方式往往不是从头做起，而是在现有成果的基础上做一些小小的调整，或者将已有的观点用比较新的方式组合起来。这种类型的工作很难用研究性的论文表达。那么，为什么大学和实验室还把论文数量作为考核黑客工作的指标呢？这种事情其实在日常生活中普遍存在，比如，我们使用代码的行数考核程序员的工作效率。。这样的考核容易实施，而容易实施的考核总是首先被采用。</p><ul><li><h3 id="把控细节"><a href="#把控细节" class="headerlink" title="把控细节"></a>把控细节</h3></li></ul><blockquote><p>他(达芬奇)对作品每一部分的认真程度完全不取决于预料中会不会有人仔细看这个部分。他就像篮球巨星迈克尔·乔丹（Michael Jordan），每一球都一丝不苟，绝不降低对自己的要求。<br>坚持一丝不苟，就能取得优秀的成果。因为那些看不见的细节累加起来，就变得可见了。</p></blockquote><p><strong>(这个原则跟上次的反思里，学习学姐的做事态度是一样的，放在自身就是对待学术，写论文要一丝不苟，把细节做好，不断拓宽思路。在写程序上还处于初步阶段，更应该一丝不苟，细节处理到位才行，每一次的修订都是进步，长久积累下来就是看得见的长进。)</strong></p><ul><li><h3 id="思考“不能说的话”"><a href="#思考“不能说的话”" class="headerlink" title="思考“不能说的话”"></a>思考“不能说的话”</h3></li></ul><blockquote><p>有人可能会问，为什么要去找出“不能说的话”？为什么要故意打探那些龌龊的、见不得人的思想观点？你明知那里有挡住去路的石头，为什么还要把它们翻过来看个究竟呢？</p></blockquote><p>1 .首先，我这样做与小孩子翻石头是出于同样的原因：纯粹的好奇心。我对任何被禁止的东西都有特别强烈的好奇心。我要亲眼看一下，然后自己做决定。<br>其次，我这样做是因为我不喜欢犯错。如果像其他时代一样，那些我们自以为正确的事情将来会被证明是荒谬可笑的，我希望自己能够知道是哪些事情，这样可以使我不会上当。</p><p>2 .再次，我这样做，是因为这是很好的脑力训练。想要做出优秀作品，你需要一个什么问题都能思考的大脑。尤其是那些似乎不应该思考的问题，你的大脑也要养成思考它们的习惯。<br>我认为这样做不可取，更好的方法是在思想和言论之间划一条明确的界线。在心里无所不想，但是不一定要说出来。我就鼓励自己在心里默默思考那些最无法无天的想法。你的思想是一个地下组织，绝不要把那里发生的事情一股脑说给外人听。</p><ul><li><h3 id="“元标签”（meta-label）"><a href="#“元标签”（meta-label）" class="headerlink" title="“元标签”（meta-label）"></a>“元标签”（meta-label）</h3></li></ul><blockquote><p>所谓“元标签”，就是对某个标签的抽象描述。如果人们开始讨论元标签，那么原来的标签反而不会受到注意了。举例来说，“政治正确”（political correctness）就是一个“元标签”，是许多特定现象的总称。这个词现在被广泛使用，其实这恰恰意味着“政治正确”的时代正在开始消亡，因为它使得你可以从总体上攻击这个现象，而不会受到指控，不会被说成支持某一种特定的“政治不正确”现象。</p></blockquote><p>如果一个命题不是错的，却被加上各种标签，进行压制和批判，那就有问题。因为只要不是错的观点，就不应该被压制讨论。所以每当你看到有些话被攻击为出自××分子或××主义，这就是一个明确的信号，表明背后有问题。不管在1630年还是在2030年，都是如此。当你听到有人在用这样的标签，就要问为什么。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt; 以下内容是阅读《黑客与画家》时，我摘录的一些个人觉得有意思和值得回味的观点。&lt;/p&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;h3 id=&quot;Popular-的解释&quot;&gt;&lt;a href=&quot;#Popular-的解释&quot; class=&quot;headerlink&quot; title=&quot;Popular 的
      
    
    </summary>
    
      <category term="read" scheme="http://ipine.github.io/categories/read/"/>
    
    
      <category term="reading notes" scheme="http://ipine.github.io/tags/reading-notes/"/>
    
  </entry>
  
</feed>
