<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>iPine</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://ipine.github.io/"/>
  <updated>2018-10-31T12:38:55.642Z</updated>
  <id>http://ipine.github.io/</id>
  
  <author>
    <name>iPine</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>排序</title>
    <link href="http://ipine.github.io/2018-10-30/"/>
    <id>http://ipine.github.io/2018-10-30/</id>
    <published>2018-10-30T06:27:00.000Z</published>
    <updated>2018-10-31T12:38:55.642Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题思考"><a href="#问题思考" class="headerlink" title="问题思考"></a>问题思考</h3><p>插入排序和冒泡排序的时间复杂度相同，都是O(n^2)，在实际软件开发里，为什么更倾向于使用插入排序算法而不是冒泡排序算法呢？</p><h3 id="如何分析一个排序算法"><a href="#如何分析一个排序算法" class="headerlink" title="如何分析一个排序算法"></a>如何分析一个<strong>排序算法</strong></h3><h4 id="排序算法的执行效率"><a href="#排序算法的执行效率" class="headerlink" title="排序算法的执行效率"></a>排序算法的执行效率</h4><p>1 . 最好情况、最坏情况、平均情况时间复杂度<br>分析排序算法的时间复杂度是，要分别给出最好情况、最坏情况、平均情况下的时间复杂度。除此之外，还要说出最好、最坏时间复杂度对应的要排序的原始数据长什么样。</p><p>2 . 时间复杂度的系数、常数、低阶<br>尽管表示时间复杂度时，忽略了系数、常数、低阶。但实际软件开发中，排序的数据可能是10个、100个、1000个这样的小规模数据，因而对于同一阶时间复杂度的排序算法，在比较时，应该把系数、常数和低阶考虑进来。</p><p>3 . 比较次数和交换（移动）次数<br>基于比较的排序算法在执行过程中，会涉及到两种操作，一种是比较元素大小，另一种是元素交换或移动。</p><h4 id="排序算法的内存消耗"><a href="#排序算法的内存消耗" class="headerlink" title="排序算法的内存消耗"></a>排序算法的内存消耗</h4><p>内存消耗可以通过空间复杂度来衡量。针对排序算法的空间复杂度，引入一个新概念，<code>原地排序（Sorted in place）</code>。原地排序算法，就是特指空间复杂度是<code>O(1)</code>的排序算法。</p><blockquote><p>插入排序、冒泡排序、选择排序都是原地排序算法。</p></blockquote><h4 id="排序算法的稳定性"><a href="#排序算法的稳定性" class="headerlink" title="排序算法的稳定性"></a>排序算法的稳定性</h4><p>稳定性指：如果待排序的序列中存在值相等的元素，经过排序后，相等元素之间原有的先后顺序不变。<br>相等元素之间原有的先后顺序没有变，这种排序算法叫作<strong>稳定的排序算法</strong>；否则，叫作<strong>不稳定的排序算法</strong>。</p><h5 id="为什么要考察排序算法的稳定性？"><a href="#为什么要考察排序算法的稳定性？" class="headerlink" title="为什么要考察排序算法的稳定性？"></a>为什么要考察排序算法的稳定性？</h5><p><strong>场景举栗</strong><br>比如说，我们现在要给电商交易系统中的“订单”排序。订单有两个属性，一个是下单时间，另一个是订单金额。<br>如果我们现在有 10 万条订单数据，我们希望按照金额从小到大对订单数据排序。对于金额相同的订单，我们希望按照下单时间从早到晚有序。对于这样一个排序需求，我们怎么来做呢？</p><p><strong>思路分析</strong></p><ul><li>最先想到的方法是：先按照金额对订单数据进行排序，然后，再遍历排序之后的订单数据，对于每个金额相同的小区间再按照下单时间排序。这种排序思路理解起来不难，但是实现起来会很复杂。</li><li><p>更好的方法是：借助稳定排序算法。先按照下单时间给订单排序，注意是按照下单时间，不是金额。排序完成之后，再用稳定排序算法，按照订单金额重新排序。两遍排序之后，得到的订单数据就是按照金额从小到大排序，金额相同的订单按照下单时间从早到晚排序的。</p></li><li><p>原因：稳定排序算法可以保持金额相同的两个对象，在排序之后的前后顺序不变。第一次排序之后，所有的订单按照下单时间从早到晚有序了。在第二次排序中，因为用的是稳定的排序算法，所以经过第二次排序之后，相同金额的订单仍然保持下单时间从早到晚有序。</p></li></ul><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><h4 id="排序过程"><a href="#排序过程" class="headerlink" title="排序过程"></a>排序过程</h4><p>冒泡排序只会操作相邻的两个数据。每次冒泡操作都会对相邻的两个元素进行比较，看是否满足大小关系要求。如果不满足就让它俩互换。一次冒泡会让至少一个元素移动到它应该在的位置，重复 <code>n</code> 次，就完成了 <code>n</code> 个数据的排序工作。</p><h4 id="优化过程"><a href="#优化过程" class="headerlink" title="优化过程"></a>优化过程</h4><p>当某次冒泡操作已经没有数据交换时，说明已经达到完全有序，就不用再继续执行后续的冒泡操作。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><pre><code>def bubble_sort(lt):    length = len(lt)    flag = False    for i in range(0,length):        for j in range(i+1,length):            if lt[i] &gt; lt[j]:                                lt[i], lt[j] = lt[j], lt[i] #数据交换                flag = True        if not flag:            break    return lt</code></pre><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>1 . 冒泡排序只涉及相邻数据的交换操作，只需常量级的临时空间，空间复杂度为<code>O(1)</code>，所以是一个<strong>原地排序算法</strong>。<br>2 . 冒泡排序中只有交换才改变两个元素的前后顺序。为了保证其稳定性，当相邻元素相等时，不做交换，那么相同大小的数据在排序前后不会改变顺序。所以冒泡排序是<strong>稳定</strong>的排序算法。<br>3 . 最好情况下，排序数据已经是有序的，只进行一次冒泡操作，所以时间复杂度是<code>O(n)</code>；最坏情况是，排序的数据刚好是倒序排列的，需要进行n次冒泡操作，所以时间复杂度为<code>O(n^2)</code>；<br>平均时间复杂度，采用一种不严格的方法，通过<strong>有序度</strong>和<strong>逆序度</strong>两个概念来分析。</p><blockquote><p>有序度：数组中具有有序关系的元素对的个数。（默认，从小到大是有序的）</p></blockquote><p>例：2,4,3,5这组数据的有序度为：5，分别是<code>(2,4),(2,3),(2,5),(4,5),(3,5)</code>；同理，对于一个倒序排列的数组，有序度为0；对于一个完全有序的数组，比如2,3,4,5，有序度就是<code>n*(n-1)/2</code>，也就是6。把这种完全有序的数组的有序度叫作<strong>满有序度</strong>。<br><strong>逆有序度</strong>：其定义跟有序度正好相反。</p><blockquote><p>逆有序度 = 满有序度 - 有序度 </p></blockquote><p>排序的过程就是一种增加有序度，减少逆序度的过程，最后达到满有序度，说明排序完成。<br>冒泡排序中，包含两个操作，比较和交换。每交换一次，有序度就加1。不管算法怎么改进，交换次数总是确定的，即为逆序度，也就是等于<code>n*(n-1)/2 - 初始有序度</code>。对于2,4,3,5这组数据来说，6-5=1，只需进行1次交换操作。</p><h4 id="那么对于包含n个数据的数组进行冒泡排序，平均交换次数是多少呢？"><a href="#那么对于包含n个数据的数组进行冒泡排序，平均交换次数是多少呢？" class="headerlink" title="那么对于包含n个数据的数组进行冒泡排序，平均交换次数是多少呢？"></a>那么对于包含n个数据的数组进行冒泡排序，平均交换次数是多少呢？</h4><ul><li><strong>最坏情况</strong>：初始有序度为<strong>0</strong>，需要进行<code>n*(n-1)/2</code>次交换</li><li><strong>最好情况</strong>：初始有序度为 <code>n*(n-1)/2</code>，需要进行<strong>0</strong>次交换</li><li><strong>平均情况</strong>：取一个中间值 <code>n*(n-1)/4</code>，来表示初始有序度既不是很高也不是很低的平均情况。换句话说，平均情况下，需要 <code>n*(n-1)/4</code> 次交换操作，比较操作肯定比交换操作更多，而时间复杂度的上限是 <code>O(n^2)</code>，所以平均情况下的时间复杂度就是 <code>O(n^2)</code>。</li></ul><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>对于一个原本有序的数组，往里面加一个新数据后，如何继续保持数据的有序呢？很简单，只需要遍历数组，找到数据应该插入的位置将其插入即可。</p><blockquote><p>插入排序就是借助这个思想来实现排序的。</p></blockquote><h4 id="排序过程-1"><a href="#排序过程-1" class="headerlink" title="排序过程"></a>排序过程</h4><p>首先，将数组中的数据分为两个区间，已排序区间和未排序区间。初始已排序区间只有一个元素，就是数组的第一个元素。插入算法的核心思想是取未排序区间中的元素，在已排序区间中找到合适的插入位置将其插入，并保证已排序区间数据一直有序。重复这个过程，直到未排序区间中元素为空，算法结束。</p><h4 id="两种操作"><a href="#两种操作" class="headerlink" title="两种操作"></a>两种操作</h4><p>一种是元素的比较，另一种是元素的移动。对于不同的查找插入点方法（从头到尾，从尾到头），元素的比较次数是有区别的。但<strong>对于一个给定的初始序列，移动操作的次数总是固定的，即为逆序度</strong>。（为什么<code>移动次数=逆序度</code>，可以拿个实例画一个图，很容易明白）</p><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><pre><code>def insertion_sort(lt):    length = len(lt)    for i in range(1, length):        value = lt[i]        for j in range(i-1,-1,-1):            if lt[j] &gt; value:                lt[j+1] = lt[j] #数据移动            else:                break #位置确定        lt[j+1] = value  #插入数据    return lt</code></pre><h4 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h4><p>1 . 插入排序算法的运行并不需要额外的存储空间，空间复杂度为 <code>O(1)</code>，所以是一个<strong>原地排序算法</strong>。<br>2 . 插入排序中，对于值相同的元素，可以选择将后面出现的元素，插入到前面出现元素后面，保持原有前后顺序不变。所以插入排序是<strong>稳定</strong>的排序算法。<br>3 . 时间复杂度分析。</p><ul><li><strong>最好情况</strong>：数据已经有序，不需要搬移任何数据。如果从尾到头在有序数组里查找插入位置，每次只需比较一个数据就能确定插入位置。时间复杂度为 <code>O(n)</code>；</li><li><strong>最坏情况</strong>：数组是倒序的，每次插入都相当于在数组的第一个位置插入新数据，所有需要移动大量数据。时间复杂度为 <code>O(n^2)</code>；</li><li><strong>平均情况</strong>：在数组中插入一个数据的平均时间复杂度为 <code>O(n)</code>，对于插入排序来说，每次插入操作就相当于在数组中插入一个数据，循环执行 <code>n</code> 次插入操作。所以平均时间复杂度为 <code>O(n^2)</code>。</li></ul><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>思路与插入排序类似，也分已排序区间和未排序区间。但是选择排序<strong>每次会从未排序区间中找到最小的元素，将其放到已排序区间末尾</strong>。最开始没有已排好的区间，找到数组中最小元素，将其与第一个元素交换，然后再执行以上过程。</p><h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><pre><code>def selection_sort(lt):    length = len(lt)    for i in range(0,length-1):        smallest_index = i        for j in range(i+1, length):            if lt[j] &lt; lt[smallest_index]:                lt[j], lt[smallest_index] = lt[smallest_index], lt[j]    return lt</code></pre><h4 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h4><p>1 . 选择排序空间复杂度为O(1)，是一种<strong>原地排序算法</strong>。<br>2 . 时间复杂度分析。最好情况、最坏情况和平均时间复杂度都为 <code>O(n^2)</code>。<br>3 . 选择排序是一种<strong>不稳定</strong>的排序算法。因为其每次都要找剩余未排序元素中的最小值，并和前面的元素交换位置，这样就破坏了稳定性。也因为此，相比于冒泡排序和插入排序，选择排序没那么好。</p><h3 id="解答开篇"><a href="#解答开篇" class="headerlink" title="解答开篇"></a>解答开篇</h3><p>冒泡排序和插入排序的时间复杂度都是 <code>O(n2)</code>，都是原地排序算法，为什么插入排序要比冒泡排序更受欢迎呢？<br>前面说过，冒泡排序不管怎么优化，元素交换的次数是一个固定值，是原始数据的逆序度。插入排序是同样的，不管怎么优化，元素移动的次数也等于原始数据的逆序度。<br>但是，从代码实现上来看，<strong>冒泡排序的数据交换要比插入排序的数据移动更复杂</strong>，冒泡排序需要 3 个赋值操作，而插入排序只需要 1 个。所以在对相同数组进行排序时，冒泡排序的运行时间理论上要长于插入排序。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;问题思考&quot;&gt;&lt;a href=&quot;#问题思考&quot; class=&quot;headerlink&quot; title=&quot;问题思考&quot;&gt;&lt;/a&gt;问题思考&lt;/h3&gt;&lt;p&gt;插入排序和冒泡排序的时间复杂度相同，都是O(n^2)，在实际软件开发里，为什么更倾向于使用插入排序算法而不是冒泡排序算法呢？
      
    
    </summary>
    
      <category term="technique summary" scheme="http://ipine.github.io/categories/technique-summary/"/>
    
    
      <category term="data_structure" scheme="http://ipine.github.io/tags/data-structure/"/>
    
      <category term="algorithm" scheme="http://ipine.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>递归</title>
    <link href="http://ipine.github.io/2018-10-29/"/>
    <id>http://ipine.github.io/2018-10-29/</id>
    <published>2018-10-29T07:00:00.000Z</published>
    <updated>2018-10-30T05:41:52.620Z</updated>
    
    <content type="html"><![CDATA[<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>很多APP都有推荐用户注册返佣金或奖励的功能。在这个功能中，用户A推荐用户B来注册，用户B又推荐用户C来注册。那么用户C的<code>最终推荐人</code>就为A，用户B的<code>最终推荐人</code>也为A，用户A没有最终推荐人。在数据库表中，可以记录两行数据，其中<code>user_id</code>表示用户ID，<code>referrer_id</code>表示推荐人ID。<br>那么，问题是，给定一个用户ID，如何查找这个用户的<code>最终推荐人</code>？<br>应用到的思想就是递归</p><h3 id="如何理解递归"><a href="#如何理解递归" class="headerlink" title="如何理解递归"></a>如何理解<strong>递归</strong></h3><p>很多数据结构和算法的实现都要用到递归，比如<strong>DFS深度优先搜索</strong>、<strong>前中后序二叉树遍历</strong>等。</p><p>一个生活中的例子，在电影院由于太黑，你看不清自己在第几排，但是又想知道，怎么办呢？问前一排的人，他的排数+1就是你的排数。但是前一排的人也看不清自己在第几排，他又通过问自己的前一排，就这样一直传递问下去，直到第一排的人说我是第一排，于是又一排一排把数字传回来。<br>这样一个过程就是递归求解问题的分解过程，去的过程叫<code>递</code>，回来的过程叫<code>归</code>。基本上，所有的递归问题都可以用递推公式来表示。</p><pre><code>f(n) = f(n-1) + 1, 其中，f(1) = 1</code></pre><h3 id="什么样的问题能用递归来解决？"><a href="#什么样的问题能用递归来解决？" class="headerlink" title="什么样的问题能用递归来解决？"></a>什么样的问题能用递归来解决？</h3><p>同时满足以下三个条件，就可用递归来解决。</p><ul><li><p>一个问题的解可以分解为几个子问题的解。<br>子问题是指数据规模更小的问题<br>想知道你“自己在哪一排”，可以分解为“前一排的人在哪一排”这个子问题</p></li><li><p>这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样。<br>你求解“自己在哪一排”，与前面一排求解“自己在哪一排”的思路是相同的。</p></li><li><p>存在递归终止条件<br>问题分解为子问题，子问题再一层层分解下去，但是不能无限循环，必须有终止条件。<br>电影院第一排的人知道自己在哪一排，即<code>f(1) = 1</code>,这就是递归终止条件。</p></li></ul><h3 id="编写递归代码"><a href="#编写递归代码" class="headerlink" title="编写递归代码"></a>编写递归代码</h3><p><strong>关键点：写出递归公式，找到终止条件。</strong></p><h4 id="栗子"><a href="#栗子" class="headerlink" title="栗子"></a>栗子</h4><p>假设有n个台阶，每次可以跨1个台阶或者2个台阶，那么请问走完这n个台阶，共有多少种走法？</p><h5 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h5><p>可以根据第一步的走法把所有走法分为两类，第一类是，第一步走1个台阶；第二类是，第一步走2个台阶。<br>所以，<code>n</code>个台阶的走法就等于，先走1阶后，<code>n-1</code>个台阶的走法，加上，先走2阶后，<code>n-2</code>个台阶的走法。<br>公式表示为：</p><pre><code>f(n) = f(n-1) + f(n-2)</code></pre><p>有了递推公式还不够，再分析终止条件：当有1个台阶时，就只有一个走法，所以<code>f(1) = 1</code>。用小规模数试验一下，该终止条件是否合理，当<code>n=2</code>时，<code>f(2) = f(1) + f(0)</code>。发现<code>f(2)</code>没法求解，因为没给<code>f(0)</code>的值。可以给定<code>f(0) = 0</code>，表示走0个台阶有1种走法，但这不符合常识，因而可以直接给定<code>f(2) = 2</code>，表示走2个台阶有2种走法，要么一步1个台阶走，要么一次跨2个台阶。<br>这样再试验<code>f(3) = f(2) + f(1)</code>，可以得出结果并正确。所以，递归终止条件就为<code>f(1)= 1, f(2) = 2</code>。<br>最终公式</p><pre><code>f(1)= 1f(2) = 2f(n) = f(n-1) + f(n-2)</code></pre><h5 id="递归代码"><a href="#递归代码" class="headerlink" title="递归代码"></a>递归代码</h5><pre><code>def climbStairs(self,n):    if n==1:        return 1    elif n==2:        return 2    else:        return self.climbStairs(n-1) + self.climbStairs(n-2)</code></pre><h3 id="Key"><a href="#Key" class="headerlink" title="Key"></a>Key</h3><p>对于递归代码，试图想清楚整个递和归过程的做法，实际上是进入了一个思维误区。很多时候，理解起来比较吃力，主要原因就是自己给自己制造了这种理解障碍。</p><p><strong>正确的思维方式</strong>应该是:<br>如果一个问题 A 可以分解为若干子问题 B、C、D，就假设子问题 B、C、D 已经解决，在此基础上思考如何解决问题 A。而且，只需要思考问题 A 与子问题 B、C、D 两层之间的关系即可，不需要一层一层往下思考子问题与子子问题，子子问题与子子子问题之间的关系。屏蔽掉递归细节，这样子理解起来就简单多了。<br>因此，编写递归代码的关键是，只要遇到递归，就把它抽象成一个递推公式，不用想一层层的调用关系，不要试图用人脑去分解递归的每个步骤。</p><h3 id="注意问题"><a href="#注意问题" class="headerlink" title="注意问题"></a>注意问题</h3><p>1 . 递归代码要警惕堆栈溢出。函数调用会使用栈来保存临时变量。每调用一个函数，都会将临时变量封装为栈帧压入内存栈，等函数执行完成返回时，才出栈。系统栈或者虚拟机栈空间一般都不大。如果递归求解的数据规模很大，调用层次很深，一直压入栈，就会有堆栈溢出的风险。</p><p><strong>解决思路</strong>：可以通过在代码中限制递归调用的最大深度的方式来解决这个问题。递归调用超过一定深度（比如 1000）之后，我们就不继续往下再递归了，直接返回报错。</p><p>2 . 递归代码要警惕重复计算。刚刚的例子中，就存在这个问题，比如要计算<code>f(5)</code>，就需要计算<code>f(4)</code>和<code>f(3)</code>，而计算<code>f(4)</code>，需要计算<code>f(3)</code>和<code>f(2)</code>，这个过程中<strong>f(3)就被计算了多次</strong>。</p><p><strong>解决思路</strong>：通过一个数据结构（散列表）来保存已经求解过的f(i)。当递归调用到f(i)时，先查找这个值是否已经求解。若是，则直接从散列表中取值返回，避免重复计算。</p><h4 id="修改栗子中的代码"><a href="#修改栗子中的代码" class="headerlink" title="修改栗子中的代码"></a>修改栗子中的代码</h4><pre><code>def climbStairs(self,n):    hash_list = [0,1,2]    if n==1:        return hash_list[1]    elif n==2:        return hash_list[2]    else:        for i in range(3, n+1):            hash_list.append(hash_list[i-1] + hash_list[i-2])        return  hash_list[n]</code></pre><p>3 . 时间和空间成本很高。在时间效率上，递归代码里多了很多函数调用，当这些函数调用的数量较大时，就会积聚成一个可观的时间成本。在空间复杂度上，因为递归调用一次就会在内存栈中保存一次现场数据，所以在分析递归代码空间复杂度时，需要额外考虑这部分的开销，比如前面的电影院递归代码，空间复杂度并不是 <code>O(1)</code>，而是 <code>O(n)</code>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;应用场景&quot;&gt;&lt;a href=&quot;#应用场景&quot; class=&quot;headerlink&quot; title=&quot;应用场景&quot;&gt;&lt;/a&gt;应用场景&lt;/h3&gt;&lt;p&gt;很多APP都有推荐用户注册返佣金或奖励的功能。在这个功能中，用户A推荐用户B来注册，用户B又推荐用户C来注册。那么用户C的&lt;
      
    
    </summary>
    
      <category term="technique summary" scheme="http://ipine.github.io/categories/technique-summary/"/>
    
    
      <category term="data_structure" scheme="http://ipine.github.io/tags/data-structure/"/>
    
      <category term="algorithm" scheme="http://ipine.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>队列</title>
    <link href="http://ipine.github.io/2018-10-16/"/>
    <id>http://ipine.github.io/2018-10-16/</id>
    <published>2018-10-16T11:58:00.000Z</published>
    <updated>2018-10-17T13:37:33.382Z</updated>
    
    <content type="html"><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>CPU资源有限，任务的处理速度与线程个数并不是线性正相关。过多的线程会导致CPU频繁切换，处理性能下降。<br>当我们向固定大小的线程池中请求一个线程时，如果线程池中没有空闲资源了，这个时候线程池如何处理这个请求？是拒绝请求还是排队请求？各种处理策略又是怎么实现的呢？<br>这就需要用到<code>队列</code>这个数据结构</p><h3 id="如何理解队列"><a href="#如何理解队列" class="headerlink" title="如何理解队列"></a>如何理解<code>队列</code></h3><p>理解成，排队购票，排在前面的先买，排在后面的后买。即<code>先进者先出</code>（FIFO）。<br>队列跟栈非常相似，支持的操作也有限，最基本的也是两个：<strong>入队和出队，一端出队，另一端入队</strong>；所以队列也是一种操作受限的<code>线性表</code>数据结构。</p><h3 id="顺序队列和链式队列"><a href="#顺序队列和链式队列" class="headerlink" title="顺序队列和链式队列"></a>顺序队列和链式队列</h3><p>用数组实现的队列叫作顺序队列，用链表实现的队列叫作链式队列。</p><h4 id="顺序队列"><a href="#顺序队列" class="headerlink" title="顺序队列"></a>顺序队列</h4><p>不理想的设计：<br>1 . 若使用顺序表的尾端插入实现<code>enqueue</code>操作，根据队列性质，出队操作应该在表的首端进行。为了维护顺序表的完整性（表元素在表前端连续存放），出队操作取出当时的首元素后，就需要把表中其余元素全部前移，这样就会是一个 <code>O(n)</code> 时间的操作。<br>2 . 反过来：从尾端出队是 <code>O(1)</code> 操作，但从首端入队就是 <code>O(n)</code> 时间操作，这种设计也不理想。<br>3 . 另一种是在队首元素出队后表中的元素不前移，但记住新队头位置。如果队列中没有空闲了，只需要在入队时，再集中触发一次数据的搬移操作。</p><h4 id="链式队列"><a href="#链式队列" class="headerlink" title="链式队列"></a>链式队列</h4><p>最简单的单链表只支持首端 <code>O(1)</code> 的操作，在另一端操作需要 <code>O(n)</code> 时间。不适合作为队列的实现基础。<br>考虑<code>带表尾指针</code>的单链表，它支持 <code>O(1)</code> 时间的尾端插入操作；再加上表首端的高效访问和删除，基于单链表实现队列就很容易。</p><h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><pre><code>class LNode:    def __init__(self, elem, next_=None):        self.data = elem        self.next = next_class QueueUnderflow(ValueError):    passclass LQueue:    def __init__(self):        self._head = None        self._rear = None    def is_empty(self):        return self._head is None    def peek(self):        &quot;&quot;&quot;查看队列最早元素，不删除&quot;&quot;&quot;        if self._head is None: #是空队列            raise QueueUnderflow(&apos;in peek of Queue&apos;)        else:            return self._head.data    def dequeue(self):        &quot;&quot;&quot;删除队列头结点，并返回这个结点里的数据&quot;&quot;&quot;        if self._head == None:            raise QueueUnderflow(&quot;in dequeue&quot;)        e = self._head.data        self._head = self._head.next        return e    def enqueue(self, elem):        if self._head is None:#空表            self._head = LNode(elem, self._head)            self._rear = self._head        else:            self._rear.next = LNode(elem)            self._rear = self._rear.next</code></pre><h3 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h3><p>一个具体的实现示例：基于Python的list实现顺序表示的循环队列。<br>考虑定义一个可以自定扩充存储结构的队列类。</p><blockquote><p>注：不能直接利用list的自动存储扩充机制。两个原因：<br> 1 . 队列元素的存储方式与list元素的默认存储方式不一致；list元素总在其存储器的最前面一段，而队列的元素可能是表里的任意一段，有时还分为头尾两段。<br> 2 . list没有提供检测元素存储区容量的机制，队列操作中无法判断系统何时扩容。</p></blockquote><h5 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h5><pre><code>class SQueue():    def __init__(self, init_len = 8):        self._len = init_len       #存储区长度        self._elems = [0] *init_len #元素存储        self._head = 0              #表头元素下标        self._num = 0               #元素个数    def is_empty(self):        return self._num == 0    def peek(self):        if self._num is None: #是空队列            raise QueueUnderflow(&apos;in peek of SQueue&apos;)        return self._elems[self._head]    def dequeue(self):        if self._num == 0:            raise QueueUnderflow(&apos;in dequeue of SQueue&apos;)        e = self._elems[self._head]        self._head = (self._head+1)%self._len        self._num -= 1        return e    def enqueue(self,e):        if self._num == self._len: #队满时            self._extend()        self._elems[(self._head+self._num)%self._len] = e        self._num += 1    def _extend(self):        old_len = self._len        self._len *= 2        new_elems = [0]*self._len #扩大元素存储区        for i in range(old_len):  #将原有元素搬迁到新表里（最前面的位置）            new_elems[i] = self._elems[(self._head+1)%old_len]        self._elems, self._head = new_elems, 0  </code></pre><p><strong>注解</strong></p><p>1 . 队列对象的4个属性，<code>_elems</code>，<code>_head</code>，<code>_num</code>，<code>_len</code>的作用分别是：<strong>存放队列元素</strong>，<strong>记录队列首元素所在位置的下标</strong>，<strong>记录表中元素个数</strong>，<strong>记录当存储区的有效容量（便于换存储表）</strong>。<br>2 . 在<code>_num = _len</code> 的情况下（队满）出现入队操作，就扩大存储区；队空就是 <code>_num == 0</code>。<br>3 . 队列里的元素总保存在<code>_elems</code>里，从<code>_head</code>开始的连续位置中。<br>4 . 新入队的元素存入在 <code>(_head + _num)%len</code> 算出的位置；若需要把元素存入下标<code>_len</code>的位置时，改为在<code>下标0位置</code>存入。<br>5 . 在<code>_extend</code>函数中新元素尚未入队，但<code>_extend</code>在enqueue返回后，enqueue的最后两句语句将正常完成这个工作。</p><h3 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h3><p>阻塞队列其实就是在队列基础上增加了阻塞操作。简单来说，就是在队列为空的时候，从队头取数据会被阻塞。因为此时还没有数据可取，直到队列中有了数据才能返回；如果队列已经满了，那么插入数据的操作就会被阻塞，直到队列中有空闲位置后再插入数据，然后再返回。</p><blockquote><p>注：可以用阻塞队列实现一个“生产者-消费者模型”。基于阻塞队列，可以通过协调“生产者”和“消费者”的个数，来提高数据的处理效率。</p></blockquote><h3 id="并发队列"><a href="#并发队列" class="headerlink" title="并发队列"></a>并发队列</h3><p>在多线程情况下，会有多个线程同时操作队列，这个时候就会存在线程安全问题。<br>要实现一个线程安全的队列就需要<code>并发队列</code>。<br>最简单直接的实现方式是直接在 <code>enqueue()</code>、<code>dequeue()</code> 方法上加锁，但是锁粒度大并发度会比较低，同一时刻仅允许一个存或者取操作。</p><h3 id="解答引言"><a href="#解答引言" class="headerlink" title="解答引言"></a>解答引言</h3><p>一般有两种处理策略。</p><ul><li>第一种是非阻塞的处理方式，直接拒绝任务请求；</li><li>另一种是阻塞的处理方式，将请求排队，等到有空闲线程时，取出排队的请求继续处理。</li></ul><p><strong>那如何存储排队的请求呢？</strong><br>公平地处理每个排队的请求，先进者先服务，所以队列这种数据结构很适合来存储排队请求。</p><p>队列有基于链表和基于数组这两种实现方式。<strong>两种实现方式对于排队请求又有什么区别呢？</strong></p><h4 id="基于链表的实现方式"><a href="#基于链表的实现方式" class="headerlink" title="基于链表的实现方式"></a>基于链表的实现方式</h4><p>可以实现一个支持无限排队的<code>无界队列（unbounded queue）</code>，但是可能会导致过多的请求排队等待，请求处理的响应时间过长。<br>所以，针对响应时间比较敏感的系统，基于链表实现的无限排队的线程池是不合适的。</p><h4 id="基于数组的实现方式"><a href="#基于数组的实现方式" class="headerlink" title="基于数组的实现方式"></a>基于数组的实现方式</h4><p>可以实现的是<code>有界队列（bounded queue）</code>，队列的大小有限，所以线程池中排队的请求超过队列大小时，接下来的请求就会被拒绝，这种方式对响应时间敏感的系统来说，就相对更加合理。<br>这时，设置一个合理的队列大小，就非常重要。队列太大导致等待的请求太多，队列太小会导致无法充分利用系统资源、发挥最大性能。</p><blockquote><p>注：对于大部分资源有限的场景，当没有空闲资源时，基本上都可以通过<code>队列</code>这种数据结构来实现请求排队。</p></blockquote><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>队列的其他应用<br>1 . 文件打印<br>2 . 万维网服务器<br>3 . Windows系统和消息队列<br>4 . 离散事件系统模拟</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h3&gt;&lt;p&gt;CPU资源有限，任务的处理速度与线程个数并不是线性正相关。过多的线程会导致CPU频繁切换，处理性能下降。&lt;br&gt;当我们向固定大小的线程池中请
      
    
    </summary>
    
      <category term="technique summary" scheme="http://ipine.github.io/categories/technique-summary/"/>
    
    
      <category term="data_structure" scheme="http://ipine.github.io/tags/data-structure/"/>
    
      <category term="algorithm" scheme="http://ipine.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>栈</title>
    <link href="http://ipine.github.io/2018-10-13/"/>
    <id>http://ipine.github.io/2018-10-13/</id>
    <published>2018-10-13T11:58:00.000Z</published>
    <updated>2018-10-16T05:24:05.670Z</updated>
    
    <content type="html"><![CDATA[<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>首先思考一个问题，浏览器的前进、后退功能是如何实现的呢？</p><h3 id="理解栈"><a href="#理解栈" class="headerlink" title="理解栈"></a>理解栈</h3><ul><li><code>栈</code>结构：先进的后出，后进的先出。类似于洗好的盘子，叠一摞，下次用的时候只能从最上面那个盘子开始拿。</li><li>操作特性：<code>操作受限</code>的<strong>线性表</strong></li><li>什么时候用：当某个数据集合只涉及在一端插入和删除数据，并且满足后进先出的特性，就应该首选<code>栈</code>这种结构。</li></ul><h3 id="如何实现栈"><a href="#如何实现栈" class="headerlink" title="如何实现栈"></a>如何实现栈</h3><p>栈既可以用数组实现，也可以用链表来实现。用数组实现的栈，叫作顺序栈，用链表实现的栈，叫作链栈。</p><ul><li>示例：顺序栈</li></ul><pre><code>class Stack():    def __init__(self,size):        &quot;&quot;&quot;初始化&quot;&quot;&quot;        self.size = size        self.num = 0        self.stack = []    def getSize(self):        &quot;&quot;&quot;获取栈的长度&quot;&quot;&quot;        return self.num    def print_all(self):        &quot;&quot;&quot;输出栈元素&quot;&quot;&quot;        for s in self.stack:            print s    def append_stack(self,value):        &quot;&quot;&quot;入栈&quot;&quot;&quot;        if self.num &gt;= self.size:            print(&quot;the stack is full&quot;)            return        else:            self.stack.append(value)            self.num += 1    def pop_stack(self):        &quot;&quot;&quot; 出栈&quot;&quot;&quot;        if self.num is None:            print(&quot;the stack is empty&quot;)            return        else:            self.stack.remove(self.stack[-1])</code></pre><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><h4 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><p>无论是顺序栈还是链栈，存储数据只需要一个大小为n的数组。在入栈和出栈过程中，只需要一两个临时变量存储空间，所以空间复杂度为<code>O(1)</code>。</p><blockquote><p>注：存储数据需要一个大小为n的数组，并不是指空间复杂度就为O(n)。因为，这 n 个空间是必须的，无法省掉。<br>我们说空间复杂度的时候，是指除了原本的数据存储空间外，算法运行还需要的额外的存储空间。</p></blockquote><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>不管顺序栈还是链栈，入栈、出栈只涉及栈顶个别数据的操作，所以复杂度为<code>O(1)</code>。</p><h4 id="支持动态扩容的顺序栈的入栈、出栈时间复杂度分析"><a href="#支持动态扩容的顺序栈的入栈、出栈时间复杂度分析" class="headerlink" title="支持动态扩容的顺序栈的入栈、出栈时间复杂度分析"></a>支持动态扩容的顺序栈的入栈、出栈时间复杂度分析</h4><p>对于出栈操作来说，不会涉及内存的重新申请和数据的搬移，所以出栈的时间复杂度仍然是 <code>O(1)</code>。但是，对于入栈操作来说，情况就不一样了。当栈中有空闲空间时，入栈操作的时间复杂度为 <code>O(1)</code>。但当空间不够时，就需要重新申请内存和数据搬移，所以时间复杂度就变成了 <code>O(n)</code>。</p><p>也就是说，对于入栈操作来说，最好情况时间复杂度是 <code>O(1)</code>，最坏情况时间复杂度是 <code>O(n)</code>。而平均时间复杂度，由摊还分析法分析可知为 <code>O(1)</code>。</p><h3 id="栈的应用"><a href="#栈的应用" class="headerlink" title="栈的应用"></a>栈的应用</h3><h4 id="在函数调用中的应用"><a href="#在函数调用中的应用" class="headerlink" title="在函数调用中的应用"></a>在函数调用中的应用</h4><p>操作系统给每个线程分配了一块独立的内存空间，这块内存被组织成“栈”这种结构, 用来存储函数调用时的临时变量。每进入一个函数，就会将临时变量作为一个栈帧入栈，当被调用函数执行完成，返回之后，将这个函数对应的栈帧出栈。</p><h4 id="栈在表达式求值中的应用"><a href="#栈在表达式求值中的应用" class="headerlink" title="栈在表达式求值中的应用"></a>栈在表达式求值中的应用</h4><p>实现一个表达式求值的功能，编译器就是通过两个栈来实现的。<br>其中一个保存操作数的栈，另一个是保存运算符的栈。<br>从左向右遍历表达式，当遇到数字，就直接压入操作数栈；当遇到运算符，就与运算符栈的栈顶元素进行比较。<br>如果当前运算符优先级高，就将当前运算符压入栈；如果运算符栈顶元素优先级高，就从运算符栈中取栈顶运算符，从操作数栈的栈顶取 2 个操作数，然后进行计算，再把计算完的结果压入操作数栈，继续比较。</p><h5 id="栗子"><a href="#栗子" class="headerlink" title="栗子"></a>栗子</h5><p><code>3+5*8-6</code>表达式的计算过程如下：</p><p><img src="http://p8ay1ez22.bkt.clouddn.com/18-10-16/98172578.jpg" alt="表达式"></p><h4 id="栈在括号匹配中的应用"><a href="#栈在括号匹配中的应用" class="headerlink" title="栈在括号匹配中的应用"></a>栈在括号匹配中的应用</h4><p>假设表达式中只包含三种括号，<code>圆括号 ()</code>、<code>方括号 []</code> 和<code>花括号{}</code>，并且它们可以任意嵌套。比如，<code>{[{}]}</code>或 <code>[{()}([])]</code> 等都为合法格式，而<code>{[}()]</code> 或 <code>[({)]</code> 为不合法的格式。</p><h5 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h5><p>给定一个包含三种括号的表达式字符串，如何检查它是否合法呢？</p><h5 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h5><p>用栈来保存未匹配的左括号，从左到右依次扫描字符串。当扫描到左括号时，则将其压入栈中；当扫描到右括号时，从栈顶取出一个左括号。如果能够匹配，比如<code>(</code>跟<code>)</code>匹配，<code>[</code>跟<code>]</code>匹配，<code>{</code>跟<code>}</code>匹配，则继续扫描剩下的字符串。如果扫描的过程中，遇到不能配对的右括号，或者栈中没有数据，则说明为非法格式。<br>当所有的括号都扫描完成之后，如果栈为空，则说明字符串为合法格式；否则，说明有未匹配的左括号，为非法格式。</p><h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><pre><code>left_brackets = &apos;{[(&lt;&apos;right_brackets = &apos;}])&gt;&apos;matching_brackets = {&apos;}&apos;: &apos;{&apos;, &apos;]&apos;: &apos;[&apos;, &apos;)&apos;: &apos;(&apos;, &apos;&gt;&apos;: &apos;&lt;&apos;}def judgment_brackets_matching(rows):    stack = []    label = True    for row in rows:        if row in left_brackets:            stack.append(row)        elif row in right_brackets:            if len(stack) &lt; 1:                label = False                break            elif matching_brackets[row] == stack[-1]:                stack.pop()            else:                label = False                break        else:            continue    if stack:        label = False    return label</code></pre><h2 id="解答开篇"><a href="#解答开篇" class="headerlink" title="解答开篇"></a>解答开篇</h2><p>用栈实现浏览器的前进、后退功能</p><h3 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h3><p>使用两个栈，<code>X</code> 和 <code>Y</code>，把首次浏览的页面依次压入栈 <code>X</code>，当点击后退按钮时，再依次从栈 <code>X</code> 中出栈，并将出栈的数据依次放入栈 <code>Y</code>。当我们点击前进按钮时，我们依次从栈 <code>Y</code> 中取出数据，放入栈 <code>X</code> 中。当栈 <code>X</code> 中没有数据时，那就说明没有页面可以继续后退浏览了。当栈 <code>Y</code> 中没有数据，那就说明没有页面可以点击前进按钮浏览了。</p><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><p>顺序查看了a,b,c三个页面，将其依次压入栈，栈中数据情况为：</p><pre><code>X: a-&gt;b-&gt;cY: None</code></pre><p>点击后退按钮，从c页面推到a页面，栈中数据情况为：</p><pre><code>X: NoneY: c-&gt;b-&gt;a</code></pre><p>想再次查看b页面，点击前进按钮到b页面，此时栈中数据情况为：</p><pre><code>X: a-&gt;bY: c</code></pre><p>假设，此时在b页面跳转到新页面d，页面c就无法通过前进或后退按钮重复查看了，因而需要清空Y栈：</p><pre><code>X: a-&gt;b-&gt;dY: None</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;思考&quot;&gt;&lt;a href=&quot;#思考&quot; class=&quot;headerlink&quot; title=&quot;思考&quot;&gt;&lt;/a&gt;思考&lt;/h2&gt;&lt;p&gt;首先思考一个问题，浏览器的前进、后退功能是如何实现的呢？&lt;/p&gt;
&lt;h3 id=&quot;理解栈&quot;&gt;&lt;a href=&quot;#理解栈&quot; class=&quot;he
      
    
    </summary>
    
      <category term="technique summary" scheme="http://ipine.github.io/categories/technique-summary/"/>
    
    
      <category term="data_structure" scheme="http://ipine.github.io/tags/data-structure/"/>
    
      <category term="algorithm" scheme="http://ipine.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>链表</title>
    <link href="http://ipine.github.io/2018-10-11/"/>
    <id>http://ipine.github.io/2018-10-11/</id>
    <published>2018-10-11T11:58:00.000Z</published>
    <updated>2018-10-13T11:43:18.239Z</updated>
    
    <content type="html"><![CDATA[<p>主要学习几个写链表代码的技巧</p><h3 id="理解指针或引用的含义"><a href="#理解指针或引用的含义" class="headerlink" title="理解指针或引用的含义"></a>理解指针或引用的含义</h3><p>有些语言有<code>指针</code>概念，比如C语言；有些语言没有指针，取而代之的是<code>引用</code>，比如Java、Python。不管“指针”还是“引用”，都是一个意思，<code>指存储所指对象的内存地址</code>。</p><blockquote><p>指针含义：将某个变量（对象）赋值给指针（引用），实际上就是就是将这个变量（对象）的地址赋值给指针（引用）</p></blockquote><h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h4><pre><code>p—&gt;next = q; </code></pre><p>表示<code>p</code>节点的后继<code>next</code>指针存储了<code>q</code>节点的内存地址</p><pre><code>p—&gt;next = p—&gt;next—&gt;next;</code></pre><p>表示<code>p</code>节点的后继<code>next</code>指针存储了<code>p</code>节点的下下个节点的内存地址。</p><h3 id="警惕指针丢失和内存泄漏"><a href="#警惕指针丢失和内存泄漏" class="headerlink" title="警惕指针丢失和内存泄漏"></a>警惕指针丢失和内存泄漏</h3><h4 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h4><p>单链表的插入，希望在节点a和相邻节点b之间插入节点x，假设当前指针p指向节点a，则造成指针丢失和内存泄漏的代码：</p><pre><code>p-&gt;next = x;x-&gt;next = p-&gt;next</code></pre><p>导致将<code>x</code>自身赋值给了<code>x-&gt;next</code>，自己指向自己。</p><blockquote><p>对于有些语言来说，比如 C 语言，内存管理是由程序员负责的，如果没有手动释放结点对应的内存空间，就会产生内存泄露。</p></blockquote><p>所以，插入结点时，一定要注意操作的顺序。上面代码的正确写法是：<strong>两句代码顺序调换</strong>。<br>同理，删除链表时，也一定要手动释放内存空间，否则，也会出现内存泄漏问题。</p><blockquote><p>Python语言不需手动释放，它的解释器的存储管理系统会自动回收不用的存储。</p></blockquote><h3 id="利用哨兵（头结点）简化实现难度"><a href="#利用哨兵（头结点）简化实现难度" class="headerlink" title="利用哨兵（头结点）简化实现难度"></a>利用哨兵（头结点）简化实现难度</h3><h4 id="哨兵含义："><a href="#哨兵含义：" class="headerlink" title="哨兵含义："></a><code>哨兵</code>含义：</h4><p>链表中的<code>哨兵</code>节点是解决边界问题的，不参与业务逻辑。如果我们引入<code>哨兵</code>节点，则不管链表是否为空，head指针都会指向这个“哨兵”节点。我们把这种有“哨兵”节点的链表称为<code>带头链表</code>，相反，没有<code>哨兵</code>节点的链表就称为不带头链表。</p><h4 id="示例：-2"><a href="#示例：-2" class="headerlink" title="示例："></a>示例：</h4><h5 id="不带头结点时："><a href="#不带头结点时：" class="headerlink" title="不带头结点时："></a>不带头结点时：</h5><ul><li>对于单链表的插入操作</li></ul><p>1 . 如果在p节点后插入一个新节点，只需2行代码即可搞定：</p><pre><code>new_node—&gt;next = p—&gt;next;p—&gt;next = new_node;</code></pre><p>2 . 如果向空链表中插入一个新结点，则代码就不同：</p><pre><code>if(head == null){  head = new_node;}</code></pre><ul><li>对于单链表的删除操作</li></ul><p>1 . 如果要删除节点p的后继节点，只需1行代码即可搞定：</p><pre><code>p—&gt;next = p—&gt;next—&gt;next;</code></pre><p>2 . 如果删除的是链表的最后一个节点（链表中只剩下这个节点），则代码如下：</p><pre><code>if(head—&gt;next == null){  head = null;}</code></pre><blockquote><p>以上示例可以看出，不带头结点时，单链表的插入、删除操作，需要对插入第一个结点和删除最后一个结点作特殊处理。</p></blockquote><h5 id="带头结点时："><a href="#带头结点时：" class="headerlink" title="带头结点时："></a>带头结点时：</h5><p><code>哨兵</code>节点不存储数据，无论链表是否为空，<code>head</code>指针都会指向它，作为链表的头结点始终存在。<br>这样，插入第一个节点和插入其他节点，删除最后一个节点和删除其他节点都可以统一为相同的实现逻辑。</p><h3 id="留意边界条件处理"><a href="#留意边界条件处理" class="headerlink" title="留意边界条件处理"></a>留意边界条件处理</h3><p>常用的检查链表代码是否正确的边界条件：<br>1 . 如果链表为空时，代码是否能正常工作？<br>2 . 如果链表只包含一个节点时，代码是否能正常工作？<br>3 . 如果链表只包含两个节点时，代码是否能正常工作？<br>4 . 代码逻辑在处理头尾节点时是否能正常工作？</p><h3 id="举例画图，辅助思考"><a href="#举例画图，辅助思考" class="headerlink" title="举例画图，辅助思考"></a>举例画图，辅助思考</h3><p>对于稍微复杂的链表操作，可以找一个具体例子，将它画在纸上。比如，向单链表中插入一个数据，就画出链表插入前和插入后的情况。<br>对着图写代码，写完之后，也可举列子，照着代码走一遍，很容易发现代码中的Bug。</p><h3 id="多写多练，没有捷径"><a href="#多写多练，没有捷径" class="headerlink" title="多写多练，没有捷径"></a>多写多练，没有捷径</h3><pre><code>精选的5个常见链表操作：（以及在LeetCode上对于的题目编号）1.单链表反转 ---- 2062.链表中环的检测 ---- 1413.两个有序链表合并 ---- 214.删除链表倒数第n个节点 ---- 195.求链表的中间节点 ---- 876</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;主要学习几个写链表代码的技巧&lt;/p&gt;
&lt;h3 id=&quot;理解指针或引用的含义&quot;&gt;&lt;a href=&quot;#理解指针或引用的含义&quot; class=&quot;headerlink&quot; title=&quot;理解指针或引用的含义&quot;&gt;&lt;/a&gt;理解指针或引用的含义&lt;/h3&gt;&lt;p&gt;有些语言有&lt;code&gt;指针&lt;/c
      
    
    </summary>
    
      <category term="technique summary" scheme="http://ipine.github.io/categories/technique-summary/"/>
    
    
      <category term="data_structure" scheme="http://ipine.github.io/tags/data-structure/"/>
    
      <category term="algorithm" scheme="http://ipine.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>链表</title>
    <link href="http://ipine.github.io/2018-10-10/"/>
    <id>http://ipine.github.io/2018-10-10/</id>
    <published>2018-10-10T03:58:00.000Z</published>
    <updated>2018-10-10T12:12:23.359Z</updated>
    
    <content type="html"><![CDATA[<h2 id="如何用链表实现LRU缓存淘汰算法？"><a href="#如何用链表实现LRU缓存淘汰算法？" class="headerlink" title="如何用链表实现LRU缓存淘汰算法？"></a>如何用链表实现LRU缓存淘汰算法？</h2><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><ul><li>缓存定义：一种高效数据读取性能的技术，比如常见的<strong>CPU缓存</strong>、<strong>数据库缓存</strong>、<strong>浏览器缓存</strong>等。缓存在计算机软件、硬件开发中应用都很广。</li><li>缓存特点：大小有限，被用满时，需要清理一部分数据，而哪些数据应该被清理哪些应该被保留，由<code>缓存淘汰策略</code>决定。</li></ul><h3 id="缓存淘汰策略"><a href="#缓存淘汰策略" class="headerlink" title="缓存淘汰策略"></a>缓存淘汰策略</h3><p>常见的缓存淘汰策略有：<code>FIFO（First in,First out）先进先出策略</code>、<code>LFU（Least Frequently Used）最少使用策略</code>、<code>LRU（Least Recently Used）最近最少使用策略</code>。</p><h3 id="三种链表"><a href="#三种链表" class="headerlink" title="三种链表"></a>三种链表</h3><p>链表通过指针将一组零散的内存块串联在一起。其中内存块叫做链表的<strong>结点</strong>，记录结点地址的叫做<strong>指针</strong>。链表的第一个结点叫头结点，最后一个结点叫尾结点。</p><h4 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h4><p>单链表的“尾结点”，它的指针并不指向下一个结点，而是指向一个空地址<code>NULL</code></p><p><img src="http://p8ay1ez22.bkt.clouddn.com/18-10-10/56355664.jpg" alt="单链表"></p><p>单链表插入和删除操作，复杂度为O(1)<br><img src="http://p8ay1ez22.bkt.clouddn.com/18-10-10/93241850.jpg" alt="操作"></p><h4 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h4><p>一种特殊的单链表，与单链表的区别就在于尾结点，其尾结点指向链表的头结点<br><img src="http://p8ay1ez22.bkt.clouddn.com/18-10-10/66826587.jpg" alt="循环链表"></p><p>相比于单链表，循环链表的优势在于从链尾到链头很方便。著名的<code>约瑟夫问题</code>，就适合这种数据结构。</p><h4 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h4><p>单链表只有一个方向，结点只有一个后继指针next指向后面的节点。双向链表有两个方向，一个<code>后继指针next</code>和一个<code>前驱指针pre</code>。<br><img src="http://p8ay1ez22.bkt.clouddn.com/18-10-10/80665346.jpg" alt="双向链表"></p><p>双向链表在某些情况下的插入、删除操作比单链表更高效。<br>例如删除操作，从链表中删除一个数据，有两种情况：</p><ul><li>删除链表中值等于某个给定值的结点</li><li>删除给定指针指向的结点</li></ul><p>对于第一种情况，无论单链表还是双向链表，为了查找到值等于给定值的结点，都需要从头结点开始一个一个依次遍历对比，直到找到值等于给定值的结点，然后再将其删除。<br>尽管单纯的删除操作时间复杂度是 <code>O(1)</code>，但遍历查找的时间是主要的耗时点，对应的时间复杂度为 <code>O(n)</code>。根据时间复杂度分析中的加法法则，删除值等于给定值的结点对应的链表操作的总时间复杂度为 <code>O(n)</code>。</p><p>对于第二种情况，已经找到了要删除的结点，但是删除某个结点 <code>q</code> 需要知道其前驱结点，而单链表并不支持直接获取前驱结点。这种情况下<strong>单链表</strong>删除操作需要 <code>O(n)</code> 的时间复杂度，而<strong>双向链表</strong>只需要 <code>O(1)</code> 的时间复杂度。</p><p>以上的情况涉及到一个<code>空间换时间</code>的设计思想：双向链表更费内存，但仍比单链表应用更广泛。</p><blockquote><p>缓存实际上就是利用了空间换时间的设计思想。<br> 如果我们把数据存储在硬盘上，会比较节省内存，但每次查找数据都要询问一次硬盘，会比较慢。<br> 但如果我们通过缓存技术，事先将数据加载在内存中，虽然会比较耗费内存空间，但是每次数据查询的速度就大大提高了。</p></blockquote><p>若内存空间充足，如果更加追求代码的执行速度，就选择空间复杂度相对较高，时间复杂度相对较低的算法和数据结构，例如，缓存技术。<br>若内存比较紧缺，比如代码跑在手机或者单片机上，这时，就要反过来用时间换空间。</p><h3 id="数组与链表对比"><a href="#数组与链表对比" class="headerlink" title="数组与链表对比"></a>数组与链表对比</h3><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>删除、插入：<code>链表O(1)</code>、<code>数组O(n)</code></p><p>随机访问操作：<code>链表O(n)</code>、<code>数组(1)</code></p><h4 id="缓存支持"><a href="#缓存支持" class="headerlink" title="缓存支持"></a>缓存支持</h4><p>数组在实现上使用的是连续的内存空间，可以借助 CPU 的缓存机制，预读数组中的数据，所以访问效率更高。</p><p>链表在内存中并不是连续存储，所以对 CPU 缓存不友好，没办法有效预读。</p><h5 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h5><p>CPU在从内存读取数据的时候，会先把读取到的数据加载到CPU的缓存中。而CPU每次从内存读取数据并不是只读取要访问的地址，而是读取一个数据块，并保存到CPU缓存中，然后下次访问内存数据的时候就会先从CPU缓存开始查找，如果找到就不需要再从内存中取。<br>这样就实现了比内存访问速度更快的机制，也是CPU缓存存在的意义：<strong>为了弥补内存访问速度过慢与CPU执行速度快之间的差异</strong>。<br>对于数组来说，存储空间是连续的，所以在加载某个下标的时候可以把以后的几个下标元素也加载到CPU缓存这样执行速度会快于存储空间不连续的链表存储。</p><h4 id="灵活性"><a href="#灵活性" class="headerlink" title="灵活性"></a>灵活性</h4><p>数组大小固定，一经声明就要占用整块连续内存空间。如果声明的数组过大，系统可能没有足够的连续内存空间分配给它，导致<code>内存不足（out of memory）</code>。如果声明的数组过小，则可能出现不够用的情况。这时只能再申请一个更大的内存空间，把原数组拷贝进去，非常费时。</p><p>链表本身没有大小的限制，天然地支持动态扩容。</p><h2 id="链表实现LRU缓存淘汰策略的思路"><a href="#链表实现LRU缓存淘汰策略的思路" class="headerlink" title="链表实现LRU缓存淘汰策略的思路"></a>链表实现LRU缓存淘汰策略的思路</h2><p>维护一个有序单链表，越靠近链表尾部的结点是越早被访问过的。当有新的数据被访问时，从链表头开始顺序遍历链表。—-缓存访问的时间复杂度为<code>O(n)</code></p><h3 id="过程："><a href="#过程：" class="headerlink" title="过程："></a>过程：</h3><p>1 . 当访问的数据存储在缓存的链表中时，遍历得到数据对应的结点，将其从原位置删除，再将其插入到链表表头；<br>2 . 当访问的数据未出现在缓存的链表中时<br>    1）若缓存有空闲，将该数据直接插入到链表表头。<br>    2）若缓存被占满，则将链表尾部的数据删除，再将新数据插入到链表表头。</p><h3 id="优化：使用散列表，记录每个数据的位置，将缓存访问的时间复杂度降到-O-1-。"><a href="#优化：使用散列表，记录每个数据的位置，将缓存访问的时间复杂度降到-O-1-。" class="headerlink" title="优化：使用散列表，记录每个数据的位置，将缓存访问的时间复杂度降到 O(1)。"></a>优化：使用散列表，记录每个数据的位置，将缓存访问的时间复杂度降到 O(1)。</h3><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><h3 id="如何用数组实现LRU缓存淘汰策略？"><a href="#如何用数组实现LRU缓存淘汰策略？" class="headerlink" title="如何用数组实现LRU缓存淘汰策略？"></a>如何用数组实现LRU缓存淘汰策略？</h3><p>方式一：首位置保存最新访问数据，末尾位置优先清理<br>当访问的数据未存在于缓存的数组中时<br>    1）缓存有空闲，将数据插入数组第一个元素位置，数组所有元素需要向后移动1个位置，新数据插入数组第一个元素位置，时间复杂度为O(n)；<br>    2）缓存无空闲，清理数组末尾位置的元素，数组所有元素需要向后移动1个位置，新数据插入数组第一个元素位置，时间复杂度为O(n)；<br>当访问的数据存在于缓存的数组中时，查找到数据，将其从原位置删除，并将其插入数组的第一个位置，此时亦需移动数组元素，时间复杂度为O(n)。</p><p>方式二：首位置优先清理，末尾位置保存最新访问数据<br>当访问的数据未存在于缓存的数组中时<br>    1）缓存有空闲，直接将数据添加进数组作为当前最后一个元素，时间复杂度为O(1)；<br>    2）缓存无空闲，清理数组首位置的元素，数组所有元素向前移动1个位置， 将新元素插入数组，时间复杂度为O(n)；<br>当访问的数据存在于缓存的数组中时，查找到数据，将其从原位置删除，并将其插入当前数组最后一个元素的位置，此时亦需移动数组元素，时间复杂度为O(n)。</p><h4 id="优化：清理的时候可以考虑一次性清理一定数量，从而降低清理次数，提高性能。"><a href="#优化：清理的时候可以考虑一次性清理一定数量，从而降低清理次数，提高性能。" class="headerlink" title="优化：清理的时候可以考虑一次性清理一定数量，从而降低清理次数，提高性能。"></a>优化：清理的时候可以考虑一次性清理一定数量，从而降低清理次数，提高性能。</h4><h3 id="如何通过单链表实现“判断某个字符串是否为回文字符串”？"><a href="#如何通过单链表实现“判断某个字符串是否为回文字符串”？" class="headerlink" title="如何通过单链表实现“判断某个字符串是否为回文字符串”？"></a>如何通过单链表实现“判断某个字符串是否为回文字符串”？</h3><p>比如 “123454321”<br>1 . 前提：字符串以单个字符的形式存储在单链表中。<br>2 . 遍历链表，判断字符个数是否为奇数，若为偶数，则不是。<br>3 . 将链表中的字符倒序存储一份在另一个链表中。<br>4 . 同步遍历2个链表，比较对应的字符是否相等，若相等，则是回文字符串，否则，不是。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;如何用链表实现LRU缓存淘汰算法？&quot;&gt;&lt;a href=&quot;#如何用链表实现LRU缓存淘汰算法？&quot; class=&quot;headerlink&quot; title=&quot;如何用链表实现LRU缓存淘汰算法？&quot;&gt;&lt;/a&gt;如何用链表实现LRU缓存淘汰算法？&lt;/h2&gt;&lt;h3 id=&quot;缓存&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="technique summary" scheme="http://ipine.github.io/categories/technique-summary/"/>
    
    
      <category term="data_structure" scheme="http://ipine.github.io/tags/data-structure/"/>
    
      <category term="algorithm" scheme="http://ipine.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>数组</title>
    <link href="http://ipine.github.io/2018-10-09/"/>
    <id>http://ipine.github.io/2018-10-09/</id>
    <published>2018-10-09T11:24:00.000Z</published>
    <updated>2018-10-10T11:29:57.047Z</updated>
    
    <content type="html"><![CDATA[<h3 id="数组定义"><a href="#数组定义" class="headerlink" title="数组定义"></a>数组定义</h3><p>一组<code>线性表</code>数据结构。它用一组<code>连续的内存空间</code>，来存储一组具有<code>相同类型的数据</code>。</p><h4 id="关键词解释"><a href="#关键词解释" class="headerlink" title="关键词解释"></a>关键词解释</h4><ul><li><p><strong>线性表</strong>：每个线性表上的数据最多只有前和后两个方向。<br>除了<code>数组</code>，<code>链表</code>、<code>队列</code>、<code>栈</code>都是线性表结构</p><p>联想到<strong>非线性表</strong>：数据之间并不是简单的前后关系。<br>如，<code>二叉树</code>、<code>堆</code>、<code>图</code>等</p></li><li><p><strong>连续的内存空间和相同类型的数据</strong><br>正因为有了这两个限制，才使得数组有了<code>随机访问</code>的特性；<br>也正是因为这两个限制，使得<code>数组的删除、插入操作效率很低</code>。</p></li></ul><h3 id="如何实现根据下标随机访问数组元素？"><a href="#如何实现根据下标随机访问数组元素？" class="headerlink" title="如何实现根据下标随机访问数组元素？"></a>如何实现根据下标随机访问数组元素？</h3><p>计算机会给每个内存单元分配一个地址，再通过地址来访问内存中的数据。<br>而计算机通过寻址公式来计算元素存储的内存地址：</p><pre><code>//a[i]的地址就是从首地址偏移i*data_type_size的位置a[i] = base_address + i * data_type_size</code></pre><blockquote><p>base_address: 内存块的首地址<br>  data_type_size：数中每个元素的大小；根据存储的数据类型而定，如int型，该值为4</p></blockquote><h3 id="为什么数组要从0开始编号，而不是从1开始呢？"><a href="#为什么数组要从0开始编号，而不是从1开始呢？" class="headerlink" title="为什么数组要从0开始编号，而不是从1开始呢？"></a>为什么数组要从0开始编号，而不是从1开始呢？</h3><p> 若数组从1开始计数，那么上面的公式就变成</p><pre><code>a[i] = base_address + (i-1) * data_type_size</code></pre><blockquote><p>修改后，每次随机访问数组元素都多了一次减法运算，对于CPU就多了一次减法指令。</p></blockquote><h3 id="两个操作"><a href="#两个操作" class="headerlink" title="两个操作"></a>两个操作</h3><h4 id="数组的插入操作"><a href="#数组的插入操作" class="headerlink" title="数组的插入操作"></a>数组的插入操作</h4><ul><li>效率低的原因：将某个数据插入到数组中的第<code>i</code>个位置。为了给新来的元素腾出这个位置，需要移动后面的<code>i~n</code>个元素，复杂度为<code>O(n)</code>;</li><li>改进方法：当数组是无序的，简单的方法就是将原来第<code>i</code>个位置上的元素放到数组最后，然后将新来的元素放到第<code>i</code>个位置。复杂度为<code>O(1)</code>;</li></ul><h4 id="数组的删除操作"><a href="#数组的删除操作" class="headerlink" title="数组的删除操作"></a>数组的删除操作</h4><p>与插入操作类似，若删除第<code>i</code>个位置的元素，需要搬移后面的<code>i~n</code>个元素，才能保证内存的连续性。</p><ul><li>复杂度：若删除开头元素，最坏复杂度为<code>O(n)</code>；若删除数组末尾元素，最好复杂度为<code>O(1)</code>；平均复杂度为<code>O(n)</code>。</li><li>改进方法：<strong>不要求数组中数据的连续性</strong>，就可将多次删除操作集中在一起执行。<br>每次删除元素时，并不真正搬移元素，而是记录下数据已被删除。当数组没有更多空间存储数据时，再执行一次真正的删除操作（做数据元素的搬移工作）</li></ul><h3 id="数组的访问越界问题"><a href="#数组的访问越界问题" class="headerlink" title="数组的访问越界问题"></a>数组的访问越界问题</h3><p>分析以下一段代码：</p><pre><code>int main(int argc, char* argv[]){    int i = 0;    int arr[3] = {0};    for(; i&lt;=3; i++){        arr[i] = 0;        printf(&quot;hello world\n&quot;);    }    return 0;}</code></pre><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>不是只打印三行“hello world”；而是无限打印</p><h4 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h4><p>数组大小为3，<code>a[0]，a[1]，a[2]</code>，而我们的代码 for 循环的结束条件错写为了<code>i&lt;=3</code> 而非 <code>i&lt;3</code>，所以当 <code>i=3</code> 时，数组 <code>a[3]</code> 访问越界。<br>根据我们前面讲的数组寻址公式，<code>a[3]</code> 也会被定位到某块不属于数组的内存地址上，而这个地址正好是存储变量 <code>i</code> 的内存地址，那么 <code>a[3]=0</code> 就相当于 <code>i=0</code>，所以就会导致代码无限循环。</p><blockquote><p>注：例子中死循环的问题跟编译器分配内存和字节对齐有关。数组3个元素，加上一个变量i。4个整数刚好能满足8字节对齐，所以i的地址恰好跟在a[2]后面，导致死循环。如果数组本身有4个元素，则这里不会出现死循环。因为编译器64位操作系统下，默认会进行8字节对齐，变量i的地址就不会紧跟在数组后面了。</p></blockquote><h3 id="Key"><a href="#Key" class="headerlink" title="Key"></a>Key</h3><p>1 . 常会问的一个面试题：数组和链表的区别？<br>正确表述：链表适合插入、删除操作，时间复杂度为<code>O(1)</code>；数组适合随机访问数组元素(而不应该说查找)，根据下标随机访问的时间复杂度为<code>O(1)</code>。<br>明确的点：数组是适合查找，但查找的时间复杂度不为<code>O(1)</code>。即便是<strong>排好序的数组，用二分查找，时间复杂度也是O(nlogn)</strong>。</p><p>2 . 数组越界在 C 语言中是一种未决行为，并没有规定数组访问越界时编译器应该如何处理。因为，访问数组的本质就是访问一段连续内存，只要数组通过偏移计算得到的内存地址是可用的，那么程序就可能不会报任何错误。<br>在这种情况下，一般都会出现莫名其妙的逻辑错误，就像上面举的那个例子，debug的难度非常的大。而且，很多计算机病毒也正是利用到了代码中的数组越界可以访问非法地址的漏洞，来攻击系统，所以写代码的时候一定要警惕数组越界。</p><p>3 . 二维、多维数组如何寻址？<br>行优先</p><pre><code>int a[d1][d2][d3];int *p0 = &amp;a[0][0][0];int *p = &amp;a[i][j][k];int idx = i * (d2*d3) + j * d3 + kASSERT( p0 + idx == p);</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;数组定义&quot;&gt;&lt;a href=&quot;#数组定义&quot; class=&quot;headerlink&quot; title=&quot;数组定义&quot;&gt;&lt;/a&gt;数组定义&lt;/h3&gt;&lt;p&gt;一组&lt;code&gt;线性表&lt;/code&gt;数据结构。它用一组&lt;code&gt;连续的内存空间&lt;/code&gt;，来存储一组具有&lt;code&gt;相
      
    
    </summary>
    
      <category term="technique summary" scheme="http://ipine.github.io/categories/technique-summary/"/>
    
    
      <category term="data_structure" scheme="http://ipine.github.io/tags/data-structure/"/>
    
      <category term="algorithm" scheme="http://ipine.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>算法复杂度分析</title>
    <link href="http://ipine.github.io/2018-09-29/"/>
    <id>http://ipine.github.io/2018-09-29/</id>
    <published>2018-09-29T04:40:00.000Z</published>
    <updated>2018-09-29T05:04:07.533Z</updated>
    
    <content type="html"><![CDATA[<h3 id="先举个栗子"><a href="#先举个栗子" class="headerlink" title="先举个栗子"></a>先举个栗子</h3><p>分析以下这段代码的时间复杂度</p><pre><code>// n 表示数组 array 的长度int find(int[] array, int n, int x) {  int i = 0;  int pos = -1;  for (; i &lt; n; ++i) {    if (array[i] == x) pos = i;  }  return pos;}</code></pre><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><ul><li>功能：在一个无序数组array中，查找变量x出现的位置</li><li>时间复杂度：<code>O(n)</code>, n表示数组的长度</li></ul><p>更为优化的方式</p><pre><code>// n 表示数组 array 的长度int find(int[] array, int n, int x) {  int i = 0;  int pos = -1;  for (; i &lt; n; ++i) {    if (array[i] == x) {        pos = i;        break;    }  }  return pos;}</code></pre><blockquote><p>时间复杂度： 不一定是O(n)了，不同情况下这段代码的时间复杂度是不同的。</p></blockquote><h3 id="引入概念"><a href="#引入概念" class="headerlink" title="引入概念"></a>引入概念</h3><ul><li><p>最好情况时间复杂度：在最理想情况下，执行代码的时间复杂度</p></li><li><p>最坏情况时间复杂度：在最糟糕情况下，执行代码的时间复杂度</p></li><li><p>平均情况时间复杂度：最好情况和最坏情况都是属于极端情况，发生的概率并不大。需要表示平均情况下的复杂度</p></li></ul><h3 id="如何分析平均情况时间复杂度"><a href="#如何分析平均情况时间复杂度" class="headerlink" title="如何分析平均情况时间复杂度"></a>如何分析平均情况时间复杂度</h3><p>以上面的例子为例：查找x在数组中的位置，有<code>n+1</code>种情况，在数组<code>0~n-1</code>的位置上和不在数组中。<br>将每种情况下，查找需要遍历的元素个数相加，再除以n+1种情况，就可得到需要遍历的元素个数的平均值<br><code>(1+2+3+...+n+n)/n+1 = n (n+3) /2(n+1)</code><br>省略掉系数、低阶、常量后得到平均时间复杂度为<code>O(n)</code></p><h4 id="存在问题"><a href="#存在问题" class="headerlink" title="存在问题"></a>存在问题</h4><p>在以上的n+1种情况中，未考虑x在每种情况下出现的概率。<br>现在假设，x在数组中与x不在数组中的概率各为<code>1/2</code>；<br>要查找的x出现在<code>0~n-1</code>这n个位置的可能性是相同的，即<code>1/n</code>；<br>那么，要查找的x出现在<code>0~n-1</code>中任意位置的概率为 <code>1/2*1/n = 1/(2n)</code></p><p>将每种情况发生的概率考虑进去后，平均时间复杂度计算过程变成：</p><p><img src="http://p8ay1ez22.bkt.clouddn.com/18-9-29/51560357.jpg" alt="平均时间复杂度"></p><p>这个值就是概率论中的加权平均值，也叫作期望值。因而平均时间复杂度的全称为<strong>加权平均时间复杂度</strong>或<strong>期望时间复杂度</strong>。</p><blockquote><p>注：很多时候，我们只使用一个复杂度就可以满足要求。只有同一块代码在不同情况下，时间复杂度有量级的差距，才会使用以上3种复杂度的表示法来区分。</p></blockquote><h3 id="均摊时间复杂度、摊还分析（平摊分析）"><a href="#均摊时间复杂度、摊还分析（平摊分析）" class="headerlink" title="均摊时间复杂度、摊还分析（平摊分析）"></a>均摊时间复杂度、摊还分析（平摊分析）</h3><p>举栗子说明：</p><pre><code>// array 表示一个长度为 n 的数组// 代码中的 array.length 就等于 nint[] array = new int[n];int count = 0;void insert(int val) {    if (count == array.length) {       int sum = 0;       for (int i = 0; i &lt; array.length; ++i) {          sum = sum + array[i];       }       array[0] = sum;       count = 1;    }    array[count] = val;    ++count;}</code></pre><h4 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h4><ul><li>功能：实现了往数组中插入数据的功能。</li><li><p>具体：<br>1 . 当数组满了<code>count == array.length</code>,就用for循环遍历求和，将求得的和放在数组的第一个位置，并清空数组其余元素；然后再插入新的元素。<br>2 . 当数组一开始就有空闲，则直接将数据插入数组。</p></li><li><p>复杂度分析：<br>1 . 最好情况：数组中有空闲，直接将数据插入到<code>count</code>的位置，为<code>O(1)</code><br>2 . 最坏情况：数组没有空闲空间，需要先做一个遍历求和，再作插入。所以复杂度为<code>O(n)</code><br>3 . 平均时间复杂度：<code>O(1)</code> </p></li></ul><h5 id="平均时间复杂度如何得到"><a href="#平均时间复杂度如何得到" class="headerlink" title="平均时间复杂度如何得到"></a>平均时间复杂度如何得到</h5><p>总共<code>n+1</code>种情况，前<code>n</code>中情况每种时间复杂度都为<code>O(1)</code>，后一种情况时间复杂度为<code>O(n)</code>；<code>n+1</code>种情况发生的概率一样，为<code>1/(n+1)</code>；根据加权平均计算方法：</p><blockquote><p><code>1*1/(n+1) + 1*1/(n+1) + ... + n*1/(n+1) = O(1)</code></p></blockquote><h4 id="均摊时间复杂度（amortized-time-complexity）"><a href="#均摊时间复杂度（amortized-time-complexity）" class="headerlink" title="均摊时间复杂度（amortized time complexity）"></a>均摊时间复杂度（amortized time complexity）</h4><p>分析发现:<br>1 . <code>insert()</code>函数在<strong>大部分情况</strong>下，时间复杂度都为<code>O(1)</code>；<strong>极个别情况</strong>下，复杂度才高，为<code>O(n)</code><br>2 . <code>insert()</code>函数中，<code>O(1)</code>时间复杂度的插入和<code>O(n)</code>时间复杂度的插入，<strong>出现频率很有规律</strong>。存在前后时序关系，一般一个<code>O(n)</code>插入之后，紧跟着<code>n-1</code>个<code>O(1)</code>的插入操作，循环往复。</p><h5 id="针对这种场景，引入均摊分析法"><a href="#针对这种场景，引入均摊分析法" class="headerlink" title="针对这种场景，引入均摊分析法"></a>针对这种场景，引入均摊分析法</h5><p>大致思路：每一次 <code>O(n)</code> 的插入操作，都会跟着 <code>n-1</code> 次 <code>O(1)</code> 的插入操作，所以把耗时多的那次操作均摊到接下来的 <code>n-1</code> 次耗时少的操作上，均摊下来，这一组连续的操作的均摊时间复杂度就是 <code>O(1)</code>。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>对一个数据结构进行一组连续操作中，大部分情况下时间复杂度都很低，只有个别情况下时间复杂度比较高，而且这些操作之间存在前后连贯的时序关系，这个时候，我们就可以将这一组操作放在一块儿分析，看是否能将较高时间复杂度那次操作的耗时，平摊到其他那些时间复杂度比较低的操作上。<br>而且，<strong>在能够应用均摊时间复杂度分析的场合，一般均摊时间复杂度就等于最好情况时间复杂度</strong>。</p><blockquote><p>均摊时间复杂度就是一种特殊的平均时间复杂度，没必要花太多精力去区分它们。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;先举个栗子&quot;&gt;&lt;a href=&quot;#先举个栗子&quot; class=&quot;headerlink&quot; title=&quot;先举个栗子&quot;&gt;&lt;/a&gt;先举个栗子&lt;/h3&gt;&lt;p&gt;分析以下这段代码的时间复杂度&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// n 表示数组 array 的长度
int find
      
    
    </summary>
    
      <category term="technique summary" scheme="http://ipine.github.io/categories/technique-summary/"/>
    
    
      <category term="data_structure" scheme="http://ipine.github.io/tags/data-structure/"/>
    
      <category term="algorithm" scheme="http://ipine.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>算法复杂度分析</title>
    <link href="http://ipine.github.io/2018-09-28/"/>
    <id>http://ipine.github.io/2018-09-28/</id>
    <published>2018-09-28T11:09:00.000Z</published>
    <updated>2018-09-29T04:43:10.173Z</updated>
    
    <content type="html"><![CDATA[<p><code>执行效率</code>是算法优劣的度量指标，而执行效率又是通过时间、空间复杂度分析。</p><h3 id="为什么需要复杂度分析？"><a href="#为什么需要复杂度分析？" class="headerlink" title="为什么需要复杂度分析？"></a>为什么需要复杂度分析？</h3><p>将代码跑一遍，通过统计、监控，就能得到算法执行时间和占用的内存大小。—–这叫事后统计法<br>存在局限性：<br>1 . 测试结果依赖于测试环境<br>2 . 测试结果受测试数据的规模影响</p><blockquote><p>如何能不用具体的测试数据，就可以粗略估计算法的执行效率呢？</p></blockquote><h3 id="大O复杂度表示法"><a href="#大O复杂度表示法" class="headerlink" title="大O复杂度表示法"></a>大O复杂度表示法</h3><ul><li><p>首先看个栗子：</p><pre><code>int cal(int n){   int sum = 0;   int i = 1;   for (; i &lt;= n; ++i) {     sum = sum + i;   }   return sum;}</code></pre></li></ul><h4 id="CPU角度分析"><a href="#CPU角度分析" class="headerlink" title="CPU角度分析"></a>CPU角度分析</h4><p>这段代码每一行都执行着操作：<code>读数据-运算-写数据</code>。<br>每行代码对应的CPU执行个数和执行时间不同，但假设每行代码执行时间为 <code>unit_time</code>。<br>那么上面一段代码的执行时间应为： <code>(2n+2) * unit_time</code></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><blockquote><p>所有代码的执行时间 T(n) 与每行代码的执行次数成正比。</p></blockquote><ul><li><p>按照这个思路分析下面一段代码的执行时间T(n)</p><pre><code>1 int cal(int n) {2   int sum = 0;3   int i = 1;4   int j = 1;5   for (; i &lt;= n; ++i) {6     j = 1;7     for (; j &lt;= n; ++j) {8       sum = sum +  i * j;9     }10   }11 }</code></pre></li></ul><h4 id="分析过程"><a href="#分析过程" class="headerlink" title="分析过程"></a>分析过程</h4><p>对于2,3,4行，执行每行需要1个unit_time；执行5,6行需要n个unit_time；执行7,8行需要<code>n * n</code>个unit_time<br>总的执行时间为  <code>T(n) = (2n * n + 2n + 3)*unit_time</code></p><h4 id="规律总结"><a href="#规律总结" class="headerlink" title="规律总结"></a>规律总结</h4><p>通过以上两段代码的执行时间推导，得到规律：</p><blockquote><p>所有代码的执行时间 T(n) 与每行代码的执行次数 n 成正比。</p></blockquote><h4 id="公式表示"><a href="#公式表示" class="headerlink" title="公式表示"></a>公式表示</h4><blockquote><p>T(n) = O(f(n))<br>  其中，T(n)表示代码执行时间；n 表示数据规模的大小；f(n) 表示每行代码执行的次数总和； O 表示代码的执行时间 T(n) 与 f(n) 表达式成正比。</p></blockquote><p>那么以上两个例子的大O表示应为：</p><blockquote><p>T(n) = O(2n + 2)   —–&gt; T(n) = O(n)<br>  T(n) = O(2n * n + 2n + 3)   —–&gt; T(n) = O(n * n)</p></blockquote><p><strong>注：公式中的低阶、常量、系数三部分并不决定增长趋势，因而可以忽略。</strong></p><blockquote><p>大O时间复杂度实际上并不具体表示代码真正的执行时间，而是表示代码执行时间随数据规模增长的变化趋势。<br>因而，也叫作渐进时间复杂度，简称时间复杂度。</p></blockquote><h3 id="如何分析时间复杂度"><a href="#如何分析时间复杂度" class="headerlink" title="如何分析时间复杂度"></a>如何分析时间复杂度</h3><h4 id="1、只关注循环执行次数最多的一段代码"><a href="#1、只关注循环执行次数最多的一段代码" class="headerlink" title="1、只关注循环执行次数最多的一段代码"></a>1、只关注循环执行次数最多的一段代码</h4><h4 id="2、加法法则"><a href="#2、加法法则" class="headerlink" title="2、加法法则"></a>2、加法法则</h4><p>总复杂度等于量级最大的那段代码的复杂度</p><ul><li><p>举个栗子：分析下面这段代码的时间复杂度</p><pre><code>int cal(int n) {   int sum_1 = 0;   int p = 1;   for (; p &lt; 100; ++p) {     sum_1 = sum_1 + p;   }   int sum_2 = 0;   int q = 1;   for (; q &lt; n; ++q) {     sum_2 = sum_2 + q;   }   int sum_3 = 0;   int i = 1;   int j = 1;   for (; i &lt;= n; ++i) {     j = 1;     for (; j &lt;= n; ++j) {       sum_3 = sum_3 +  i * j;     }   }   return sum_1 + sum_2 + sum_3;}</code></pre></li></ul><h5 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h5><p>代码是要分别求sum_1、sum_2、sum_3。那么算时间复杂度就分别求每一部分的时间复杂度，再放在一起，取量级最大的那个作为整段代码的时间复杂度。</p><ul><li>sum_1处：执行100次，与n无关；是常量执行时间</li></ul><blockquote><p>注：即使循环100000次，只要是一个已知数，与n无关，那么就是一个常量执行时间。<br>  因为时间复杂度表示的是一个算法执行效率与数据规模增长的变化趋势，所以不管常量的执行时间多大，都可以忽略。因为其本身对增长趋势没有影响。</p></blockquote><ul><li>sum_2处：<code>O(n)</code></li><li>sum_3处：<code>O(n*n)</code><br>根据方法2，整段代码的时间复杂度就等于 <code>O(n*n)</code></li></ul><h5 id="将规律抽象成公式"><a href="#将规律抽象成公式" class="headerlink" title="将规律抽象成公式"></a>将规律抽象成公式</h5><blockquote><p>若 T1(n)=O(f(n))，T2(n)=O(g(n))；<br>那么 T(n)=T1(n)+T2(n) = max(O(f(n)), O(g(n))) = O(max(f(n), g(n))).</p></blockquote><h4 id="3、乘法法则"><a href="#3、乘法法则" class="headerlink" title="3、乘法法则"></a>3、乘法法则</h4><p>嵌套代码的复杂度等于嵌套内外代码复杂度的乘积</p><h5 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h5><blockquote><p>若 <code>T1(n)=O(f(n))，T2(n)=O(g(n))</code>；<br>那么  <code>T(n)=T1(n)*T2(n) = O(f(n))*O(g(n)) = O(f(n)*g(n))</code>.</p></blockquote><h4 id="几种常见时间复杂度实例分析"><a href="#几种常见时间复杂度实例分析" class="headerlink" title="几种常见时间复杂度实例分析"></a>几种常见时间复杂度实例分析</h4><p><img src="http://p8ay1ez22.bkt.clouddn.com/18-9-28/46917205.jpg" alt="常见复杂度实例"></p><blockquote><p>注 <code>O(1) &lt; O(logn) &lt; O(n) &lt; O(nlogn) &lt; O(n*n)</code></p></blockquote><p>以上罗列的复杂度量级，可以粗略分为两类：多项式量级、非多项式量级（指数阶和阶乘阶）</p><blockquote><p>将时间复杂度为非多项式量级的算法问题叫作NP问题。当数据规模增大时，非多项式时间复杂度的算法效率非常低。</p></blockquote><h5 id="重点关注常见的多项式时间复杂度"><a href="#重点关注常见的多项式时间复杂度" class="headerlink" title="重点关注常见的多项式时间复杂度"></a>重点关注常见的多项式时间复杂度</h5><p>1 . <code>O(1)</code><br>明确：O(1)是常量级时间复杂度的一种表示方法，并不是指只执行了一行代码。<br>一般情况下，只要算法中不存在循环语句、递归语句，即使有成千上万行的代码，其时间复杂度也是Ο(1)。</p><p>2 . <code>O(logn)</code>、<code>O(nlogn)</code><br>最难分析的一种时间复杂度<br>最常见的例子：</p><pre><code>1 i=1;2 while (i &lt;= n)  {3   i = i * 2;  //i = i * 3;4 }</code></pre><p>分析：变量i从1开始取，每循环一次就乘以2。变量i的取值就是一个等比数列： 2的x次方为n，求解x为多少。<code>x=logn</code>(以2为底)<br>若循环体内的代码改成 <code>i = i * 3</code>;那么时间复杂度为<code>O(logn)</code>(以3为底)</p><p>我们把所有对数阶的时间复杂度都记为<code>O(logn)</code><br>因为：<code>log3n</code> 就等于 <code>log32 * log2n</code>，所以 <code>O(log3n) = O(C * log2n)</code>，其中 <code>C=log32</code> 是一个常量。<br>基于我们前面的一个理论：在采用大 O 标记复杂度的时候，可以忽略系数，即 <code>O(C*f(n)) = O(f(n))</code>。</p><blockquote><p>如果一段代码的时间复杂度是 O(logn)，我们循环执行 n 遍，时间复杂度就是 O(nlogn) 。</p></blockquote><p><strong>O(nlogn) 也是一种非常常见的算法时间复杂度。比如，归并排序、快速排序的时间复杂度都是 O(nlogn)。</strong></p><p>3 . <code>O(m+n)</code>、<code>O(m*n)</code><br>代码的时间复杂度由两个数据的规模来决定。无法评估m和n谁的量级更大，所以在表示复杂度时，就不能简单利用加法法则，而忽略掉其中一个。<br>针对这种情况，原来的加法法则应改为 <code>T1(m) + T2(n) = O(f(m) + g(n))</code>；乘法法则继续有效 <code>T1(m)*T2(n) = O(f(m) * f(n))</code>。</p><h3 id="空间复杂度分析"><a href="#空间复杂度分析" class="headerlink" title="空间复杂度分析"></a>空间复杂度分析</h3><p>渐进空间复杂度，表示算法的存储空间与数据规模之间的增长关系。<br>我们常见的空间复杂度就是 <code>O(1)、 O(n)、 O(n*n )</code>，像 <code>O(logn)、 O(nlogn)</code> 这样的对数阶复杂度平时都用不到。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p><img src="http://p8ay1ez22.bkt.clouddn.com/18-9-29/66748631.jpg" alt="常见复杂度函数变化"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;执行效率&lt;/code&gt;是算法优劣的度量指标，而执行效率又是通过时间、空间复杂度分析。&lt;/p&gt;
&lt;h3 id=&quot;为什么需要复杂度分析？&quot;&gt;&lt;a href=&quot;#为什么需要复杂度分析？&quot; class=&quot;headerlink&quot; title=&quot;为什么需要复杂度分析？&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="technique summary" scheme="http://ipine.github.io/categories/technique-summary/"/>
    
    
      <category term="data_structure" scheme="http://ipine.github.io/tags/data-structure/"/>
    
      <category term="algorithm" scheme="http://ipine.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>发表的论文</title>
    <link href="http://ipine.github.io/2018-09-26/"/>
    <id>http://ipine.github.io/2018-09-26/</id>
    <published>2018-09-26T13:59:00.000Z</published>
    <updated>2018-10-31T12:54:54.838Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Acceptted-by-IEEE-VIS-2018"><a href="#Acceptted-by-IEEE-VIS-2018" class="headerlink" title="Acceptted by IEEE VIS 2018"></a><a href="http://ieeevis.org/year/2018/info/papers" target="_blank" rel="noopener">Acceptted by IEEE VIS 2018</a></h3><h4 id="Title-Evaluating-Multi-Dimensional-Visualizations-for-Understanding-Fuzzy-Clusters"><a href="#Title-Evaluating-Multi-Dimensional-Visualizations-for-Understanding-Fuzzy-Clusters" class="headerlink" title="Title: Evaluating Multi-Dimensional Visualizations for Understanding Fuzzy Clusters"></a>Title: Evaluating Multi-Dimensional Visualizations for Understanding Fuzzy Clusters</h4><ul><li><a href="https://ieeexplore.ieee.org/abstract/document/8440829" target="_blank" rel="noopener">Paper</a></li><li><a href="https://vimeo.com/289787891" target="_blank" rel="noopener">Video</a></li><li><a href="https://1drv.ms/p/s!AlEzTfE0kEurhnFiiCJzRCRrTy0H" target="_blank" rel="noopener">Talk-PPT</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Acceptted-by-IEEE-VIS-2018&quot;&gt;&lt;a href=&quot;#Acceptted-by-IEEE-VIS-2018&quot; class=&quot;headerlink&quot; title=&quot;Acceptted by IEEE VIS 2018&quot;&gt;&lt;/a&gt;&lt;a href=
      
    
    </summary>
    
      <category term="可视化论文" scheme="http://ipine.github.io/categories/%E5%8F%AF%E8%A7%86%E5%8C%96%E8%AE%BA%E6%96%87/"/>
    
    
      <category term="paper" scheme="http://ipine.github.io/tags/paper/"/>
    
      <category term="presentation" scheme="http://ipine.github.io/tags/presentation/"/>
    
  </entry>
  
  <entry>
    <title>Use Seaborn to Create Animated Graph</title>
    <link href="http://ipine.github.io/2018-09-15/"/>
    <id>http://ipine.github.io/2018-09-15/</id>
    <published>2018-09-15T08:18:00.000Z</published>
    <updated>2018-09-15T09:09:17.927Z</updated>
    
    <content type="html"><![CDATA[<p>今天看到一篇很好的文章，教我们如何在Python中创建动画图。很具有实践性，于是跟着码了一遍代码。</p><p><a href="https://towardsdatascience.com/how-to-create-animated-graphs-in-python-bb619cc2dec1" target="_blank" rel="noopener">附上文章链接</a></p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>这过程中遇到两个问题：<br>1 . 用<code>pip install ffmpeg</code>安装了FFmpeg之后，仍然不能正常运行<br>2 . 解决第一个问题后,又报<code>AttributeError:Seaborn Lineplot Module Object Has No Attribute &#39;Lineplot&#39;</code></p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="问题一"><a href="#问题一" class="headerlink" title="问题一"></a>问题一</h3><p>在Windows上安装FFmpeg需要设置环境变量。</p><h4 id="步骤一"><a href="#步骤一" class="headerlink" title="步骤一"></a>步骤一</h4><p>从<a href="https://ffmpeg.zeranoe.com/builds/" target="_blank" rel="noopener">这里</a>下载FFmpeg包，<code>ffmpeg-20180913-1b98bfb-win64-static</code>到本地，解压后，重命名文件夹为<code>FFmpeg</code>。复制或者剪切修改好的文件夹到<code>C</code>盘。</p><h4 id="步骤二"><a href="#步骤二" class="headerlink" title="步骤二"></a>步骤二</h4><p>接下来在命令行中启用FFmpeg。右键单击<code>此电脑</code>，选择<code>属性</code>，找到<code>高级系统设置</code>，进去。点击<code>环境变量</code>，可以看到两个设置变量的框，在上面的<code>xxx的用户变量</code>框里，找到<code>Path</code>,选择新增，将<code>C:\FFmpeg\bin</code>添加进去，点击<code>确定</code>。</p><h4 id="步骤三"><a href="#步骤三" class="headerlink" title="步骤三"></a>步骤三</h4><p>测试FFmpeg是否安装成功。快捷方式<code>win+R</code>，输入<code>cmd</code>进入命令控制窗口。键入<code>ffmpeg -version</code>，回车，若出现一系列关于FFmpeg的信息，说明设置成功。</p><h3 id="问题二"><a href="#问题二" class="headerlink" title="问题二"></a>问题二</h3><p>对于Seaborn包没有属性<code>Lineplot</code>问题，我首先百度了下，几乎都是建议先确认自己的Python环境是否正确，是否安装了需要用的包。于是我分别执行命令<code>pip install matplotlib</code>和<code>pip install seaborn</code>后，再重新导入这些模块到代码中，运行仍然报错。</p><p>一番折腾后，发现是seaborn包版本问题。<code>Linplot</code>在0.9版本下的seaborn环境中才可以，因而需要对seaborn包进行升级，运行命令<code>pip install seaborn==0.9.0</code>之后，再次运行代码，不报错了。</p><h2 id="注"><a href="#注" class="headerlink" title="注"></a>注</h2><p>1 . 原文中使用的代码在读取excel文件的时候使用了已废弃的<code>sheetname</code>参数，正确应该修改为<code>sheet_name</code><br>2 . 若使用的是jupyter notebook，确保在代码首行加入了<code>%matplotlib notebook</code>。<code>%matplotlib notebook</code>提供了一些交互性，可能会很慢，因为渲染由服务器端完成。<br>然鹅，我加了后，在jupyter notebook中并没有看到正常的动画效果(原因未知)。程序运行是没有问题的，在本地生成了一个视频，可以正常显示动画图。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天看到一篇很好的文章，教我们如何在Python中创建动画图。很具有实践性，于是跟着码了一遍代码。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://towardsdatascience.com/how-to-create-animated-graphs-in-python-
      
    
    </summary>
    
      <category term="technique summary" scheme="http://ipine.github.io/categories/technique-summary/"/>
    
    
      <category term="python" scheme="http://ipine.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Django入门练习的两个错误</title>
    <link href="http://ipine.github.io/2018-09-12/"/>
    <id>http://ipine.github.io/2018-09-12/</id>
    <published>2018-09-12T12:18:00.000Z</published>
    <updated>2018-09-13T13:32:32.297Z</updated>
    
    <content type="html"><![CDATA[<p>学习《Python从入门到实践》书中的第18章Django入门时，实践书中代码，遇到<code>&#39;learning_logs&#39; is not a registered namespace</code>和<code>ImproperlyConfigured: Specifying a namespace in include() without providing an app_name is not supported. Set the app_name attribute in the included module, or pass a 2-tuple containing the list of patterns and app_name instead.</code></p><h3 id="第一个错误来源"><a href="#第一个错误来源" class="headerlink" title="第一个错误来源"></a>第一个错误来源</h3><p>在创建显示<code>Topics</code>数据的网页时，按照书中流程走，创建了父模板，然后子模板继承父模板。<br>再按照三步标准流程走完：<br>1 . 添加URL模式;<br>2 . 视图创建;<br>3 . 模板创建</p><p>一切工作就绪，运行，报错了。<br>错误如下：</p><p><img src="http://p8ay1ez22.bkt.clouddn.com/18-9-13/64291775.jpg" alt="ERROR"></p><p>添加的父模板，里面有两个链接用到了命名空间<code>learning_logs</code>。<br>父模板代码如下：</p><pre><code>&lt;p&gt;  &lt;a href=&quot;{% url 'learning_logs:index' %}&quot;&gt;Learning Log&lt;/a&gt;  &lt;a href=&quot;{% url 'learning_logs:topics' %}&quot;&gt;Topics&lt;/a&gt;&lt;/p&gt;&lt;!-- 插入的块标签 content ，是一个占位符，其中包含的信息将由子模板指定。 --&gt;{% block content %}{% endblock content %}</code></pre><h3 id="排查问题"><a href="#排查问题" class="headerlink" title="排查问题"></a>排查问题</h3><p>1 . 首先看项目文件夹下的<code>settings.py</code>文件，确认应用程序<code>learning_logs</code>是否被添加进去了</p><p><img src="http://p8ay1ez22.bkt.clouddn.com/18-9-13/57959414.jpg" alt="settings.py"></p><blockquote><p>不是这里的问题</p></blockquote><p>2 . 定位到<code>urls.py</code>文件，打开项目文件下的<code>urls.py</code>文件；发现有两个版本的<code>urlpatterns</code>列表.</p><h4 id="旧版本，url式的："><a href="#旧版本，url式的：" class="headerlink" title="旧版本，url式的："></a>旧版本，url式的：</h4><pre><code>from django.conf.urls import url, include#根据书上的代码写的urlpatterns = [    url(r&apos;^admin/&apos;,admin.site.urls),    url(r&apos;&apos;,include(&apos;learning_logs.urls&apos;)),]</code></pre><blockquote><p>出现新旧版本，原因在于安装的Django的版本，书中的是1.8；而我装的2.1</p></blockquote><h4 id="新版本，path式的："><a href="#新版本，path式的：" class="headerlink" title="新版本，path式的："></a>新版本，path式的：</h4><pre><code>from django.urls import include, pathurlpatterns = [    path(&apos;admin/&apos;, admin.site.urls),    path(&apos;&apos;,include(&apos;learning_logs.urls&apos;,namespace=&apos;learning_logs&apos;)),]</code></pre><blockquote><p>我将path式的注释掉了，用的是url式的。这在今天创建新网页之前，运行都是正常的。</p></blockquote><h3 id="错误解决"><a href="#错误解决" class="headerlink" title="错误解决"></a>错误解决</h3><p>首先想到：将url式注释掉，尝试path式，看能否运行正常；结果，又报另一个错误：(</p><blockquote><p>ImproperlyConfigured: Specifying a namespace in include() without providing an app_name is not supported. Set the app_name attribute in the included module, or pass a 2-tuple containing the list of patterns and app_name instead.</p></blockquote><p>理解下意思，大致就是：应该在include模块中设置app_name属性，或者传递一个包含模式列表和app_name的2元组<br>又百度一番，知道了<code>include</code>模块需包含两个参数，前一个为2元组，后一个为<code>namespace</code>；于是将代码修改成这样：</p><pre><code>from django.urls import include, pathurlpatterns = [    path(&apos;admin/&apos;, admin.site.urls),    path(&apos;&apos;,include((&apos;learning_logs.urls&apos;,&apos;learning_logs&apos;),namespace=&apos;learning_logs&apos;)),    ]</code></pre><blockquote><p>OK! 运行正常</p></blockquote><p>网上搜索一番，发现新旧版本的区别在于是否显示声明<code>namespace</code>的值，在旧版本url式中<code>namespace</code>是注册了的，而新版本未注册。<br>用url式的代码如下：</p><pre><code>from django.conf.urls import url, includeurlpatterns = [    url(r&apos;^admin/&apos;,admin.site.urls),    url(r&apos;&apos;,include((&apos;learning_logs.urls&apos;,&apos;learning_logs&apos;))),]</code></pre><blockquote><p>Include只需包含一个参数arg：2元组；namespace不需要显示声明。</p></blockquote><p>到此，问题解决。 完：）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;学习《Python从入门到实践》书中的第18章Django入门时，实践书中代码，遇到&lt;code&gt;&amp;#39;learning_logs&amp;#39; is not a registered namespace&lt;/code&gt;和&lt;code&gt;ImproperlyConfigured: 
      
    
    </summary>
    
      <category term="technique summary" scheme="http://ipine.github.io/categories/technique-summary/"/>
    
    
      <category term="python" scheme="http://ipine.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>UnboundLocalError</title>
    <link href="http://ipine.github.io/2018-08-30/"/>
    <id>http://ipine.github.io/2018-08-30/</id>
    <published>2018-08-29T11:20:00.000Z</published>
    <updated>2018-08-31T11:39:27.496Z</updated>
    
    <content type="html"><![CDATA[<p>做《Python编程：从入门到实践》一书中的练习时，运行一段代码，遇到了变量引用的错误：</p><blockquote><p>UnboundLocalError: local variable ‘range’ referenced before assignment</p></blockquote><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><h4 id="依赖模块car-py"><a href="#依赖模块car-py" class="headerlink" title="依赖模块car.py"></a>依赖模块<code>car.py</code></h4><pre><code>&quot;&quot;&quot;一个可用于表示汽车的类&quot;&quot;&quot;#父类class Car():    &quot;&quot;&quot;一次模拟汽车的简单尝试&quot;&quot;&quot;    ...#提取出的单独类，并将其实例作为子类的一个属性值class Battery():    &quot;&quot;&quot;一次模拟电动汽车电瓶的简单尝试&quot;&quot;&quot;    def __init__(self, battery_size=60):        &quot;&quot;&quot;初始化电瓶的属性&quot;&quot;&quot;        self.battery_size = battery_size    def describe_battery(self):        &quot;&quot;&quot;打印一条描述电瓶容量的消息&quot;&quot;&quot;        print(&quot;This car has a &quot; + str(self.battery_size) + &quot;-kWh battery.&quot;)    def get_range(self):        &quot;&quot;&quot;打印一条描述电瓶续航里程的消息&quot;&quot;&quot;        if self.battery_size == 70:            range = 240        elif self.battery_size == 85:            range = 270        message = &quot;This car can go approximately &quot; + str(range)        message += &quot; miles on a full charge.&quot;        print(message)#子类        class ElectricCar(Car):    &quot;&quot;&quot;模拟电动汽车的独特之处&quot;&quot;&quot;    def __init__(self, make, model, year):        &quot;&quot;&quot;        初始化父类的属性，再初始化电动汽车特有的属性        &quot;&quot;&quot;        super().__init__(make, model, year)        #将Battery类的实例作为属性值        self.battery = Battery()</code></pre><h4 id="执行my-electric-car-py中的代码"><a href="#执行my-electric-car-py中的代码" class="headerlink" title="执行my_electric_car.py中的代码"></a>执行<code>my_electric_car.py</code>中的代码</h4><pre><code>from car import ElectricCar#实例化电动汽车my_tesla = ElectricCar(&apos;tesla&apos;, &apos;model s&apos;, 2016)print(my_tesla.get_descriptive_name())my_tesla.battery.describe_battery()#调用方法get_range()my_tesla.battery.get_range()</code></pre><h3 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h3><p>前面运行正常，就是<code>get_range()</code>方法调用出错</p><pre><code>2016 Tesla Model SThis car has a 60-kWh battery.UnboundLocalError: local variable &apos;range&apos; referenced before assignment</code></pre><blockquote><p>错误意思：在定义前就调用；即是range的作用域出了问题；<br> 观察<code>Battery</code>类可以发现变量<code>battery_size</code>的默认值给的是60；而对于<code>get_range()</code>方法中的if判断条件，<code>battery_size</code>的值不满足任何条件；因而变量<code>range</code>并没有得到实例化（即没有被声明），后面的<code>message</code>调用它就会出错。</p></blockquote><h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><p>在方法内，if条件外声明变量range。例如：</p><pre><code>def get_range(self):&quot;&quot;&quot;打印一条描述电瓶续航里程的消息&quot;&quot;&quot;#解决办法：在if条件外声明变量rangerange = 220# 当两个if条件都没有满足时，后面调用range会报错；因为它没有被声明if self.battery_size == 70:    range = 240elif self.battery_size == 85:    range = 270message = &quot;This car can go approximately &quot; + str(range)message += &quot; miles on a full charge.&quot;print(message)</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;做《Python编程：从入门到实践》一书中的练习时，运行一段代码，遇到了变量引用的错误：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;UnboundLocalError: local variable ‘range’ referenced before assignment&lt;/
      
    
    </summary>
    
      <category term="technique summary" scheme="http://ipine.github.io/categories/technique-summary/"/>
    
    
      <category term="python" scheme="http://ipine.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>IOPub data rate exceeded</title>
    <link href="http://ipine.github.io/2018-08-28/"/>
    <id>http://ipine.github.io/2018-08-28/</id>
    <published>2018-08-28T04:18:00.000Z</published>
    <updated>2018-08-31T11:17:51.265Z</updated>
    
    <content type="html"><![CDATA[<p>仍然是在爬区块链数据的过程中遇到的问题。加载爬取的<code>blockdata.json</code>数据文件时,<code>Jupyter notebook</code>显示不出来还报错：</p><blockquote><p>IOPub data rate exceeded</p></blockquote><h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>Jupyter botebook 内存设置的问题，调整过后即可正常显示。</p><h3 id="如何设置"><a href="#如何设置" class="headerlink" title="如何设置"></a>如何设置</h3><ul><li>打开<code>anaconda prompt</code>命令窗口</li><li>在该命令窗口运行： <code>jupyter notebook --generate-config</code></li><li>可以看见一个路径，找到该路径下的配置文件， 从中找到<code>iopub_data_rate_limit</code></li><li>将它的值调大（后面可以多填几个0），去掉注释</li><li>重启jupyter notebook就可以正常显示</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;仍然是在爬区块链数据的过程中遇到的问题。加载爬取的&lt;code&gt;blockdata.json&lt;/code&gt;数据文件时,&lt;code&gt;Jupyter notebook&lt;/code&gt;显示不出来还报错：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;IOPub data rate exce
      
    
    </summary>
    
      <category term="tool" scheme="http://ipine.github.io/categories/tool/"/>
    
    
      <category term="Jupyter nootebook" scheme="http://ipine.github.io/tags/Jupyter-nootebook/"/>
    
  </entry>
  
  <entry>
    <title>json读取数据出错</title>
    <link href="http://ipine.github.io/2018-08-27/"/>
    <id>http://ipine.github.io/2018-08-27/</id>
    <published>2018-08-27T10:50:00.000Z</published>
    <updated>2018-08-28T04:10:05.006Z</updated>
    
    <content type="html"><![CDATA[<p>这几天在爬区块链的数据，需要进一步做处理。在爬取过程中，遇到了问题。</p><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>当我需要读取一个字典结构的数据，该数据存在<code>json</code>文件中,类似于如下所示数据。</p><pre><code>{  &quot;hash160&quot;: &quot;6c6be098a685e95270812137e8b01b1ae7d8ffd0&quot;,  &quot;address&quot;: &quot;1AtHDAdBEw6bUtnjYQbbYjVKvSmRrdmomY&quot;,  &quot;n_tx&quot;: 2,  &quot;total_received&quot;: 60451790,  &quot;total_sent&quot;: 60451790,  &quot;final_balance&quot;: 0,}</code></pre><p>我使用<code>jupyter notebook</code> 运行如下代码，<strong>读</strong> 该文件中的数据：</p><pre><code>with open(&apos;xxx.json&apos;,&apos;r&apos;) as f:    lines = json.loads(f.read())</code></pre><p>程序抛出异常： </p><blockquote><p><strong>Extra data:</strong> line 1 column 225215 (char 225214)</p></blockquote><h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><p>发生以上错误原因是<code>json</code>只能读取一个文档对象。刚才读的字典数据在文件中的格式不正确，导致无法正确读数据。解决办法有两个：</p><h4 id="方法一：单行读取文件"><a href="#方法一：单行读取文件" class="headerlink" title="方法一：单行读取文件"></a>方法一：单行读取文件</h4><ul><li>适用于有多行json，行与行之间没有关联的情况</li></ul><pre><code>with open(&apos;xxx.json&apos;,&apos;r&apos;) as f:   for line in f.readlines():      dic = json.loads(line)</code></pre><h4 id="方法二：保存数据源的时候，格式化为一个对象"><a href="#方法二：保存数据源的时候，格式化为一个对象" class="headerlink" title="方法二：保存数据源的时候，格式化为一个对象"></a>方法二：保存数据源的时候，格式化为一个对象</h4><ul><li>适用于普遍情况；将这个文件写成一个大的json</li></ul><pre><code>with open(&apos;address.json&apos;,&apos;a&apos;) as f:    for line in address:        #循环，写入多条记录；最外层格式化        f.write(&apos;{&quot;address&quot;:[&apos;)        #将每条记录以json格式写入f        f.write(json.dumps(line,ensure_ascii=False,indent=2 ) + &apos;\n&apos;)        f.write(&apos;,&apos;)        f.write(&apos;]}&apos;)</code></pre><ul><li>读取时再作为一个文档对象处理</li></ul><pre><code>with open(&apos;address.json&apos;,&apos;a&apos;) as f:    str_json = json.loads(f.read())</code></pre><h4 id="读写json文件函数"><a href="#读写json文件函数" class="headerlink" title="读写json文件函数"></a>读写json文件函数</h4><ul><li>写json<br>一般都是方法二提到的json格式，整个文件中的数据是一个大json。函数如下</li></ul><pre><code>f.write(json.dumps())</code></pre><p> <code>json.dumps()</code>函数是将一个Python数据类型列表进行json格式的编码。可以理解为：<code>json.dumps()</code>函数是将字典转化为字符串</p><ul><li>读json<br>函数如下</li></ul><pre><code>json.loads(f.read())</code></pre><p> <code>json.loads()</code>函数是将json格式数据转换为字典。可以理解为：<code>json.loads()</code>函数是将字符串转化为字典</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这几天在爬区块链的数据，需要进一步做处理。在爬取过程中，遇到了问题。&lt;/p&gt;
&lt;h3 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h3&gt;&lt;p&gt;当我需要读取一个字典结构的数据，该数据存
      
    
    </summary>
    
      <category term="technique summary" scheme="http://ipine.github.io/categories/technique-summary/"/>
    
    
      <category term="python" scheme="http://ipine.github.io/tags/python/"/>
    
      <category term="json" scheme="http://ipine.github.io/tags/json/"/>
    
  </entry>
  
  <entry>
    <title>2018为期一个月的暑期记事</title>
    <link href="http://ipine.github.io/2018-08-04/"/>
    <id>http://ipine.github.io/2018-08-04/</id>
    <published>2018-08-04T11:52:00.000Z</published>
    <updated>2018-08-28T04:10:00.195Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>成为研究僧的第一个暑假（哈哈，此处应该有掌声，研究生也有暑假），总觉得有必要记录一下，不然对不起炎炎夏日在实验室享受着空调，搞学术的孩子们，认真脸：）。</p></blockquote><p>   在知乎上看到很多类似“xxx是种什么体验”的问题，每次一边浏览着高赞回答一边感慨，遗憾自己一个都答不上来，因为没有那个经历。然鹅，由于过去一年都沉迷在科研的海洋里无法自拔，我和小组小伙伴们居然做了一篇顶级paper，也许在某个时候也可以分享“做一篇顶级会议投稿是种什么体验”了。</p><p>   时间来到6月底，距离paper的开始已经快一年了。当paper的Revise版本提交后，导师说可以休息一个月了，交代边等最终结果边准备后续的工作。收到通知那一刻，我惊喜今年还能有假期，立马收拾东西，多一天也不想像去年，大四的那个暑假，来小组准备VIS，每天三点一线，寝室–实验室–大排档食堂。连续一个多月，在同一个食堂吃饭（除了便宜，都是毛病），真的吃到怀疑人生。</p><p>   怀着٩(๑&gt;◡&lt;๑)۶激动的心情开始了我的休假生活。终于有时间做一些想做而未做的事情。</p><h3 id="关于学习"><a href="#关于学习" class="headerlink" title="关于学习"></a>关于学习</h3><ul><li><p>学习了优达学城上的Git课程，重新熟悉和理解了git的基本概念和基本命令。终于搞清楚了git和github的关系。版本控制系统非常多，例如，我们熟悉的Wikipedia,Google Docs,手动保存也是，而git是控制系统的一种，利用版本控制系统我们可以浏览历史，可以回退到之前的某个版本。而github是一个可托管代码可利用git的远程仓库。学习完课程之后，顺便整理了自己的github仓库。在之前未完成的项目上使用版本控制工具，整理后期需要用到的数据，做了首次commit。</p></li><li><p>英语学习按计划进行着。放假的那天果断报名了英语流利说的核心课程，为期半年。每天学习半小时以上，目前打卡记录为34天。读研后，看了比较多的论文可能阅读能力提高了，但是口语和听力真的有心无力。为了能听懂大佬们的报告，再加上身边有同学报名，我也没犹豫地报了。跟着AI机器人学英语感觉还不赖，分小组监督一周至少5天的打卡。据说是定制课程，开始学习前测试了英语等级，L3，目标是学完半年达到L6。</p></li><li><p>7月12号得到论文的最终录用通知。论文最后的修改和Camera-ready排版完成。紧接着开始制作Fast forward视频，迭代了两个版本后，被告知8月回学校再做。记得当时有两个晚上，可能做得太晚，闭上眼，脑子里不断跳出修改思路。说明太晚不碰工作是有道理的，影响睡眠质量。</p></li><li><p>看《技术之瞳》一直是日程上的事情，之前计划在暑假结束前一定要看完一遍。这次囫囵吞枣地看了一遍，记录了一些题目和概念。印象最深的就是阿里的人才观：聪明、皮实、乐观、自省。聪明是既包括智商高也包括情商高，技术上“有两把刷子”的同时能够很开放地对待身边的人和事。皮实是既有抗打击的能力，也有填坑的能力，还得有经得起夸奖的能力。</p></li><li><p>之前收藏的微信公众号推送的python文章，这次放假也一并读了。算是粗略过了一遍基础知识，之后会边练习边加深理解。</p></li><li><p>看了《六神磊磊读唐诗》。读到这本书纯属缘分，有几天太无聊，翻开了它。被六神磊磊幽默诙谐的笔调给圈粉了，以读武侠的方式读唐诗，有趣。整本书的大结构就是按照唐朝的四个时期，初唐、盛唐、中唐、晚唐来讲唐诗。读完这本书，仿佛读到了千年前那些诗人们的心事，惊讶他们是如此丰富多面，有血有肉。从此伟人们也不再只是静立在书上的名字。</p></li><li><p>这一个月，终于好好思考了自己未来的职业方向。问题一直在，读研后，忙着上课，忙着实验，忙着论文，好像一直没有思考清楚。抱着增强技能的心态来读研，实际上是常常疑问自己为什么来读研，是不是自己不适合读研。我是一个不擅长做长远计划的人，或者说不会思考的人，从大学到现在一直都是顺其自然地走着，每一次做了选择，我会调整自己去适应，努力做到最好。这一年，我在成长的同时也常焦虑未来。抱怨少了，但是焦虑导致的失眠、身体状态不佳却也越来越严重，周围人表现出来的很多特质无时无刻都在宣称着自己有多糟糕。就像玩抢椅子游戏，众人在这一曲音乐里欢快地玩着，音乐戛然而止的时候，每个人都找到了自己的那把椅子开始坐下，只有我茫然地站着。假期里，和很多已经工作的朋友同学交流，心态得以调整，再结合自身的兴趣和特长，终于认定了未来的职业方向。</p></li></ul><h3 id="关于娱乐"><a href="#关于娱乐" class="headerlink" title="关于娱乐"></a>关于娱乐</h3><ul><li><p>在北京吃了一家比较正宗的川菜，金紫茗张妈妈川味馆，算是解了在长沙吃不到钵钵鸡的馋。这家店真的很良心，开在北京但是价格特别亲民，炒菜分量也是足足的。只有在美食面前，作为死宅党的我才愿意在炎炎夏日“迈开腿”，平日里的日均步数不超过200步，那天的步数是25000+。</p></li><li><p>在北京吃了一家韩菜，Tiger，这是一家米酒屋。虽然餐厅比较小，但是影响不了络绎不绝的食客。装修氛围像酒吧，自制的米酒很nice，招牌菜也强推。吃完饭几个朋友一起聊聊天，感觉不能更棒。</p></li><li><p>看了部火爆的电影，《我不是药神》。火爆到什么程度呢，就是看完电影的那个晚上，打车回去，滴滴司机一路上都在跟我们聊它。真人事件改编而成，整个观影体验就是五味杂陈，一会笑，一会哭，还有憋屈和无可奈何。</p></li><li><p>各种熬夜，一星期追完一部30来个小时的韩剧，《请回答1988》。之前就被很多朋友安利这部剧，但一直没时间看。既舍不得看完，又按奈不住地往后追，看到后面有个剧情，大家一个接一个搬离那个承载着他们整个青春记忆的胡同时，我仿佛感觉自己的青春时光也一去不复返了。每集都是一个独立主题，很治愈，尽管隔着国界，我仍能从中找到共鸣感。亲情，爱情，邻里情都在剧里被刻画得真切细腻，能够触到心底最柔软的地方。记忆深刻地是讲家庭出现矛盾后各家人的处理方式以及对互相理解作出的努力，正焕和妈妈生涩的拥抱、和配合爸爸夸张的见面礼，德善妈妈接纳丈夫的不够浪漫与细腻，德善爸爸倾听德善的诉求……家人之间，同样需要像生命体一样不断地修复更新。家人之间最好的相处方式应该就是这样相互“接纳”与相互被需要吧。</p></li></ul><h3 id="近期规划"><a href="#近期规划" class="headerlink" title="近期规划"></a>近期规划</h3><p> 今天已经是8月4号，7号前从休假状态调整回科研模式。这个月要完成的事项包括：</p><ul><li><p>15号前搞定Fast Forward和Preview视频</p></li><li><p>准备10月份会议Presentation的PPT</p></li><li><p>英语学习不能停，打卡满60天，口语练习，目标达到L4</p></li><li><p>开始阅读《增长黑客》，做读书笔记</p></li><li><p>每周2次，健身房锻炼或寝室内瑜伽</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;成为研究僧的第一个暑假（哈哈，此处应该有掌声，研究生也有暑假），总觉得有必要记录一下，不然对不起炎炎夏日在实验室享受着空调，搞学术的孩子们，认真脸：）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;   在知乎上看到很多类似“xxx是种什么体验”的问
      
    
    </summary>
    
      <category term="life" scheme="http://ipine.github.io/categories/life/"/>
    
    
      <category term="reading notes" scheme="http://ipine.github.io/tags/reading-notes/"/>
    
      <category term="essay" scheme="http://ipine.github.io/tags/essay/"/>
    
      <category term="teleplay" scheme="http://ipine.github.io/tags/teleplay/"/>
    
  </entry>
  
  <entry>
    <title>冒泡排序</title>
    <link href="http://ipine.github.io/2018-06-11/"/>
    <id>http://ipine.github.io/2018-06-11/</id>
    <published>2018-06-11T12:27:00.000Z</published>
    <updated>2018-08-28T04:09:55.295Z</updated>
    
    <content type="html"><![CDATA[<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><h4 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h4><blockquote><p>理论：<br>    1.比较轮数n-1。<br>    2.比较次数n-1。<br>    3.符合某个条件交换位置。</p></blockquote><blockquote><p>核心： 双重for循环。</p></blockquote><p><strong>步骤：</strong></p><p>1 .双重for循环。</p><p>2 .指定轮数和次数。</p><p>3 .判断是否符合标准。如果符合标准交换位置。</p><h3 id="版本比较"><a href="#版本比较" class="headerlink" title="版本比较"></a>版本比较</h3><p> 将数组元素从小到大排序：</p><h4 id="初始版"><a href="#初始版" class="headerlink" title="初始版"></a>初始版</h4><p>按照前面的步骤很容易写出以下代码：</p><pre><code>var arr = [7,6,5,4,3,2,1];//1.双重for循环。(外循环控制轮数)  for(var i=0;i&lt;arr.length-1;i++){    //2.指定轮数和次数（内循环控制次数）    for(var j=0;j&lt;arr.length-1;j++){        //3.判断是否符合标准。如果符合标准交换位置。                           if(arr[j] &gt; arr[j+1]){            var temp = arr[j];            arr[j] = arr[j+1];            arr[j+1] = temp;        }    }}</code></pre><blockquote><p><strong>改进思路</strong>：每比较一轮，就少比较一次。（每一轮都会比较出一个最大值，后一轮就没有必要再比较那个值了，所以每比较一轮，就少比较一次。）</p></blockquote><h4 id="改进版"><a href="#改进版" class="headerlink" title="改进版"></a>改进版</h4><pre><code>var arr = [7,6,5,4,3,2,1];    var m = 0;    var n = 0;for(var i=0;i&lt;arr.length-1;i++){    for(var j=0;j&lt;arr.length-1-i;j++){                       if(arr[j] &gt; arr[j+1]){            var temp = arr[j];            arr[j] = arr[j+1];            arr[j+1] = temp;        }        m++;//记录比较次数    }    n++;//记录比较轮数}console.log(arr);console.log(m);console.log(n);</code></pre><blockquote><p><strong>再升级思路</strong>：如果比较完，提前结束比较。（判断，如果本次比较没有移动任何元素，那么说明已经比较完成。）</p></blockquote><h4 id="升级版"><a href="#升级版" class="headerlink" title="升级版"></a>升级版</h4><pre><code>var arr = [1, 2, 3, 4, 5, 6, 7];var m = 0;var n = 0;for(var i=0;i&lt;arr.length-1;i++){    //开闭原则。（写在第一个for循环里，是为了每轮比较先初始化bool变量变为true。）    var bool = true;    for(var j=0;j&lt;arr.length-1-i;j++){        if(arr[j] &gt; arr[j+1]){            var temp = arr[j];            arr[j] = arr[j+1];            arr[j+1] = temp;            //如果有交换，则bool置false。            bool = false;        }        m++;    }    n++;    //如果本轮比较没有任何元素相互交换位置，那么说明已经比较完成，可以跳出循环。    if(bool){        break;    }}console.log(arr);console.log(m);console.log(n);</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;冒泡排序&quot;&gt;&lt;a href=&quot;#冒泡排序&quot; class=&quot;headerlink&quot; title=&quot;冒泡排序&quot;&gt;&lt;/a&gt;冒泡排序&lt;/h3&gt;&lt;h4 id=&quot;基本思想&quot;&gt;&lt;a href=&quot;#基本思想&quot; class=&quot;headerlink&quot; title=&quot;基本思想&quot;&gt;&lt;/a
      
    
    </summary>
    
      <category term="technique summary" scheme="http://ipine.github.io/categories/technique-summary/"/>
    
    
      <category term="排序算法" scheme="http://ipine.github.io/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>js实现before :after伪类样式修改</title>
    <link href="http://ipine.github.io/2018-06-06/"/>
    <id>http://ipine.github.io/2018-06-06/</id>
    <published>2018-06-06T03:25:00.000Z</published>
    <updated>2018-08-28T04:09:49.387Z</updated>
    
    <content type="html"><![CDATA[<p>为了能对区块的产生有一个更直观的认识，想让最新区块的产生有一个动画的展示效果（从无到有的弹入）。这里用js的<code>animate</code>函数来实现。之前有提到每个区块都用了伪类来添加样式，所以这里还需要对伪类样式作一些修改。</p><h3 id="伪类样式修改方案"><a href="#伪类样式修改方案" class="headerlink" title="伪类样式修改方案"></a>伪类样式修改方案</h3><h4 id="元素的before和after伪类的样式修改方案"><a href="#元素的before和after伪类的样式修改方案" class="headerlink" title="元素的before和after伪类的样式修改方案"></a>元素的before和after伪类的样式修改方案</h4><p>要实现某个元素的before和after伪类的样式修改，方法有4种。CSS中并不能直接选择某一个元素的<code>:before</code>和<code>:after</code>伪类元素。</p><h4 id="举个栗子说明4种方案"><a href="#举个栗子说明4种方案" class="headerlink" title="举个栗子说明4种方案"></a>举个栗子说明4种方案</h4><h4 id="HTML结构"><a href="#HTML结构" class="headerlink" title="HTML结构"></a>HTML结构</h4><pre><code>&lt;div class=&quot;box&quot;&gt;Hello,it&apos;s me.&lt;/div&gt;</code></pre><h4 id="CSS样式"><a href="#CSS样式" class="headerlink" title="CSS样式"></a>CSS样式</h4><pre><code>.box:after{    content: &apos;&apos;,    font-weight: bold}</code></pre><h4 id="方案1"><a href="#方案1" class="headerlink" title="方案1"></a>方案1</h4><p>使用js或者jQuery改变，为元素添加类</p><pre><code>.blue:after{    content: &apos;&apos;,    background-color: blue}$(&apos;div&apos;).addClass(&apos;blue&apos;);</code></pre><h4 id="方案2"><a href="#方案2" class="headerlink" title="方案2"></a>方案2</h4><p>在存在的style文档中动态插入样式</p><pre><code>document.styleSheet[0].addRule(&apos;.box:after&apos;,&apos;background-color:blue&apos;);document.styleSheet[0].insertRule(&apos;.box:after{background-color:blue}&apos;,0);</code></pre><h4 id="方案3"><a href="#方案3" class="headerlink" title="方案3"></a>方案3</h4><p>创建一份新的样式表，并使用js或jQuery将其插入到head标签中</p><pre><code>var style = document.creatElement(&apos;style&apos;);document.head.appendChild(style);sheet = style.sheet;sheet.addRule(&apos;.box:after&apos;,&apos;background-color:blue&apos;);sheet.insetRule(&apos;.box:after{background-color:blue}&apos;,0);&lt;!-- 插入操作 --&gt;$(&apos;&lt;style&gt;.box:after{background-color:blue}&lt;/style&gt;&apos;).appendTo(&apos;head&apos;);</code></pre><h4 id="方案4"><a href="#方案4" class="headerlink" title="方案4"></a>方案4</h4><p>使用HTML5的<code>data-</code>属性，在属性中使用<code>attr()</code>动态修改<br>先给div标签增加<code>data-attr = &#39;orange&#39;</code>属性，然后用jQuery修改该属性值</p><pre><code>.box:after{        content: &apos;&apos;,        font-weight: bold,        data-attr: &apos;orange&apos;    }$(&apos;div&apos;).attr(&apos;data-attr&apos;,&apos;blue&apos;);</code></pre><h3 id="我的练习"><a href="#我的练习" class="headerlink" title="我的练习"></a>我的练习</h3><h4 id="最新区块修改伪类样式"><a href="#最新区块修改伪类样式" class="headerlink" title="最新区块修改伪类样式"></a>最新区块修改伪类样式</h4><p>说明：每个区块在展示时，因为有额外的图片和时间信息需要展示，所以借助了伪类<code>before</code>和<code>after</code> <a href="https://ipine.github.io/2018-05-20/">具体实现可Pick我</a>。</p><ul><li>原来的做法：在CSS中选择要应用伪类的元素，然后设置伪类样式</li></ul><p><img src="http://p8ay1ez22.bkt.clouddn.com/18-6-6/72925655.jpg" alt="图1"></p><blockquote><p>图1 直接选择要应用伪类的元素，然后设置样式</p></blockquote><ul><li>现在的做法：给某个类名设置伪类样式，然后将该类名添加给需要该样式的元素。用的是上面提到的4个方案中的方案1，这是比较简洁和方便的做法。</li></ul><blockquote><p>注意：<code>after</code>伪类显示区块产生时间，需要通过js设置<code>data-content</code>属性值，CSS用<code>content</code>属性，获取属性<code>data-content</code>的值</p></blockquote><p><img src="http://p8ay1ez22.bkt.clouddn.com/18-6-6/56336466.jpg" alt="图2"></p><blockquote><p>图2 给某个类名应用伪类样式，before类设置小三角图片，after类显示区块产生时间</p></blockquote><h3 id="动态弹入效果"><a href="#动态弹入效果" class="headerlink" title="动态弹入效果"></a>动态弹入效果</h3><p>动态展示的最新区块，其HTML结构与其他区块不同，且还需要改变它的伪类样式。</p><h4 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h4><h5 id="动态添加节点"><a href="#动态添加节点" class="headerlink" title="动态添加节点"></a>动态添加节点</h5><p>首先把最新区块与其他区块分开。最新区块在页面加载完时是没有的，在写入区块信息之前，动态添加最新区块的节点。最新区块的HTML结构相比于其他区块，多了一层大的div.bnew，作用是为了显示链条的背景图，小三角，区块的产生时间(用到了<code>before</code>和<code>after</code>伪类，如图2所示)。因为每次刷新都需要动态添加最新区块的节点，因而在添加前需要把上一次的节点remove掉，所以具体实现如下所示。</p><p><img src="http://p8ay1ez22.bkt.clouddn.com/18-6-6/12410357.jpg" alt="图3"></p><blockquote><p>图3 jQUery动态操作节点</p></blockquote><h5 id="动画方法"><a href="#动画方法" class="headerlink" title="动画方法"></a>动画方法</h5><p>动画实现用到的是jQuery的animate()方法，语法包含4个参数</p><pre><code>$(selector).animate(styles,speed,easing,callback)</code></pre><p>参数的具体设置如下：</p><p>1 .首先动态修改<code>style</code>参数。通过<code>marginLeft</code>来控制进入方向；<code>width</code>来控制显示范围；<code>opacity</code>控制初始的隐藏状态；<br>2 .然后填加动画时间为2000ms。</p><p>具体如图4所示。<br><img src="http://p8ay1ez22.bkt.clouddn.com/18-6-6/92604390.jpg" alt="图4"></p><blockquote><p>图4 给最新区块<code>div.bnew</code>添加动画</p></blockquote><p>初始的<code>div.bnew</code>的CSS样式</p><p><img src="http://p8ay1ez22.bkt.clouddn.com/18-6-6/93921793.jpg" alt="图5"></p><blockquote><p>图5 初始的<code>div.bnew</code>样式设置</p></blockquote><blockquote><p>注：因为在animate方法中，<code>display</code>属性无法起作用，所以在初始的样式设置中要用<code>opacity</code>属性。</p></blockquote><p>3 .注意<code>easing</code>参数的设置，内置的只有2种，如下所示。</p><p><img src="http://p8ay1ez22.bkt.clouddn.com/18-6-6/17971145.jpg" alt="图6"></p><p>若要用到其他的运动轨迹需要添加库，然后引用，这里引用的是<code>easeOutBounce</code>。<a href="https://easings.net/zh-tw" target="_blank" rel="noopener">详细参数引用可Pick我</a></p><p><img src="http://p8ay1ez22.bkt.clouddn.com/18-6-6/7066421.jpg" alt="图7"></p><p>4 .最后回调函数<code>callback</code>的设置。为<code>div.bnew</code>添加类名<code>bnewT</code>（伪类样式的设置）放在这里，如图4所示。</p><h4 id="实现效果"><a href="#实现效果" class="headerlink" title="实现效果"></a>实现效果</h4><p><img src="http://p8ay1ez22.bkt.clouddn.com/18-6-6/2353727.jpg" alt="效果图"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;为了能对区块的产生有一个更直观的认识，想让最新区块的产生有一个动画的展示效果（从无到有的弹入）。这里用js的&lt;code&gt;animate&lt;/code&gt;函数来实现。之前有提到每个区块都用了伪类来添加样式，所以这里还需要对伪类样式作一些修改。&lt;/p&gt;
&lt;h3 id=&quot;伪类样式修改
      
    
    </summary>
    
      <category term="technique summary" scheme="http://ipine.github.io/categories/technique-summary/"/>
    
    
      <category term="javascript" scheme="http://ipine.github.io/tags/javascript/"/>
    
      <category term="css" scheme="http://ipine.github.io/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>《白说》</title>
    <link href="http://ipine.github.io/2018-06-03/"/>
    <id>http://ipine.github.io/2018-06-03/</id>
    <published>2018-06-03T11:52:00.000Z</published>
    <updated>2018-08-28T04:09:41.878Z</updated>
    
    <content type="html"><![CDATA[<p>繁忙的5月，在并不忙的最后几天读了《白说》。这是我第一次读白岩松老师的书，我是个很难在短时间内读完一本书的人（武侠小说除外 0.0），但这次很快就看完了。可能这跟《白说》是本类似于鸡汤的演讲集有关。白岩松作为央视的著名主持人，肯定做过很多演讲，这本书其实就是把他所讲的相同主题的演讲内容组合在一起，总共二十来篇。</p><p>他说。他姓白，所以这本书叫《白说》。他说，说了也白说，但不说，白不说。读完《白说》，我觉得很多地方都没“白说”，下面是摘录的部分读书笔记。</p><hr><h3 id="主题：漂亮的失败是另一种成功"><a href="#主题：漂亮的失败是另一种成功" class="headerlink" title="主题：漂亮的失败是另一种成功"></a>主题：漂亮的失败是另一种成功</h3><blockquote><p>白说：人如果一直处于“成功”的状态，慢慢也就麻了，所谓温水中的青蛙，你觉得一切都是理所当然。反倒是时常降临的失败与挫折，是上帝对你的一个提醒，让你从“失败”这门课里，接受某些教育。</p></blockquote><p> 人处于一帆风顺的境地，久了，可能会觉得生活太平淡反而没有什么意思。偶尔的一些逆境，让人学会某些东西，然后体验生活的不同味道。”生命远非人智所及，它由伟大的孤寂中诞生，只有从苦难中才能触及。只有困厄与苦难才能使心眼打开，看到那不为他人所知的一切”。拥抱失败与痛苦，直面现实，才能触及到生命的本质。</p><blockquote><p>白说：很多人的失败感，不是来自自己的感受，而是别人的眼光与当下世俗的标准。然后方寸大乱，然后就真觉得自己失败了。如果你不为别人的眼光与标准活着，失败的感受会在我们生活中消失大半。</p></blockquote><p> 无论做什么事，都应该建立自己的标准与目标，别让别人的眼光打扰自己的情绪和感受，信自己才是王道。</p><h3 id="主题：沟通世界不是非黑即白"><a href="#主题：沟通世界不是非黑即白" class="headerlink" title="主题：沟通世界不是非黑即白"></a>主题：沟通世界不是非黑即白</h3><blockquote><p>白说：国外的新闻报道几乎已成共识：通过具体人物，表达宏大事件。没有主人公就没有事件，就会让新闻可信度，尤其是吸引力降低。所以，你首先要明白，新闻写作传播，就是一个写故事和讲故事的过程。不要在“故事”和“虚构”之间画等号—真实的事情，也需要通过“讲故事”的方式进行传播。我们在对外、对内的宣传当中，有相当多的失败就是因为不会讲故事。花了很多钱出了很多力，却没有好的效果。</p></blockquote><p>以前也一直认为故事就等于虚构，不够贴近生活。现在才知道，生活需要我们有讲一个好故事的能力。同样一个笑话，为什么别人讲，就好好笑，自己讲，空气中弥漫的尽是尴尬。传播信息本质上也是一个讲故事的过程，学习，工作时常需要作报告和分享，这些就能体现出一个人讲故事的能力。如何讲才能更通俗易懂，更能吸引听者听下去，这些都是是需要花很多时间思考和准备的。柏拉图说： “谁会讲故事谁就拥有世界”。与人交流，学会讲故事，才能掌握主动权。</p><h3 id="主题：智商很高，情商却低"><a href="#主题：智商很高，情商却低" class="headerlink" title="主题：智商很高，情商却低"></a>主题：智商很高，情商却低</h3><blockquote><p>国家治理体系和治理能力的现代化，不仅包括依法治国，其中必然也包括提升整个社会的情商，尤其是执政者的情商。一个国家的良性运转，一个社会要达成和谐，情商必不可少，甚至高于智商。情商对于中国的执政者、媒体格外重要。中国老百姓最受用的一个词是“态度”，不管受多大委屈，如果你的情商很高，带着爱、带着温暖走到他的身边，人家立即眼泪一抹，“放心，我自力更生。”啥委屈都扔一边了。</p></blockquote><p>读到这段话的时候，感触挺深的。因为正好碰到自己遇到不公平待遇，就感觉自己其实也很受用“态度”一词，不管受多大委屈，只有别人态度诚恳，说话不那么伤人，我就觉得这些都没啥了，多大的事可能都不是事了：），可能也只有高情商的人才会想到这样做。想起之前读的一本书《所谓情商高就是会说话》，说话不只是一种“感觉”，说话还是是一种技术，同一个意思，换一个表达，效果却全然不一样。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;繁忙的5月，在并不忙的最后几天读了《白说》。这是我第一次读白岩松老师的书，我是个很难在短时间内读完一本书的人（武侠小说除外 0.0），但这次很快就看完了。可能这跟《白说》是本类似于鸡汤的演讲集有关。白岩松作为央视的著名主持人，肯定做过很多演讲，这本书其实就是把他所讲的相同主
      
    
    </summary>
    
      <category term="read" scheme="http://ipine.github.io/categories/read/"/>
    
    
      <category term="reading notes" scheme="http://ipine.github.io/tags/reading-notes/"/>
    
  </entry>
  
  <entry>
    <title>判断一个数是否是2的幂</title>
    <link href="http://ipine.github.io/2018-05-30/"/>
    <id>http://ipine.github.io/2018-05-30/</id>
    <published>2018-05-30T13:59:00.000Z</published>
    <updated>2018-08-28T04:09:35.299Z</updated>
    
    <content type="html"><![CDATA[<h2 id="最近在看《技术之瞳》，编程语言部分有一个笔试题目"><a href="#最近在看《技术之瞳》，编程语言部分有一个笔试题目" class="headerlink" title=" 最近在看《技术之瞳》，编程语言部分有一个笔试题目"></a> 最近在看《技术之瞳》，编程语言部分有一个笔试题目</h2><h3 id="Q：请填写一个表达式，用于判断一个数是否是2的幂？"><a href="#Q：请填写一个表达式，用于判断一个数是否是2的幂？" class="headerlink" title="Q：请填写一个表达式，用于判断一个数是否是2的幂？"></a>Q：请填写一个表达式，用于判断一个数是否是2的幂？</h3><h3 id="A：首先要考虑数的正负，其次判断是否为2的幂，最好的办法是利用位运算技巧。"><a href="#A：首先要考虑数的正负，其次判断是否为2的幂，最好的办法是利用位运算技巧。" class="headerlink" title="A：首先要考虑数的正负，其次判断是否为2的幂，最好的办法是利用位运算技巧。"></a>A：首先要考虑数的正负，其次判断是否为2的幂，最好的办法是利用位运算技巧。</h3><pre><code>n&gt;0? (n&amp;(n-1))==0:false</code></pre><h3 id="Key"><a href="#Key" class="headerlink" title="Key"></a>Key</h3><h4 id="将2的幂次方写成二进制形式后，很容易就会发现有一个特点："><a href="#将2的幂次方写成二进制形式后，很容易就会发现有一个特点：" class="headerlink" title="将2的幂次方写成二进制形式后，很容易就会发现有一个特点："></a>将2的幂次方写成二进制形式后，很容易就会发现有一个特点：</h4><blockquote><p>二进制中只有一个1，并且1后面跟了n个0。如果将这个数减去1后会发现，那个1会变为0，而原来的n个0会变为1。</p></blockquote><h4 id="举栗子说明"><a href="#举栗子说明" class="headerlink" title="举栗子说明"></a>举栗子说明</h4><pre><code>十进制   二进制 2        10 4        100 8        1000 16       10000 ...       ... 2-1      01 4-1      011 8-1      0111 16-1     01111</code></pre><blockquote><p>因此将原来的数与其减去1后的数字进行<code>&amp;</code>运算,为零，则原来的数是2的幂。</p></blockquote><h3 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h3><ul><li><code>&amp;</code> 按位与运算符：两位同时为1，结果才为1，否则为0。</li></ul><h4 id="作用："><a href="#作用：" class="headerlink" title="作用："></a>作用：</h4><p> 1 . 清零；想让某个数清零，则另找一个数（原数为1的位置，新数为0），两个数作与运算。<br> 2 . 取一个数中的某些位；若想取低字节位，则可和8个1作与运算。<br> 3 . 保留指定位；若23，即10111，想保留左起的2,3,5位，则可和01101（13）作与运算。</p><ul><li><code>|</code> 按位或运算符：两位中有一个为1，结果就为1。</li></ul><h4 id="作用：-1"><a href="#作用：-1" class="headerlink" title="作用："></a>作用：</h4><p> 1 . 按位或运算常用来对一个数据的某些位定值为1；若想使18，即10010的低4位改为1，则只需和13（1101）进行按位或运算即可。</p><ul><li><code>^</code> 异或运算符：两位值不同，结果为1，否则为0。</li></ul><h4 id="作用：-2"><a href="#作用：-2" class="headerlink" title="作用："></a>作用：</h4><p> 1 . 交换两个值，不用临时变量；</p><h5 id="举栗子说明-1"><a href="#举栗子说明-1" class="headerlink" title="举栗子说明"></a>举栗子说明</h5><pre><code>a=3 (011), b=5 (101);      a=a^b;                  b=a^b;               b=a^b;        </code></pre><h5 id="另一种方式"><a href="#另一种方式" class="headerlink" title="另一种方式"></a>另一种方式</h5><pre><code>a=a+b; b=a-b;a=a-b;</code></pre><ul><li><code>~</code> 取反运算符：将0变1，1变0；用于求整数的二进制反码。</li></ul><ul><li><code>&lt;&lt;</code> 左移运算符：各二进制位全部左移若干位，左边丢弃，右边补0。</li></ul><ul><li><code>&gt;&gt;</code> 右移运算符：各二进制位全部右移若干位，正数左补0，负数左补1，右边丢弃。</li></ul><ul><li>两个不同长度的数据进行位运算时，系统会将二者按右端对齐，然后进行位运算。短的那个数据如果是负数，左边补1，否则补0。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;最近在看《技术之瞳》，编程语言部分有一个笔试题目&quot;&gt;&lt;a href=&quot;#最近在看《技术之瞳》，编程语言部分有一个笔试题目&quot; class=&quot;headerlink&quot; title=&quot; 最近在看《技术之瞳》，编程语言部分有一个笔试题目&quot;&gt;&lt;/a&gt; 最近在看《技术之瞳》，编
      
    
    </summary>
    
      <category term="technique summary" scheme="http://ipine.github.io/categories/technique-summary/"/>
    
    
      <category term="面试题" scheme="http://ipine.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
      <category term="code" scheme="http://ipine.github.io/tags/code/"/>
    
  </entry>
  
</feed>
