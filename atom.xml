<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>iPine</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://ipine.github.io/"/>
  <updated>2018-09-15T09:00:57.134Z</updated>
  <id>http://ipine.github.io/</id>
  
  <author>
    <name>iPine</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Use Seaborn to Create Animated Graph</title>
    <link href="http://ipine.github.io/2018-09-15/"/>
    <id>http://ipine.github.io/2018-09-15/</id>
    <published>2018-09-15T08:18:00.000Z</published>
    <updated>2018-09-15T09:00:57.134Z</updated>
    
    <content type="html"><![CDATA[<p>今天看到一篇很好的文章，教我们如何在Python中创建动画图。很具有实践性，于是跟着码了一遍代码。</p><p><a href="https://mp.weixin.qq.com/s?__biz=MzI0NzE3NTAzOA==&amp;mid=2652119133&amp;idx=1&amp;sn=ee31498b7d1fd1a8089d8803e1ea2398&amp;chksm=f254824cc5230b5ae5b62fe8e07910f6fe38a249b5ed94d059434e82269a531a732f49598c97&amp;mpshare=1&amp;scene=1&amp;srcid=0914qnQYtDfRybOt3WkgREec#rd" target="_blank" rel="noopener">附上文章链接</a></p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>这过程中遇到两个问题：<br>1 . 用<code>pip install ffmpeg</code>安装了FFmpeg之后，仍然报错<br>2 . 解决第一个问题后,又报<code>AttributeError:Seaborn Lineplot Module Object Has No Attribute &#39;Lineplot&#39;</code></p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="问题一"><a href="#问题一" class="headerlink" title="问题一"></a>问题一</h3><p>在Windows上安装FFmpeg需要设置环境变量。</p><h4 id="步骤一"><a href="#步骤一" class="headerlink" title="步骤一"></a>步骤一</h4><p>从<a href="https://ffmpeg.zeranoe.com/builds/" target="_blank" rel="noopener">这里</a>下载FFmpeg包<code>ffmpeg-20180913-1b98bfb-win64-static</code>到本地，解压后，重命名文件夹为<code>FFmpeg</code>。复制或者剪切修改好的文件夹到<code>C</code>盘。</p><h4 id="步骤二"><a href="#步骤二" class="headerlink" title="步骤二"></a>步骤二</h4><p>接下来在命令行中启用FFmpeg。右键单击<code>此电脑</code>，选择<code>属性</code>，找到<code>高级系统设置</code>，进去。点击<code>环境变量</code>，可以看到两个设置变量的框，在上面的<code>xxx的用户变量</code>框里，找到<code>Path</code>,选择新增，将<code>C:\FFmpeg\bin</code>添加进去，点击<code>确定</code>。</p><h4 id="步骤三"><a href="#步骤三" class="headerlink" title="步骤三"></a>步骤三</h4><p>测试FFmpeg是否安装成功。快捷方式<code>win+R</code>，输入<code>cmd</code>进入命令控制窗口。键入<code>ffmpeg -version</code>，回车，若出现一系列关于FFmpeg的信息，说明设置成功。</p><h3 id="问题二"><a href="#问题二" class="headerlink" title="问题二"></a>问题二</h3><p>对于Seaborn包没有属性<code>Lineplot</code>问题，我首先百度了下，几乎都是建议先确认自己的Python环境是否正确，是否安装了需要用的包。于是我分别执行命令<code>pip install matplotlib</code>和<code>pip install seaborn</code>后，再重新导入这些模块到代码中，运行仍然报错。</p><p>一番折腾后，发现是seaborn包版本问题。<code>Linplot</code>在0.9版本下的seaborn环境中才可以，因而需要对seaborn包进行升级，运行命令<code>pip install seaborn==0.9.0</code>之后，再次运行代码，可以正常看到动画。</p><h2 id="注"><a href="#注" class="headerlink" title="注"></a>注</h2><p>1 . 原文中使用的代码在读取excel文件的时候使用了已废弃的<code>sheetname</code>参数，正确应该修改为<code>sheet_name</code><br>2 . 若使用的是jupyter notebook，确保在代码首行加入了<code>%matplotlib notebook</code>，它提供了一些交互性，可能会很慢，因为渲染由服务器端完成。虽然我加了，但是在jupyter notebook中没有看到正常的动画效果(原因未知)。程序运行没有问题，在本地生成了一个视频，可以正常显示动画图。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天看到一篇很好的文章，教我们如何在Python中创建动画图。很具有实践性，于是跟着码了一遍代码。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI0NzE3NTAzOA==&amp;amp;mid=2652119133&amp;am
      
    
    </summary>
    
      <category term="technique summary" scheme="http://ipine.github.io/categories/technique-summary/"/>
    
    
      <category term="python" scheme="http://ipine.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Django入门练习的两个错误</title>
    <link href="http://ipine.github.io/2018-09-12/"/>
    <id>http://ipine.github.io/2018-09-12/</id>
    <published>2018-09-12T12:18:00.000Z</published>
    <updated>2018-09-13T13:32:32.297Z</updated>
    
    <content type="html"><![CDATA[<p>学习《Python从入门到实践》书中的第18章Django入门时，实践书中代码，遇到<code>&#39;learning_logs&#39; is not a registered namespace</code>和<code>ImproperlyConfigured: Specifying a namespace in include() without providing an app_name is not supported. Set the app_name attribute in the included module, or pass a 2-tuple containing the list of patterns and app_name instead.</code></p><h3 id="第一个错误来源"><a href="#第一个错误来源" class="headerlink" title="第一个错误来源"></a>第一个错误来源</h3><p>在创建显示<code>Topics</code>数据的网页时，按照书中流程走，创建了父模板，然后子模板继承父模板。<br>再按照三步标准流程走完：<br>1 . 添加URL模式;<br>2 . 视图创建;<br>3 . 模板创建</p><p>一切工作就绪，运行，报错了。<br>错误如下：</p><p><img src="http://p8ay1ez22.bkt.clouddn.com/18-9-13/64291775.jpg" alt="ERROR"></p><p>添加的父模板，里面有两个链接用到了命名空间<code>learning_logs</code>。<br>父模板代码如下：</p><pre><code>&lt;p&gt;  &lt;a href=&quot;{% url 'learning_logs:index' %}&quot;&gt;Learning Log&lt;/a&gt;  &lt;a href=&quot;{% url 'learning_logs:topics' %}&quot;&gt;Topics&lt;/a&gt;&lt;/p&gt;&lt;!-- 插入的块标签 content ，是一个占位符，其中包含的信息将由子模板指定。 --&gt;{% block content %}{% endblock content %}</code></pre><h3 id="排查问题"><a href="#排查问题" class="headerlink" title="排查问题"></a>排查问题</h3><p>1 . 首先看项目文件夹下的<code>settings.py</code>文件，确认应用程序<code>learning_logs</code>是否被添加进去了</p><p><img src="http://p8ay1ez22.bkt.clouddn.com/18-9-13/57959414.jpg" alt="settings.py"></p><blockquote><p>不是这里的问题</p></blockquote><p>2 . 定位到<code>urls.py</code>文件，打开项目文件下的<code>urls.py</code>文件；发现有两个版本的<code>urlpatterns</code>列表.</p><h4 id="旧版本，url式的："><a href="#旧版本，url式的：" class="headerlink" title="旧版本，url式的："></a>旧版本，url式的：</h4><pre><code>from django.conf.urls import url, include#根据书上的代码写的urlpatterns = [    url(r&apos;^admin/&apos;,admin.site.urls),    url(r&apos;&apos;,include(&apos;learning_logs.urls&apos;)),]</code></pre><blockquote><p>出现新旧版本，原因在于安装的Django的版本，书中的是1.8；而我装的2.1</p></blockquote><h4 id="新版本，path式的："><a href="#新版本，path式的：" class="headerlink" title="新版本，path式的："></a>新版本，path式的：</h4><pre><code>from django.urls import include, pathurlpatterns = [    path(&apos;admin/&apos;, admin.site.urls),    path(&apos;&apos;,include(&apos;learning_logs.urls&apos;,namespace=&apos;learning_logs&apos;)),]</code></pre><blockquote><p>我将path式的注释掉了，用的是url式的。这在今天创建新网页之前，运行都是正常的。</p></blockquote><h3 id="错误解决"><a href="#错误解决" class="headerlink" title="错误解决"></a>错误解决</h3><p>首先想到：将url式注释掉，尝试path式，看能否运行正常；结果，又报另一个错误：(</p><blockquote><p>ImproperlyConfigured: Specifying a namespace in include() without providing an app_name is not supported. Set the app_name attribute in the included module, or pass a 2-tuple containing the list of patterns and app_name instead.</p></blockquote><p>理解下意思，大致就是：应该在include模块中设置app_name属性，或者传递一个包含模式列表和app_name的2元组<br>又百度一番，知道了<code>include</code>模块需包含两个参数，前一个为2元组，后一个为<code>namespace</code>；于是将代码修改成这样：</p><pre><code>from django.urls import include, pathurlpatterns = [    path(&apos;admin/&apos;, admin.site.urls),    path(&apos;&apos;,include((&apos;learning_logs.urls&apos;,&apos;learning_logs&apos;),namespace=&apos;learning_logs&apos;)),    ]</code></pre><blockquote><p>OK! 运行正常</p></blockquote><p>网上搜索一番，发现新旧版本的区别在于是否显示声明<code>namespace</code>的值，在旧版本url式中<code>namespace</code>是注册了的，而新版本未注册。<br>用url式的代码如下：</p><pre><code>from django.conf.urls import url, includeurlpatterns = [    url(r&apos;^admin/&apos;,admin.site.urls),    url(r&apos;&apos;,include((&apos;learning_logs.urls&apos;,&apos;learning_logs&apos;))),]</code></pre><blockquote><p>Include只需包含一个参数arg：2元组；namespace不需要显示声明。</p></blockquote><p>到此，问题解决。 完：）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;学习《Python从入门到实践》书中的第18章Django入门时，实践书中代码，遇到&lt;code&gt;&amp;#39;learning_logs&amp;#39; is not a registered namespace&lt;/code&gt;和&lt;code&gt;ImproperlyConfigured: 
      
    
    </summary>
    
      <category term="technique summary" scheme="http://ipine.github.io/categories/technique-summary/"/>
    
    
      <category term="python" scheme="http://ipine.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>UnboundLocalError</title>
    <link href="http://ipine.github.io/2018-08-30/"/>
    <id>http://ipine.github.io/2018-08-30/</id>
    <published>2018-08-29T11:20:00.000Z</published>
    <updated>2018-08-31T11:39:27.496Z</updated>
    
    <content type="html"><![CDATA[<p>做《Python编程：从入门到实践》一书中的练习时，运行一段代码，遇到了变量引用的错误：</p><blockquote><p>UnboundLocalError: local variable ‘range’ referenced before assignment</p></blockquote><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><h4 id="依赖模块car-py"><a href="#依赖模块car-py" class="headerlink" title="依赖模块car.py"></a>依赖模块<code>car.py</code></h4><pre><code>&quot;&quot;&quot;一个可用于表示汽车的类&quot;&quot;&quot;#父类class Car():    &quot;&quot;&quot;一次模拟汽车的简单尝试&quot;&quot;&quot;    ...#提取出的单独类，并将其实例作为子类的一个属性值class Battery():    &quot;&quot;&quot;一次模拟电动汽车电瓶的简单尝试&quot;&quot;&quot;    def __init__(self, battery_size=60):        &quot;&quot;&quot;初始化电瓶的属性&quot;&quot;&quot;        self.battery_size = battery_size    def describe_battery(self):        &quot;&quot;&quot;打印一条描述电瓶容量的消息&quot;&quot;&quot;        print(&quot;This car has a &quot; + str(self.battery_size) + &quot;-kWh battery.&quot;)    def get_range(self):        &quot;&quot;&quot;打印一条描述电瓶续航里程的消息&quot;&quot;&quot;        if self.battery_size == 70:            range = 240        elif self.battery_size == 85:            range = 270        message = &quot;This car can go approximately &quot; + str(range)        message += &quot; miles on a full charge.&quot;        print(message)#子类        class ElectricCar(Car):    &quot;&quot;&quot;模拟电动汽车的独特之处&quot;&quot;&quot;    def __init__(self, make, model, year):        &quot;&quot;&quot;        初始化父类的属性，再初始化电动汽车特有的属性        &quot;&quot;&quot;        super().__init__(make, model, year)        #将Battery类的实例作为属性值        self.battery = Battery()</code></pre><h4 id="执行my-electric-car-py中的代码"><a href="#执行my-electric-car-py中的代码" class="headerlink" title="执行my_electric_car.py中的代码"></a>执行<code>my_electric_car.py</code>中的代码</h4><pre><code>from car import ElectricCar#实例化电动汽车my_tesla = ElectricCar(&apos;tesla&apos;, &apos;model s&apos;, 2016)print(my_tesla.get_descriptive_name())my_tesla.battery.describe_battery()#调用方法get_range()my_tesla.battery.get_range()</code></pre><h3 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h3><p>前面运行正常，就是<code>get_range()</code>方法调用出错</p><pre><code>2016 Tesla Model SThis car has a 60-kWh battery.UnboundLocalError: local variable &apos;range&apos; referenced before assignment</code></pre><blockquote><p>错误意思：在定义前就调用；即是range的作用域出了问题；<br> 观察<code>Battery</code>类可以发现变量<code>battery_size</code>的默认值给的是60；而对于<code>get_range()</code>方法中的if判断条件，<code>battery_size</code>的值不满足任何条件；因而变量<code>range</code>并没有得到实例化（即没有被声明），后面的<code>message</code>调用它就会出错。</p></blockquote><h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><p>在方法内，if条件外声明变量range。例如：</p><pre><code>def get_range(self):&quot;&quot;&quot;打印一条描述电瓶续航里程的消息&quot;&quot;&quot;#解决办法：在if条件外声明变量rangerange = 220# 当两个if条件都没有满足时，后面调用range会报错；因为它没有被声明if self.battery_size == 70:    range = 240elif self.battery_size == 85:    range = 270message = &quot;This car can go approximately &quot; + str(range)message += &quot; miles on a full charge.&quot;print(message)</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;做《Python编程：从入门到实践》一书中的练习时，运行一段代码，遇到了变量引用的错误：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;UnboundLocalError: local variable ‘range’ referenced before assignment&lt;/
      
    
    </summary>
    
      <category term="technique summary" scheme="http://ipine.github.io/categories/technique-summary/"/>
    
    
      <category term="python" scheme="http://ipine.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>IOPub data rate exceeded</title>
    <link href="http://ipine.github.io/2018-08-28/"/>
    <id>http://ipine.github.io/2018-08-28/</id>
    <published>2018-08-28T04:18:00.000Z</published>
    <updated>2018-08-31T11:17:51.265Z</updated>
    
    <content type="html"><![CDATA[<p>仍然是在爬区块链数据的过程中遇到的问题。加载爬取的<code>blockdata.json</code>数据文件时,<code>Jupyter notebook</code>显示不出来还报错：</p><blockquote><p>IOPub data rate exceeded</p></blockquote><h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>Jupyter botebook 内存设置的问题，调整过后即可正常显示。</p><h3 id="如何设置"><a href="#如何设置" class="headerlink" title="如何设置"></a>如何设置</h3><ul><li>打开<code>anaconda prompt</code>命令窗口</li><li>在该命令窗口运行： <code>jupyter notebook --generate-config</code></li><li>可以看见一个路径，找到该路径下的配置文件， 从中找到<code>iopub_data_rate_limit</code></li><li>将它的值调大（后面可以多填几个0），去掉注释</li><li>重启jupyter notebook就可以正常显示</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;仍然是在爬区块链数据的过程中遇到的问题。加载爬取的&lt;code&gt;blockdata.json&lt;/code&gt;数据文件时,&lt;code&gt;Jupyter notebook&lt;/code&gt;显示不出来还报错：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;IOPub data rate exce
      
    
    </summary>
    
      <category term="tool" scheme="http://ipine.github.io/categories/tool/"/>
    
    
      <category term="Jupyter nootebook" scheme="http://ipine.github.io/tags/Jupyter-nootebook/"/>
    
  </entry>
  
  <entry>
    <title>json读取数据出错</title>
    <link href="http://ipine.github.io/2018-08-27/"/>
    <id>http://ipine.github.io/2018-08-27/</id>
    <published>2018-08-27T10:50:00.000Z</published>
    <updated>2018-08-28T04:10:05.006Z</updated>
    
    <content type="html"><![CDATA[<p>这几天在爬区块链的数据，需要进一步做处理。在爬取过程中，遇到了问题。</p><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>当我需要读取一个字典结构的数据，该数据存在<code>json</code>文件中,类似于如下所示数据。</p><pre><code>{  &quot;hash160&quot;: &quot;6c6be098a685e95270812137e8b01b1ae7d8ffd0&quot;,  &quot;address&quot;: &quot;1AtHDAdBEw6bUtnjYQbbYjVKvSmRrdmomY&quot;,  &quot;n_tx&quot;: 2,  &quot;total_received&quot;: 60451790,  &quot;total_sent&quot;: 60451790,  &quot;final_balance&quot;: 0,}</code></pre><p>我使用<code>jupyter notebook</code> 运行如下代码，<strong>读</strong> 该文件中的数据：</p><pre><code>with open(&apos;xxx.json&apos;,&apos;r&apos;) as f:    lines = json.loads(f.read())</code></pre><p>程序抛出异常： </p><blockquote><p><strong>Extra data:</strong> line 1 column 225215 (char 225214)</p></blockquote><h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><p>发生以上错误原因是<code>json</code>只能读取一个文档对象。刚才读的字典数据在文件中的格式不正确，导致无法正确读数据。解决办法有两个：</p><h4 id="方法一：单行读取文件"><a href="#方法一：单行读取文件" class="headerlink" title="方法一：单行读取文件"></a>方法一：单行读取文件</h4><ul><li>适用于有多行json，行与行之间没有关联的情况</li></ul><pre><code>with open(&apos;xxx.json&apos;,&apos;r&apos;) as f:   for line in f.readlines():      dic = json.loads(line)</code></pre><h4 id="方法二：保存数据源的时候，格式化为一个对象"><a href="#方法二：保存数据源的时候，格式化为一个对象" class="headerlink" title="方法二：保存数据源的时候，格式化为一个对象"></a>方法二：保存数据源的时候，格式化为一个对象</h4><ul><li>适用于普遍情况；将这个文件写成一个大的json</li></ul><pre><code>with open(&apos;address.json&apos;,&apos;a&apos;) as f:    for line in address:        #循环，写入多条记录；最外层格式化        f.write(&apos;{&quot;address&quot;:[&apos;)        #将每条记录以json格式写入f        f.write(json.dumps(line,ensure_ascii=False,indent=2 ) + &apos;\n&apos;)        f.write(&apos;,&apos;)        f.write(&apos;]}&apos;)</code></pre><ul><li>读取时再作为一个文档对象处理</li></ul><pre><code>with open(&apos;address.json&apos;,&apos;a&apos;) as f:    str_json = json.loads(f.read())</code></pre><h4 id="读写json文件函数"><a href="#读写json文件函数" class="headerlink" title="读写json文件函数"></a>读写json文件函数</h4><ul><li>写json<br>一般都是方法二提到的json格式，整个文件中的数据是一个大json。函数如下</li></ul><pre><code>f.write(json.dumps())</code></pre><p> <code>json.dumps()</code>函数是将一个Python数据类型列表进行json格式的编码。可以理解为：<code>json.dumps()</code>函数是将字典转化为字符串</p><ul><li>读json<br>函数如下</li></ul><pre><code>json.loads(f.read())</code></pre><p> <code>json.loads()</code>函数是将json格式数据转换为字典。可以理解为：<code>json.loads()</code>函数是将字符串转化为字典</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这几天在爬区块链的数据，需要进一步做处理。在爬取过程中，遇到了问题。&lt;/p&gt;
&lt;h3 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h3&gt;&lt;p&gt;当我需要读取一个字典结构的数据，该数据存
      
    
    </summary>
    
      <category term="technique summary" scheme="http://ipine.github.io/categories/technique-summary/"/>
    
    
      <category term="python" scheme="http://ipine.github.io/tags/python/"/>
    
      <category term="json" scheme="http://ipine.github.io/tags/json/"/>
    
  </entry>
  
  <entry>
    <title>2018为期一个月的暑期记事</title>
    <link href="http://ipine.github.io/2018-08-04/"/>
    <id>http://ipine.github.io/2018-08-04/</id>
    <published>2018-08-04T11:52:00.000Z</published>
    <updated>2018-08-28T04:10:00.195Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>成为研究僧的第一个暑假（哈哈，此处应该有掌声，研究生也有暑假），总觉得有必要记录一下，不然对不起炎炎夏日在实验室享受着空调，搞学术的孩子们，认真脸：）。</p></blockquote><p>   在知乎上看到很多类似“xxx是种什么体验”的问题，每次一边浏览着高赞回答一边感慨，遗憾自己一个都答不上来，因为没有那个经历。然鹅，由于过去一年都沉迷在科研的海洋里无法自拔，我和小组小伙伴们居然做了一篇顶级paper，也许在某个时候也可以分享“做一篇顶级会议投稿是种什么体验”了。</p><p>   时间来到6月底，距离paper的开始已经快一年了。当paper的Revise版本提交后，导师说可以休息一个月了，交代边等最终结果边准备后续的工作。收到通知那一刻，我惊喜今年还能有假期，立马收拾东西，多一天也不想像去年，大四的那个暑假，来小组准备VIS，每天三点一线，寝室–实验室–大排档食堂。连续一个多月，在同一个食堂吃饭（除了便宜，都是毛病），真的吃到怀疑人生。</p><p>   怀着٩(๑&gt;◡&lt;๑)۶激动的心情开始了我的休假生活。终于有时间做一些想做而未做的事情。</p><h3 id="关于学习"><a href="#关于学习" class="headerlink" title="关于学习"></a>关于学习</h3><ul><li><p>学习了优达学城上的Git课程，重新熟悉和理解了git的基本概念和基本命令。终于搞清楚了git和github的关系。版本控制系统非常多，例如，我们熟悉的Wikipedia,Google Docs,手动保存也是，而git是控制系统的一种，利用版本控制系统我们可以浏览历史，可以回退到之前的某个版本。而github是一个可托管代码可利用git的远程仓库。学习完课程之后，顺便整理了自己的github仓库。在之前未完成的项目上使用版本控制工具，整理后期需要用到的数据，做了首次commit。</p></li><li><p>英语学习按计划进行着。放假的那天果断报名了英语流利说的核心课程，为期半年。每天学习半小时以上，目前打卡记录为34天。读研后，看了比较多的论文可能阅读能力提高了，但是口语和听力真的有心无力。为了能听懂大佬们的报告，再加上身边有同学报名，我也没犹豫地报了。跟着AI机器人学英语感觉还不赖，分小组监督一周至少5天的打卡。据说是定制课程，开始学习前测试了英语等级，L3，目标是学完半年达到L6。</p></li><li><p>7月12号得到论文的最终录用通知。论文最后的修改和Camera-ready排版完成。紧接着开始制作Fast forward视频，迭代了两个版本后，被告知8月回学校再做。记得当时有两个晚上，可能做得太晚，闭上眼，脑子里不断跳出修改思路。说明太晚不碰工作是有道理的，影响睡眠质量。</p></li><li><p>看《技术之瞳》一直是日程上的事情，之前计划在暑假结束前一定要看完一遍。这次囫囵吞枣地看了一遍，记录了一些题目和概念。印象最深的就是阿里的人才观：聪明、皮实、乐观、自省。聪明是既包括智商高也包括情商高，技术上“有两把刷子”的同时能够很开放地对待身边的人和事。皮实是既有抗打击的能力，也有填坑的能力，还得有经得起夸奖的能力。</p></li><li><p>之前收藏的微信公众号推送的python文章，这次放假也一并读了。算是粗略过了一遍基础知识，之后会边练习边加深理解。</p></li><li><p>看了《六神磊磊读唐诗》。读到这本书纯属缘分，有几天太无聊，翻开了它。被六神磊磊幽默诙谐的笔调给圈粉了，以读武侠的方式读唐诗，有趣。整本书的大结构就是按照唐朝的四个时期，初唐、盛唐、中唐、晚唐来讲唐诗。读完这本书，仿佛读到了千年前那些诗人们的心事，惊讶他们是如此丰富多面，有血有肉。从此伟人们也不再只是静立在书上的名字。</p></li><li><p>这一个月，终于好好思考了自己未来的职业方向。问题一直在，读研后，忙着上课，忙着实验，忙着论文，好像一直没有思考清楚。抱着增强技能的心态来读研，实际上是常常疑问自己为什么来读研，是不是自己不适合读研。我是一个不擅长做长远计划的人，或者说不会思考的人，从大学到现在一直都是顺其自然地走着，每一次做了选择，我会调整自己去适应，努力做到最好。这一年，我在成长的同时也常焦虑未来。抱怨少了，但是焦虑导致的失眠、身体状态不佳却也越来越严重，周围人表现出来的很多特质无时无刻都在宣称着自己有多糟糕。就像玩抢椅子游戏，众人在这一曲音乐里欢快地玩着，音乐戛然而止的时候，每个人都找到了自己的那把椅子开始坐下，只有我茫然地站着。假期里，和很多已经工作的朋友同学交流，心态得以调整，再结合自身的兴趣和特长，终于认定了未来的职业方向。</p></li></ul><h3 id="关于娱乐"><a href="#关于娱乐" class="headerlink" title="关于娱乐"></a>关于娱乐</h3><ul><li><p>在北京吃了一家比较正宗的川菜，金紫茗张妈妈川味馆，算是解了在长沙吃不到钵钵鸡的馋。这家店真的很良心，开在北京但是价格特别亲民，炒菜分量也是足足的。只有在美食面前，作为死宅党的我才愿意在炎炎夏日“迈开腿”，平日里的日均步数不超过200步，那天的步数是25000+。</p></li><li><p>在北京吃了一家韩菜，Tiger，这是一家米酒屋。虽然餐厅比较小，但是影响不了络绎不绝的食客。装修氛围像酒吧，自制的米酒很nice，招牌菜也强推。吃完饭几个朋友一起聊聊天，感觉不能更棒。</p></li><li><p>看了部火爆的电影，《我不是药神》。火爆到什么程度呢，就是看完电影的那个晚上，打车回去，滴滴司机一路上都在跟我们聊它。真人事件改编而成，整个观影体验就是五味杂陈，一会笑，一会哭，还有憋屈和无可奈何。</p></li><li><p>各种熬夜，一星期追完一部30来个小时的韩剧，《请回答1988》。之前就被很多朋友安利这部剧，但一直没时间看。既舍不得看完，又按奈不住地往后追，看到后面有个剧情，大家一个接一个搬离那个承载着他们整个青春记忆的胡同时，我仿佛感觉自己的青春时光也一去不复返了。每集都是一个独立主题，很治愈，尽管隔着国界，我仍能从中找到共鸣感。亲情，爱情，邻里情都在剧里被刻画得真切细腻，能够触到心底最柔软的地方。记忆深刻地是讲家庭出现矛盾后各家人的处理方式以及对互相理解作出的努力，正焕和妈妈生涩的拥抱、和配合爸爸夸张的见面礼，德善妈妈接纳丈夫的不够浪漫与细腻，德善爸爸倾听德善的诉求……家人之间，同样需要像生命体一样不断地修复更新。家人之间最好的相处方式应该就是这样相互“接纳”与相互被需要吧。</p></li></ul><h3 id="近期规划"><a href="#近期规划" class="headerlink" title="近期规划"></a>近期规划</h3><p> 今天已经是8月4号，7号前从休假状态调整回科研模式。这个月要完成的事项包括：</p><ul><li><p>15号前搞定Fast Forward和Preview视频</p></li><li><p>准备10月份会议Presentation的PPT</p></li><li><p>英语学习不能停，打卡满60天，口语练习，目标达到L4</p></li><li><p>开始阅读《增长黑客》，做读书笔记</p></li><li><p>每周2次，健身房锻炼或寝室内瑜伽</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;成为研究僧的第一个暑假（哈哈，此处应该有掌声，研究生也有暑假），总觉得有必要记录一下，不然对不起炎炎夏日在实验室享受着空调，搞学术的孩子们，认真脸：）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;   在知乎上看到很多类似“xxx是种什么体验”的问
      
    
    </summary>
    
      <category term="life" scheme="http://ipine.github.io/categories/life/"/>
    
    
      <category term="reading notes" scheme="http://ipine.github.io/tags/reading-notes/"/>
    
      <category term="essay" scheme="http://ipine.github.io/tags/essay/"/>
    
      <category term="teleplay" scheme="http://ipine.github.io/tags/teleplay/"/>
    
  </entry>
  
  <entry>
    <title>冒泡排序</title>
    <link href="http://ipine.github.io/2018-06-11/"/>
    <id>http://ipine.github.io/2018-06-11/</id>
    <published>2018-06-11T12:27:00.000Z</published>
    <updated>2018-08-28T04:09:55.295Z</updated>
    
    <content type="html"><![CDATA[<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><h4 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h4><blockquote><p>理论：<br>    1.比较轮数n-1。<br>    2.比较次数n-1。<br>    3.符合某个条件交换位置。</p></blockquote><blockquote><p>核心： 双重for循环。</p></blockquote><p><strong>步骤：</strong></p><p>1 .双重for循环。</p><p>2 .指定轮数和次数。</p><p>3 .判断是否符合标准。如果符合标准交换位置。</p><h3 id="版本比较"><a href="#版本比较" class="headerlink" title="版本比较"></a>版本比较</h3><p> 将数组元素从小到大排序：</p><h4 id="初始版"><a href="#初始版" class="headerlink" title="初始版"></a>初始版</h4><p>按照前面的步骤很容易写出以下代码：</p><pre><code>var arr = [7,6,5,4,3,2,1];//1.双重for循环。(外循环控制轮数)  for(var i=0;i&lt;arr.length-1;i++){    //2.指定轮数和次数（内循环控制次数）    for(var j=0;j&lt;arr.length-1;j++){        //3.判断是否符合标准。如果符合标准交换位置。                           if(arr[j] &gt; arr[j+1]){            var temp = arr[j];            arr[j] = arr[j+1];            arr[j+1] = temp;        }    }}</code></pre><blockquote><p><strong>改进思路</strong>：每比较一轮，就少比较一次。（每一轮都会比较出一个最大值，后一轮就没有必要再比较那个值了，所以每比较一轮，就少比较一次。）</p></blockquote><h4 id="改进版"><a href="#改进版" class="headerlink" title="改进版"></a>改进版</h4><pre><code>var arr = [7,6,5,4,3,2,1];    var m = 0;    var n = 0;for(var i=0;i&lt;arr.length-1;i++){    for(var j=0;j&lt;arr.length-1-i;j++){                       if(arr[j] &gt; arr[j+1]){            var temp = arr[j];            arr[j] = arr[j+1];            arr[j+1] = temp;        }        m++;//记录比较次数    }    n++;//记录比较轮数}console.log(arr);console.log(m);console.log(n);</code></pre><blockquote><p><strong>再升级思路</strong>：如果比较完，提前结束比较。（判断，如果本次比较没有移动任何元素，那么说明已经比较完成。）</p></blockquote><h4 id="升级版"><a href="#升级版" class="headerlink" title="升级版"></a>升级版</h4><pre><code>var arr = [1, 2, 3, 4, 5, 6, 7];var m = 0;var n = 0;for(var i=0;i&lt;arr.length-1;i++){    //开闭原则。（写在第一个for循环里，是为了每轮比较先初始化bool变量变为true。）    var bool = true;    for(var j=0;j&lt;arr.length-1-i;j++){        if(arr[j] &gt; arr[j+1]){            var temp = arr[j];            arr[j] = arr[j+1];            arr[j+1] = temp;            //如果有交换，则bool置false。            bool = false;        }        m++;    }    n++;    //如果本轮比较没有任何元素相互交换位置，那么说明已经比较完成，可以跳出循环。    if(bool){        break;    }}console.log(arr);console.log(m);console.log(n);</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;冒泡排序&quot;&gt;&lt;a href=&quot;#冒泡排序&quot; class=&quot;headerlink&quot; title=&quot;冒泡排序&quot;&gt;&lt;/a&gt;冒泡排序&lt;/h3&gt;&lt;h4 id=&quot;基本思想&quot;&gt;&lt;a href=&quot;#基本思想&quot; class=&quot;headerlink&quot; title=&quot;基本思想&quot;&gt;&lt;/a
      
    
    </summary>
    
      <category term="technique summary" scheme="http://ipine.github.io/categories/technique-summary/"/>
    
    
      <category term="排序算法" scheme="http://ipine.github.io/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>js实现before :after伪类样式修改</title>
    <link href="http://ipine.github.io/2018-06-06/"/>
    <id>http://ipine.github.io/2018-06-06/</id>
    <published>2018-06-06T03:25:00.000Z</published>
    <updated>2018-08-28T04:09:49.387Z</updated>
    
    <content type="html"><![CDATA[<p>为了能对区块的产生有一个更直观的认识，想让最新区块的产生有一个动画的展示效果（从无到有的弹入）。这里用js的<code>animate</code>函数来实现。之前有提到每个区块都用了伪类来添加样式，所以这里还需要对伪类样式作一些修改。</p><h3 id="伪类样式修改方案"><a href="#伪类样式修改方案" class="headerlink" title="伪类样式修改方案"></a>伪类样式修改方案</h3><h4 id="元素的before和after伪类的样式修改方案"><a href="#元素的before和after伪类的样式修改方案" class="headerlink" title="元素的before和after伪类的样式修改方案"></a>元素的before和after伪类的样式修改方案</h4><p>要实现某个元素的before和after伪类的样式修改，方法有4种。CSS中并不能直接选择某一个元素的<code>:before</code>和<code>:after</code>伪类元素。</p><h4 id="举个栗子说明4种方案"><a href="#举个栗子说明4种方案" class="headerlink" title="举个栗子说明4种方案"></a>举个栗子说明4种方案</h4><h4 id="HTML结构"><a href="#HTML结构" class="headerlink" title="HTML结构"></a>HTML结构</h4><pre><code>&lt;div class=&quot;box&quot;&gt;Hello,it&apos;s me.&lt;/div&gt;</code></pre><h4 id="CSS样式"><a href="#CSS样式" class="headerlink" title="CSS样式"></a>CSS样式</h4><pre><code>.box:after{    content: &apos;&apos;,    font-weight: bold}</code></pre><h4 id="方案1"><a href="#方案1" class="headerlink" title="方案1"></a>方案1</h4><p>使用js或者jQuery改变，为元素添加类</p><pre><code>.blue:after{    content: &apos;&apos;,    background-color: blue}$(&apos;div&apos;).addClass(&apos;blue&apos;);</code></pre><h4 id="方案2"><a href="#方案2" class="headerlink" title="方案2"></a>方案2</h4><p>在存在的style文档中动态插入样式</p><pre><code>document.styleSheet[0].addRule(&apos;.box:after&apos;,&apos;background-color:blue&apos;);document.styleSheet[0].insertRule(&apos;.box:after{background-color:blue}&apos;,0);</code></pre><h4 id="方案3"><a href="#方案3" class="headerlink" title="方案3"></a>方案3</h4><p>创建一份新的样式表，并使用js或jQuery将其插入到head标签中</p><pre><code>var style = document.creatElement(&apos;style&apos;);document.head.appendChild(style);sheet = style.sheet;sheet.addRule(&apos;.box:after&apos;,&apos;background-color:blue&apos;);sheet.insetRule(&apos;.box:after{background-color:blue}&apos;,0);&lt;!-- 插入操作 --&gt;$(&apos;&lt;style&gt;.box:after{background-color:blue}&lt;/style&gt;&apos;).appendTo(&apos;head&apos;);</code></pre><h4 id="方案4"><a href="#方案4" class="headerlink" title="方案4"></a>方案4</h4><p>使用HTML5的<code>data-</code>属性，在属性中使用<code>attr()</code>动态修改<br>先给div标签增加<code>data-attr = &#39;orange&#39;</code>属性，然后用jQuery修改该属性值</p><pre><code>.box:after{        content: &apos;&apos;,        font-weight: bold,        data-attr: &apos;orange&apos;    }$(&apos;div&apos;).attr(&apos;data-attr&apos;,&apos;blue&apos;);</code></pre><h3 id="我的练习"><a href="#我的练习" class="headerlink" title="我的练习"></a>我的练习</h3><h4 id="最新区块修改伪类样式"><a href="#最新区块修改伪类样式" class="headerlink" title="最新区块修改伪类样式"></a>最新区块修改伪类样式</h4><p>说明：每个区块在展示时，因为有额外的图片和时间信息需要展示，所以借助了伪类<code>before</code>和<code>after</code> <a href="https://ipine.github.io/2018-05-20/">具体实现可Pick我</a>。</p><ul><li>原来的做法：在CSS中选择要应用伪类的元素，然后设置伪类样式</li></ul><p><img src="http://p8ay1ez22.bkt.clouddn.com/18-6-6/72925655.jpg" alt="图1"></p><blockquote><p>图1 直接选择要应用伪类的元素，然后设置样式</p></blockquote><ul><li>现在的做法：给某个类名设置伪类样式，然后将该类名添加给需要该样式的元素。用的是上面提到的4个方案中的方案1，这是比较简洁和方便的做法。</li></ul><blockquote><p>注意：<code>after</code>伪类显示区块产生时间，需要通过js设置<code>data-content</code>属性值，CSS用<code>content</code>属性，获取属性<code>data-content</code>的值</p></blockquote><p><img src="http://p8ay1ez22.bkt.clouddn.com/18-6-6/56336466.jpg" alt="图2"></p><blockquote><p>图2 给某个类名应用伪类样式，before类设置小三角图片，after类显示区块产生时间</p></blockquote><h3 id="动态弹入效果"><a href="#动态弹入效果" class="headerlink" title="动态弹入效果"></a>动态弹入效果</h3><p>动态展示的最新区块，其HTML结构与其他区块不同，且还需要改变它的伪类样式。</p><h4 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h4><h5 id="动态添加节点"><a href="#动态添加节点" class="headerlink" title="动态添加节点"></a>动态添加节点</h5><p>首先把最新区块与其他区块分开。最新区块在页面加载完时是没有的，在写入区块信息之前，动态添加最新区块的节点。最新区块的HTML结构相比于其他区块，多了一层大的div.bnew，作用是为了显示链条的背景图，小三角，区块的产生时间(用到了<code>before</code>和<code>after</code>伪类，如图2所示)。因为每次刷新都需要动态添加最新区块的节点，因而在添加前需要把上一次的节点remove掉，所以具体实现如下所示。</p><p><img src="http://p8ay1ez22.bkt.clouddn.com/18-6-6/12410357.jpg" alt="图3"></p><blockquote><p>图3 jQUery动态操作节点</p></blockquote><h5 id="动画方法"><a href="#动画方法" class="headerlink" title="动画方法"></a>动画方法</h5><p>动画实现用到的是jQuery的animate()方法，语法包含4个参数</p><pre><code>$(selector).animate(styles,speed,easing,callback)</code></pre><p>参数的具体设置如下：</p><p>1 .首先动态修改<code>style</code>参数。通过<code>marginLeft</code>来控制进入方向；<code>width</code>来控制显示范围；<code>opacity</code>控制初始的隐藏状态；<br>2 .然后填加动画时间为2000ms。</p><p>具体如图4所示。<br><img src="http://p8ay1ez22.bkt.clouddn.com/18-6-6/92604390.jpg" alt="图4"></p><blockquote><p>图4 给最新区块<code>div.bnew</code>添加动画</p></blockquote><p>初始的<code>div.bnew</code>的CSS样式</p><p><img src="http://p8ay1ez22.bkt.clouddn.com/18-6-6/93921793.jpg" alt="图5"></p><blockquote><p>图5 初始的<code>div.bnew</code>样式设置</p></blockquote><blockquote><p>注：因为在animate方法中，<code>display</code>属性无法起作用，所以在初始的样式设置中要用<code>opacity</code>属性。</p></blockquote><p>3 .注意<code>easing</code>参数的设置，内置的只有2种，如下所示。</p><p><img src="http://p8ay1ez22.bkt.clouddn.com/18-6-6/17971145.jpg" alt="图6"></p><p>若要用到其他的运动轨迹需要添加库，然后引用，这里引用的是<code>easeOutBounce</code>。<a href="https://easings.net/zh-tw" target="_blank" rel="noopener">详细参数引用可Pick我</a></p><p><img src="http://p8ay1ez22.bkt.clouddn.com/18-6-6/7066421.jpg" alt="图7"></p><p>4 .最后回调函数<code>callback</code>的设置。为<code>div.bnew</code>添加类名<code>bnewT</code>（伪类样式的设置）放在这里，如图4所示。</p><h4 id="实现效果"><a href="#实现效果" class="headerlink" title="实现效果"></a>实现效果</h4><p><img src="http://p8ay1ez22.bkt.clouddn.com/18-6-6/2353727.jpg" alt="效果图"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;为了能对区块的产生有一个更直观的认识，想让最新区块的产生有一个动画的展示效果（从无到有的弹入）。这里用js的&lt;code&gt;animate&lt;/code&gt;函数来实现。之前有提到每个区块都用了伪类来添加样式，所以这里还需要对伪类样式作一些修改。&lt;/p&gt;
&lt;h3 id=&quot;伪类样式修改
      
    
    </summary>
    
      <category term="technique summary" scheme="http://ipine.github.io/categories/technique-summary/"/>
    
    
      <category term="javascript" scheme="http://ipine.github.io/tags/javascript/"/>
    
      <category term="css" scheme="http://ipine.github.io/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>《白说》</title>
    <link href="http://ipine.github.io/2018-06-03/"/>
    <id>http://ipine.github.io/2018-06-03/</id>
    <published>2018-06-03T11:52:00.000Z</published>
    <updated>2018-08-28T04:09:41.878Z</updated>
    
    <content type="html"><![CDATA[<p>繁忙的5月，在并不忙的最后几天读了《白说》。这是我第一次读白岩松老师的书，我是个很难在短时间内读完一本书的人（武侠小说除外 0.0），但这次很快就看完了。可能这跟《白说》是本类似于鸡汤的演讲集有关。白岩松作为央视的著名主持人，肯定做过很多演讲，这本书其实就是把他所讲的相同主题的演讲内容组合在一起，总共二十来篇。</p><p>他说。他姓白，所以这本书叫《白说》。他说，说了也白说，但不说，白不说。读完《白说》，我觉得很多地方都没“白说”，下面是摘录的部分读书笔记。</p><hr><h3 id="主题：漂亮的失败是另一种成功"><a href="#主题：漂亮的失败是另一种成功" class="headerlink" title="主题：漂亮的失败是另一种成功"></a>主题：漂亮的失败是另一种成功</h3><blockquote><p>白说：人如果一直处于“成功”的状态，慢慢也就麻了，所谓温水中的青蛙，你觉得一切都是理所当然。反倒是时常降临的失败与挫折，是上帝对你的一个提醒，让你从“失败”这门课里，接受某些教育。</p></blockquote><p> 人处于一帆风顺的境地，久了，可能会觉得生活太平淡反而没有什么意思。偶尔的一些逆境，让人学会某些东西，然后体验生活的不同味道。”生命远非人智所及，它由伟大的孤寂中诞生，只有从苦难中才能触及。只有困厄与苦难才能使心眼打开，看到那不为他人所知的一切”。拥抱失败与痛苦，直面现实，才能触及到生命的本质。</p><blockquote><p>白说：很多人的失败感，不是来自自己的感受，而是别人的眼光与当下世俗的标准。然后方寸大乱，然后就真觉得自己失败了。如果你不为别人的眼光与标准活着，失败的感受会在我们生活中消失大半。</p></blockquote><p> 无论做什么事，都应该建立自己的标准与目标，别让别人的眼光打扰自己的情绪和感受，信自己才是王道。</p><h3 id="主题：沟通世界不是非黑即白"><a href="#主题：沟通世界不是非黑即白" class="headerlink" title="主题：沟通世界不是非黑即白"></a>主题：沟通世界不是非黑即白</h3><blockquote><p>白说：国外的新闻报道几乎已成共识：通过具体人物，表达宏大事件。没有主人公就没有事件，就会让新闻可信度，尤其是吸引力降低。所以，你首先要明白，新闻写作传播，就是一个写故事和讲故事的过程。不要在“故事”和“虚构”之间画等号—真实的事情，也需要通过“讲故事”的方式进行传播。我们在对外、对内的宣传当中，有相当多的失败就是因为不会讲故事。花了很多钱出了很多力，却没有好的效果。</p></blockquote><p>以前也一直认为故事就等于虚构，不够贴近生活。现在才知道，生活需要我们有讲一个好故事的能力。同样一个笑话，为什么别人讲，就好好笑，自己讲，空气中弥漫的尽是尴尬。传播信息本质上也是一个讲故事的过程，学习，工作时常需要作报告和分享，这些就能体现出一个人讲故事的能力。如何讲才能更通俗易懂，更能吸引听者听下去，这些都是是需要花很多时间思考和准备的。柏拉图说： “谁会讲故事谁就拥有世界”。与人交流，学会讲故事，才能掌握主动权。</p><h3 id="主题：智商很高，情商却低"><a href="#主题：智商很高，情商却低" class="headerlink" title="主题：智商很高，情商却低"></a>主题：智商很高，情商却低</h3><blockquote><p>国家治理体系和治理能力的现代化，不仅包括依法治国，其中必然也包括提升整个社会的情商，尤其是执政者的情商。一个国家的良性运转，一个社会要达成和谐，情商必不可少，甚至高于智商。情商对于中国的执政者、媒体格外重要。中国老百姓最受用的一个词是“态度”，不管受多大委屈，如果你的情商很高，带着爱、带着温暖走到他的身边，人家立即眼泪一抹，“放心，我自力更生。”啥委屈都扔一边了。</p></blockquote><p>读到这段话的时候，感触挺深的。因为正好碰到自己遇到不公平待遇，就感觉自己其实也很受用“态度”一词，不管受多大委屈，只有别人态度诚恳，说话不那么伤人，我就觉得这些都没啥了，多大的事可能都不是事了：），可能也只有高情商的人才会想到这样做。想起之前读的一本书《所谓情商高就是会说话》，说话不只是一种“感觉”，说话还是是一种技术，同一个意思，换一个表达，效果却全然不一样。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;繁忙的5月，在并不忙的最后几天读了《白说》。这是我第一次读白岩松老师的书，我是个很难在短时间内读完一本书的人（武侠小说除外 0.0），但这次很快就看完了。可能这跟《白说》是本类似于鸡汤的演讲集有关。白岩松作为央视的著名主持人，肯定做过很多演讲，这本书其实就是把他所讲的相同主
      
    
    </summary>
    
      <category term="read" scheme="http://ipine.github.io/categories/read/"/>
    
    
      <category term="reading notes" scheme="http://ipine.github.io/tags/reading-notes/"/>
    
  </entry>
  
  <entry>
    <title>判断一个数是否是2的幂</title>
    <link href="http://ipine.github.io/2018-05-30/"/>
    <id>http://ipine.github.io/2018-05-30/</id>
    <published>2018-05-30T13:59:00.000Z</published>
    <updated>2018-08-28T04:09:35.299Z</updated>
    
    <content type="html"><![CDATA[<h2 id="最近在看《技术之瞳》，编程语言部分有一个笔试题目"><a href="#最近在看《技术之瞳》，编程语言部分有一个笔试题目" class="headerlink" title=" 最近在看《技术之瞳》，编程语言部分有一个笔试题目"></a> 最近在看《技术之瞳》，编程语言部分有一个笔试题目</h2><h3 id="Q：请填写一个表达式，用于判断一个数是否是2的幂？"><a href="#Q：请填写一个表达式，用于判断一个数是否是2的幂？" class="headerlink" title="Q：请填写一个表达式，用于判断一个数是否是2的幂？"></a>Q：请填写一个表达式，用于判断一个数是否是2的幂？</h3><h3 id="A：首先要考虑数的正负，其次判断是否为2的幂，最好的办法是利用位运算技巧。"><a href="#A：首先要考虑数的正负，其次判断是否为2的幂，最好的办法是利用位运算技巧。" class="headerlink" title="A：首先要考虑数的正负，其次判断是否为2的幂，最好的办法是利用位运算技巧。"></a>A：首先要考虑数的正负，其次判断是否为2的幂，最好的办法是利用位运算技巧。</h3><pre><code>n&gt;0? (n&amp;(n-1))==0:false</code></pre><h3 id="Key"><a href="#Key" class="headerlink" title="Key"></a>Key</h3><h4 id="将2的幂次方写成二进制形式后，很容易就会发现有一个特点："><a href="#将2的幂次方写成二进制形式后，很容易就会发现有一个特点：" class="headerlink" title="将2的幂次方写成二进制形式后，很容易就会发现有一个特点："></a>将2的幂次方写成二进制形式后，很容易就会发现有一个特点：</h4><blockquote><p>二进制中只有一个1，并且1后面跟了n个0。如果将这个数减去1后会发现，那个1会变为0，而原来的n个0会变为1。</p></blockquote><h4 id="举栗子说明"><a href="#举栗子说明" class="headerlink" title="举栗子说明"></a>举栗子说明</h4><pre><code>十进制   二进制 2        10 4        100 8        1000 16       10000 ...       ... 2-1      01 4-1      011 8-1      0111 16-1     01111</code></pre><blockquote><p>因此将原来的数与其减去1后的数字进行<code>&amp;</code>运算,为零，则原来的数是2的幂。</p></blockquote><h3 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h3><ul><li><code>&amp;</code> 按位与运算符：两位同时为1，结果才为1，否则为0。</li></ul><h4 id="作用："><a href="#作用：" class="headerlink" title="作用："></a>作用：</h4><p> 1 . 清零；想让某个数清零，则另找一个数（原数为1的位置，新数为0），两个数作与运算。<br> 2 . 取一个数中的某些位；若想取低字节位，则可和8个1作与运算。<br> 3 . 保留指定位；若23，即10111，想保留左起的2,3,5位，则可和01101（13）作与运算。</p><ul><li><code>|</code> 按位或运算符：两位中有一个为1，结果就为1。</li></ul><h4 id="作用：-1"><a href="#作用：-1" class="headerlink" title="作用："></a>作用：</h4><p> 1 . 按位或运算常用来对一个数据的某些位定值为1；若想使18，即10010的低4位改为1，则只需和13（1101）进行按位或运算即可。</p><ul><li><code>^</code> 异或运算符：两位值不同，结果为1，否则为0。</li></ul><h4 id="作用：-2"><a href="#作用：-2" class="headerlink" title="作用："></a>作用：</h4><p> 1 . 交换两个值，不用临时变量；</p><h5 id="举栗子说明-1"><a href="#举栗子说明-1" class="headerlink" title="举栗子说明"></a>举栗子说明</h5><pre><code>a=3 (011), b=5 (101);      a=a^b;                  b=a^b;               b=a^b;        </code></pre><h5 id="另一种方式"><a href="#另一种方式" class="headerlink" title="另一种方式"></a>另一种方式</h5><pre><code>a=a+b; b=a-b;a=a-b;</code></pre><ul><li><code>~</code> 取反运算符：将0变1，1变0；用于求整数的二进制反码。</li></ul><ul><li><code>&lt;&lt;</code> 左移运算符：各二进制位全部左移若干位，左边丢弃，右边补0。</li></ul><ul><li><code>&gt;&gt;</code> 右移运算符：各二进制位全部右移若干位，正数左补0，负数左补1，右边丢弃。</li></ul><ul><li>两个不同长度的数据进行位运算时，系统会将二者按右端对齐，然后进行位运算。短的那个数据如果是负数，左边补1，否则补0。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;最近在看《技术之瞳》，编程语言部分有一个笔试题目&quot;&gt;&lt;a href=&quot;#最近在看《技术之瞳》，编程语言部分有一个笔试题目&quot; class=&quot;headerlink&quot; title=&quot; 最近在看《技术之瞳》，编程语言部分有一个笔试题目&quot;&gt;&lt;/a&gt; 最近在看《技术之瞳》，编
      
    
    </summary>
    
      <category term="technique summary" scheme="http://ipine.github.io/categories/technique-summary/"/>
    
    
      <category term="面试题" scheme="http://ipine.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
      <category term="code" scheme="http://ipine.github.io/tags/code/"/>
    
  </entry>
  
  <entry>
    <title>CSS :before :after应用</title>
    <link href="http://ipine.github.io/2018-05-20/"/>
    <id>http://ipine.github.io/2018-05-20/</id>
    <published>2018-05-20T12:06:00.000Z</published>
    <updated>2018-08-28T04:09:28.573Z</updated>
    
    <content type="html"><![CDATA[<p>前面总结过将<a href="http://ipine.github.io/2018-05-13/">Flex布局</a>应用在区块图的布局中，现在需要在区块<code>.block</code>之间显示每个块产生的时间间隔，以及一个小三角符号。这里总结用伪元素<code>:before</code> ，<code>:after</code> 来实现该效果。</p><h3 id="伪元素"><a href="#伪元素" class="headerlink" title="伪元素"></a>伪元素</h3><h4 id="基本语法格式"><a href="#基本语法格式" class="headerlink" title="基本语法格式"></a>基本语法格式</h4><blockquote><p>selector:pseudo-element {property:value;}<br>  selector.class:pseudo-element {property:value;}</p></blockquote><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>方便给某些选择器添加特殊效果。</p><h4 id="before"><a href="#before" class="headerlink" title=":before"></a>:before</h4><p>用来给指定的元素的内容之前插入新内容；</p><h4 id="after"><a href="#after" class="headerlink" title=":after"></a>:after</h4><p>用来给指定的元素的内容之后插入新内容。</p><h4 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h4><pre><code>.first:before{    content: &apos;It\&apos;s &apos;;    color: blue;}&lt;p class=&quot;first&quot;&gt;me&lt;/p&gt;</code></pre><ul><li>效果：</li></ul><p><img src="http://p8ay1ez22.bkt.clouddn.com/18-5-20/44955663.jpg" alt="例1"></p><h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><ul><li><p>通过伪元素 <code>:before</code> ，<code>:after</code>添加的新内容区域默认的<code>display</code> 属性值为<code>inline</code>。可以像修改其他元素一样修改它的样式，可以将它的 <code>display</code> 属性值来改为 <code>block</code>。</p></li><li><p>对于伪元素 <code>:before</code> 和 <code>:after</code> ，属性 <code>content</code> <strong>必须设置</strong>。</p></li><li><p>属性 <code>content</code> 的值可以是多类型的</p></li></ul><h5 id="再举栗子"><a href="#再举栗子" class="headerlink" title="再举栗子"></a>再举栗子</h5><p> 1 . 可以是一张图片的url </p><pre><code>content: url( &quot;img/me.png&quot; )</code></pre><p> 2 . 可以配合伪类使用，常配合伪类 :hover </p><pre><code>.first:hover:before{    content:&apos;It\&apos;s &apos;;    color:red; }&lt;p class=&quot;first&quot;&gt;me&lt;/p&gt;</code></pre><p>注意两者使用的顺序，伪类 <code>:hover</code> 在前，伪元素<code>:before</code>在后，如果顺序改为 <code>.before:before:hover</code> ,则无效。</p><ul><li>效果：</li></ul><p><img src="http://p8ay1ez22.bkt.clouddn.com/18-5-20/54128140.jpg" alt="例2"></p><blockquote><p>鼠标移上去就显示It’s，且颜色是红色</p></blockquote><p>3 . 配合取值函数attr()使用</p><pre><code>a:before{     content: attr(title);}&lt;a href=&quot;http://www.taobao.com&quot; title=&quot;我的最爱&quot;&gt;买买买&lt;/a&gt;</code></pre><ul><li>效果：</li></ul><p><img src="http://p8ay1ez22.bkt.clouddn.com/18-5-20/3773922.jpg" alt="例3"></p><h3 id="我的练习"><a href="#我的练习" class="headerlink" title="我的练习"></a>我的练习</h3><h4 id="最终效果图"><a href="#最终效果图" class="headerlink" title="最终效果图"></a>最终效果图</h4><p><img src="http://p8ay1ez22.bkt.clouddn.com/18-5-20/51524863.jpg" alt="图1"></p><blockquote><p>图1 两个红色线框中的内容为实现效果</p></blockquote><h4 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h4><h5 id="HTML结构"><a href="#HTML结构" class="headerlink" title="HTML结构"></a>HTML结构</h5><p><img src="http://p8ay1ez22.bkt.clouddn.com/18-5-20/30610342.jpg" alt="图2"></p><blockquote><p>图2 3个大的横排div，每个横排大div里，假设都有5个<code>.block</code>区块div</p></blockquote><h5 id="CSS设置"><a href="#CSS设置" class="headerlink" title="CSS设置"></a>CSS设置</h5><p>以<code>.rowMiddle</code>行里的<code>.block</code>为例，用<code>:before</code>控制小三角的显示和位置；用<code>:after</code>控制区块产生的间隔时间的显示和位置</p><p>/<em><code>.rowMiddle</code>中每个<code>.block</code>后面的小三角符号的处理，控制 <code>:before</code></em>/</p><pre><code>.rowMiddle .block:not(:first-child)::before{    content: &apos;&apos;;    display: block;    width: 9px;     height: 9px;    background-image: url(../images/chainicon1.png);    background-repeat: no-repeat;    position: absolute;    top: 60%;    left: -20%;}</code></pre><p>/<em><code>.rowMiddle</code>中每个<code>.block</code>的产生时间间隔，控制 <code>:after</code></em>/</p><pre><code>.rowMiddle .block:not(:first-child)::after{    content: attr(data-content);    font-size: 12px;    display: block;    width: 36px;     height: 15px;    line-height: 15px;    position: absolute;    top: 30%;    left: -27%;}</code></pre><blockquote><p>注：attr(data-content)中 <code>data-content</code>的值通过js计算得到。每个<code>.block</code>的产生时间间隔不同，在js中为每个<code>.block</code>添加一个<code>.timewait</code>类，并设置属性<code>data-content</code>的值。</p></blockquote><h5 id="JS代码"><a href="#JS代码" class="headerlink" title="JS代码"></a>JS代码</h5><pre><code>$(&quot;.rowMiddle .block&quot;).each(function(i){    // 控制after伪类,为每个block添加不同的产生时间信息    // CSS中的.attr只能应用在伪类中的content属性    var timeWait = 0;        timeWait = blockData[4+i].time - blockData[5+i].time;        $(this).addClass(&apos;timewait&apos;).attr(&apos;data-content&apos;,timeWait+&apos;秒&apos;);});</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前面总结过将&lt;a href=&quot;http://ipine.github.io/2018-05-13/&quot;&gt;Flex布局&lt;/a&gt;应用在区块图的布局中，现在需要在区块&lt;code&gt;.block&lt;/code&gt;之间显示每个块产生的时间间隔，以及一个小三角符号。这里总结用伪元素&lt;code&gt;
      
    
    </summary>
    
      <category term="technique summary" scheme="http://ipine.github.io/categories/technique-summary/"/>
    
    
      <category term="javascript" scheme="http://ipine.github.io/tags/javascript/"/>
    
      <category term="css" scheme="http://ipine.github.io/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>报告：多维数据的感知互补视图评估</title>
    <link href="http://ipine.github.io/2018-05-17/"/>
    <id>http://ipine.github.io/2018-05-17/</id>
    <published>2018-05-17T07:59:00.000Z</published>
    <updated>2018-08-28T04:09:23.393Z</updated>
    
    <content type="html"><![CDATA[<h1 id="报告：多维数据的感知互补视图评估"><a href="#报告：多维数据的感知互补视图评估" class="headerlink" title="报告：多维数据的感知互补视图评估"></a>报告：多维数据的感知互补视图评估</h1><ul><li>论文原文：An Evaluation of Perceptually Complementary Views for Multivariate Data</li><li>作者：Chunlei Chang,Tim Dwyer,Kim Marriott</li><li>发表刊物/会议： <a href="http://itolab.is.ocha.ac.jp/pvis2018/" target="_blank" rel="noopener">PVis 2018</a></li></ul><h2 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h2><p>各个领域越来越多的自动化数据收集，因此越来越复杂的高维数据变得可用。有效的可视化和分析工具也越来越重要。多维数据的可视化技术和方法有很多，比如经典的MDS，PCA，但是这类方法在数据降维的过程中难免会损失原始数据的信息。而既能保证数据信息不丢失又能展示所有维度的信息，应用最广泛的是散点图矩阵<code>（SPLOMs）</code>和平行坐标图<code>（PCPs）</code>。</p><h3 id="本文工作"><a href="#本文工作" class="headerlink" title="本文工作"></a>本文工作</h3><p>评估散点图矩阵（SPLOM）、平行坐标图（PCP）、以及这两种技术的并排组合图（ Combined ）在可视化多维数据时的各自优势。</p><h3 id="重点贡献"><a href="#重点贡献" class="headerlink" title="重点贡献"></a>重点贡献</h3><p>1 . 总结6个用户分析多维数据时需要解决的Tasks；<br>2 . 总结5种志愿者在使用组合图时常用的策略；</p><ul><li><strong>论文作者为什么会想到评估组合视图呢？</strong></li></ul><blockquote><p>思路来源于一篇感知互补网络可视化的评估论文（CHI 2017 Evaluating perceptually<br>complementary views for network exploration tasks），这篇论文比较网络的单个矩阵视图、节点链接视图、以及它们的并排组合，发现并排组合的综合视图有明显的优势。但是现在还没有人做过这种组合视图的评估工作。 </p></blockquote><blockquote><p>注：感知互补视图，不同于多视图，在感觉上是互补的，即它们都展示相同的信息，但是对不同类型的分析任务有不同的和互补的支持。</p></blockquote><ul><li><strong>本文的组合视图与以往研究工作中的组合视图有什么区别呢？</strong></li></ul><blockquote><p>以往做法：使用复杂的视觉和交互设计将两种不同技术组合成单个可视化方案<br>  本文：更为直接地做法将两种技术视图并排放在一起</p></blockquote><ul><li><strong>主要研究的问题？</strong></li></ul><blockquote><p>Q1：PCP或SPLOM各自适合哪些任务？<br>  Q2：解决复杂任务时组合视图有没有优势？<br>  Q3：用户是否意识到不同视图的优点？ 如果有，他们用什么策略来解决分析任务。</p></blockquote><h2 id="视觉编码及交互设计"><a href="#视觉编码及交互设计" class="headerlink" title="视觉编码及交互设计"></a>视觉编码及交互设计</h2><h3 id="视觉编码"><a href="#视觉编码" class="headerlink" title="视觉编码"></a>视觉编码</h3><ul><li>PCP：每个数据项都被编码为一条折线，标签命名轴表示数据维度和范围；</li><li>SPLOM：每个数据项由多个圆点表示，对角线上的空白单元格用来显示维度标签，数据范围标记在左边和底边。</li></ul><p><img src="http://p8ay1ez22.bkt.clouddn.com/18-5-20/51062033.jpg" alt="图1"></p><blockquote><p>图1：可视化技术介绍</p></blockquote><h3 id="交互设计"><a href="#交互设计" class="headerlink" title="交互设计"></a>交互设计</h3><ul><li>鼠标悬浮数据项，高亮，该数据点的相关信息展示在旁边</li><li>范围过滤，选择范围内的数据项高亮</li><li>组合视图Brush（两个视图的联动），包括上面两个交互技术的应用</li><li><p>平行坐标轴和矩阵重排序</p><p><strong> 维度排序步骤：</strong><br>1 .点击PCP的轴或者散点图的轴启动拖拽<br>2 .将选定的轴拖动到所需的位置。<br>3 .释放鼠标，两个视图更新</p></li></ul><p><img src="http://p8ay1ez22.bkt.clouddn.com/18-5-20/15907245.jpg" alt="图2"></p><blockquote><p>图2 组合视图中轴的重排序</p></blockquote><h2 id="实验研究过程"><a href="#实验研究过程" class="headerlink" title="实验研究过程"></a>实验研究过程</h2><p>首先总结Tasks，确定6个通用任务，来源于以往基于PCP和SPLOM的评估工作。</p><p>实验参与者需要回答每个任务后面的具体问题。问题是基于实验中使用的数据。</p><ul><li>实验数据：学生成绩数据，6个维度，包含姓名、性别和4门学科的分数。</li></ul><h3 id="Best-Performer"><a href="#Best-Performer" class="headerlink" title="Best-Performer"></a>Best-Performer</h3><ul><li>Q： 哪个学生的平均分数最高？</li></ul><h3 id="Subset-Tracing"><a href="#Subset-Tracing" class="headerlink" title="Subset-Tracing"></a>Subset-Tracing</h3><ul><li>Q： 年龄在22岁，科学分数少于75分但是数学分数最高的学生姓名是？</li></ul><h3 id="Object-Comparison"><a href="#Object-Comparison" class="headerlink" title="Object-Comparison"></a>Object-Comparison</h3><ul><li>Q： 在所有4门学科中，标记3个数据为黄色，1个数据为蓝，要求找出标记为黄色的学生哪个与标记为蓝色的学生平均分最为相近？</li></ul><h3 id="Outlier-Detection"><a href="#Outlier-Detection" class="headerlink" title="Outlier-Detection"></a>Outlier-Detection</h3><ul><li>Q： 找出工程得分高于其他三门课程的学生（最为明显的那一个）？</li></ul><h3 id="Correlation-Estimation"><a href="#Correlation-Estimation" class="headerlink" title="Correlation-Estimation"></a>Correlation-Estimation</h3><ul><li>Q： 哪两门学科最为正相关？</li></ul><h3 id="Cluster-Identification"><a href="#Cluster-Identification" class="headerlink" title="Cluster-Identification"></a>Cluster-Identification</h3><ul><li>Q： 在哪对维度上有明显的簇？（找视觉上聚在一起的点或线）</li></ul><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><h3 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h3><p> 人造的学生成绩数据，共15个。3个训练集，12个用于正式实验。</p><ul><li>包括两个难易程度：容易6个、难6个。通过数据密度和答案选对的难易程度来控制题目的难易程度。</li><li>容易：100-120个数据项；正确答案与候选答案之间相差较远。</li><li>难：180-200个数据项；正确答案与几个候选答案之间很接近。</li></ul><h3 id="参与者"><a href="#参与者" class="headerlink" title="参与者"></a>参与者</h3><p> 实验分成A、B两个部分进行，每部分完成3个任务，时间花费在45分钟左右。参加A部分的人完成前3个任务，参加B部分的人完成后3个任务。</p><ul><li>每个参与者需要完成：3（任务）<em>12（数据）</em>3（可视化）次试验。</li></ul><h4 id="实验参与人员结构："><a href="#实验参与人员结构：" class="headerlink" title="实验参与人员结构："></a>实验参与人员结构：</h4><p> 全部来自于大学里的学生或工作人员。</p><ul><li>参加A部分的人，21名，8女13男；</li><li>参加B部分的人，30名，9女21男；</li><li>其中有9个人，同时参与两部分实验；</li><li>年龄在19岁-55岁，平均年龄为29岁。</li></ul><h3 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h3><h4 id="电脑配置"><a href="#电脑配置" class="headerlink" title="电脑配置"></a>电脑配置</h4><ul><li>英特尔酷睿i7 MacBook Pro（2016）和24英寸屏幕（1920×1080）</li></ul><h4 id="使用Tobii-X3-120眼动仪"><a href="#使用Tobii-X3-120眼动仪" class="headerlink" title="使用Tobii X3-120眼动仪"></a>使用Tobii X3-120眼动仪</h4><ul><li>跟踪参与者眼睛在屏幕上的移动情况，收集数据，为后面分析参与者使用组合视图时使用的策略作准备。</li></ul><h4 id="交互方式"><a href="#交互方式" class="headerlink" title="交互方式"></a>交互方式</h4><ul><li>通过鼠标和键盘进行答题和操作。</li></ul><h3 id="实验设计"><a href="#实验设计" class="headerlink" title="实验设计"></a>实验设计</h3><ul><li>分成A，B两部分：A：完成前3个任务；B：完成后3个任务；</li><li>为了实验条件平衡，每部分的参与者又分成2组，一组先用单独的一种可视化，后用组合可视化；另一组先用组合可视化，后用单独的可视化；对于同一个数据集，参与者在用不同可视化技术回答问题时，通过改变数据中学生的姓名和维度的排列顺序来避免可视化技术之间的影响；</li><li>每个参与者的问题顺序随机；</li><li>屏幕上方有计时条，参与者最多有30s使用可视化的时间；若在30s之内有答案，可按空格键停止计时；</li><li>屏幕弹出答案选项，包括几个候选答案，以及“太难”、“都不是”选项。</li></ul><h3 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h3><p> 1 .背景知识调查，调查参与者以往对两种可视化方法是否了解过。结果如图3所示。对于PCP技术，49%的人从未见过；而对于SPLOM技术，43%的人偶尔使用。</p><p><img src="http://p8ay1ez22.bkt.clouddn.com/18-5-20/96842735.jpg" alt="图3"></p><blockquote><p>图3 参与者背景知识调查结果</p></blockquote><p> 2 .眼动仪校准<br> 要求参与者对眼动仪进行校准，用时不超过30秒。</p><p> 3 .训练<br> 包括内容：</p><ul><li>指导每个参与者如何用可视化完成任务；</li><li>每个任务有3个实例，训练之后给出正确答案；</li><li>通过第一个实例来演示交互技术；正确通过一个实例后才能进入下一个实例；</li><li><p>告诉参与者答题时间的限制，要尽可能快和准地完成实验。</p><p>4 .正式实验<br>为每个参与者，呈现3种视图，每个视图都包含3个任务，每个任务包含12个不同数据集的问题。</p><p>5 . 收集反馈</p></li><li>收集参与者对3种可视化方法在每个任务上的排名；</li><li>收集参与者对每个可视化方法的优缺点评论。</li></ul><h2 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h2><h3 id="数据分析"><a href="#数据分析" class="headerlink" title="数据分析"></a>数据分析</h3><h4 id="数据收集"><a href="#数据收集" class="headerlink" title="数据收集"></a>数据收集</h4><ul><li>每次试验的完成时间</li><li>每次试验的准确率</li><li>眼睛和鼠标的移动数据</li><li>对于每个任务，参与者对可视化技术的主观偏好</li></ul><h4 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h4><ul><li>移除6次不合理数据，完成时间小于1s</li><li>移除选“太难” 或“都没有” 的试验</li></ul><h4 id="统计分析"><a href="#统计分析" class="headerlink" title="统计分析"></a>统计分析</h4><ul><li>数据不服从正态分布，使用Friedman test检验数据的总体差异性</li><li>由于移除了不合理的数据导致样本量不等，成对差异比较使用Mann-Whitney U test</li></ul><h3 id="眼动仪数据分析"><a href="#眼动仪数据分析" class="headerlink" title="眼动仪数据分析"></a>眼动仪数据分析</h3><p> 通过分析眼动仪数据来了解参与者使用<strong>组合视图</strong>采用的策略。</p><h4 id="数据收集-1"><a href="#数据收集-1" class="headerlink" title="数据收集"></a>数据收集</h4><p> 组合视图中的每次试验，测量参与者花在观察两个AOI（兴趣区域），即PCP和SPLOM上各自的停留和访问持续时间，用于检查和识别参与者策略。 </p><h4 id="策略分类结果，总共分为5种，如图4所示。"><a href="#策略分类结果，总共分为5种，如图4所示。" class="headerlink" title="策略分类结果，总共分为5种，如图4所示。"></a>策略分类结果，总共分为5种，如图4所示。</h4><ul><li>只看SPLOM，每次在PCP上停留时间不超过1s。</li><li>只看PCP，每次在SPLOM上停留时间不超过1s。</li><li>先看SPLOM，后看PCP，每次来回切换的停留时间不超过1s。</li><li>先看PCP，后看SPLOM，每次来回切换的停留时间不超过1s。</li><li>参与者视线在两个视图上频繁切换。</li></ul><p><img src="http://p8ay1ez22.bkt.clouddn.com/18-5-20/75032469.jpg" alt="图4"></p><blockquote><p>图4 组合视图中5种常见的使用策略</p></blockquote><h3 id="任务结果"><a href="#任务结果" class="headerlink" title="任务结果"></a>任务结果</h3><h4 id="T1：Best-Performer"><a href="#T1：Best-Performer" class="headerlink" title="T1：Best-Performer"></a>T1：Best-Performer</h4><ul><li>时间，3种技术无显著差异</li><li>准确率，PCP和Combined视图显著高于SPM</li><li>参与者更喜欢用PCP视图</li><li>眼追踪数据表明，参与者花在PCP上的时间多于SPLOM</li></ul><h4 id="T2：Subset-Tracing"><a href="#T2：Subset-Tracing" class="headerlink" title="T2：Subset-Tracing"></a>T2：Subset-Tracing</h4><ul><li>时间，PCP和Combined视图显著快于SPLOM</li><li>准确率，SPLOM显著最差</li><li>参与者更喜欢用PCP视图</li><li>眼追踪数据表明，Combined视图中，参与者花在PCP上的时间更多</li></ul><h4 id="T3：Object-Comparison"><a href="#T3：Object-Comparison" class="headerlink" title="T3：Object-Comparison"></a>T3：Object-Comparison</h4><ul><li>时间，3种技术无显著差异</li><li>准确率，SPLOM显著最差</li><li>参与者更喜欢用Combined视图</li><li>眼追踪数据表明，表明频繁切换视图策略最受欢迎，单独使用PCP与先使用PCP的比例相同，无人单独使用SPLOM</li></ul><h4 id="T4-Outlier-Detection"><a href="#T4-Outlier-Detection" class="headerlink" title="T4: Outlier-Detection"></a>T4: Outlier-Detection</h4><ul><li>时间，PCP显著多于SPLOM和Combined视图</li><li>准确率，SPLOM和Combined视图显著高于PCP</li><li>参与者更喜欢用Combined视图</li><li>眼追踪数据表明，频繁切换和先使用SPLOM最受欢迎</li></ul><h4 id="T5-Correlation-Estimation"><a href="#T5-Correlation-Estimation" class="headerlink" title="T5: Correlation-Estimation"></a>T5: Correlation-Estimation</h4><ul><li>时间，PCP显著多于SPLOM和Combined视图</li><li>准确率，所有技术之间都有显著性，SPLOM&gt;C&gt;PCP</li><li>参与者更喜欢用SPLOM视图</li><li>眼追踪数据表明，无人单独使用PCP，单独使用SPLOM的人最多</li></ul><h4 id="T6-Cluster-Identification"><a href="#T6-Cluster-Identification" class="headerlink" title="T6: Cluster-Identification"></a>T6: Cluster-Identification</h4><ul><li>时间，SPLOM显著快于其余两个</li><li>准确率，Combined视图最高，其次是SPLOM，最后是PCP</li><li>参与者更喜欢用SPLOM视图</li><li>眼追踪数据表明，只使用SPLOM的人最多，无人只使用PCP</li></ul><blockquote><p>图5，图6，图7，图8展示了相关结果</p></blockquote><p><img src="http://p8ay1ez22.bkt.clouddn.com/18-5-20/17397410.jpg" alt="图5"></p><blockquote><p>图5 按任务分类的三种可视化技术中每一种的平均结果。黄色背景表明该值与相同指标下的其他值有显著差异；黑色加粗字体表明是该指标下的最优值。</p></blockquote><p><img src="http://p8ay1ez22.bkt.clouddn.com/18-5-20/12855836.jpg" alt="图6"></p><blockquote><p>图6 按任务分类的三种可视化技术中每一种的完成时间的平均值和标准偏差。</p></blockquote><p><img src="http://p8ay1ez22.bkt.clouddn.com/18-5-20/52541686.jpg" alt="图7"></p><blockquote><p>图7 按任务分类的三种可视化技术中每一种的准确率平均值和标准偏差。</p></blockquote><p><img src="http://p8ay1ez22.bkt.clouddn.com/18-5-20/82786381.jpg" alt="图8"></p><blockquote><p>图8 (a)每个任务下，参与者在Combined视图中的偏好选择；(b)每个任务下，参与者在Combined视图中使用的策略情况。</p></blockquote><h4 id="视图使用情况对比"><a href="#视图使用情况对比" class="headerlink" title="视图使用情况对比"></a>视图使用情况对比</h4><p> 组合视图中，参与者花费在每个视图中的时间对比图，如图9所示。</p><blockquote><p>发现：在前3个任务中，多数参与者使用PCP 1st and Parallel Use两种策略；后3个任务，则多数参与者使用SPLOM 1st and Parallel Use 两种策略</p></blockquote><p><img src="http://p8ay1ez22.bkt.clouddn.com/18-5-20/19142179.jpg" alt="图9"></p><blockquote><p>图9 用于查看Combined视图中每个视图的相对时长（栏高度）；1-3是训练任务。</p></blockquote><h2 id="结论总结"><a href="#结论总结" class="headerlink" title="结论总结"></a>结论总结</h2><p> 提出PCP和SPLOM的组合表示，主要探讨并评估多维数据的感知互补视图的影响。</p><ul><li><p><strong>PCP和SPLOM视图在感知上是互补的。</strong></p><p>SPLOM点可视化可以帮助参与者理解整体（后3个Tasks）,PCP线可视化帮助参与者识别单个观察点，两种结合既可以解决整体任务又可以解决细节任务。</p></li><li><p><strong>并排放置感知互补的视图是获得两者优点的有效方法。</strong></p><p>以往用复杂的设计和交互手段使两个技术结合成一种可视化方案并不是没有效果，但是这种效果普通参与者无法体验。更为直接的方法就是让两个视图并排放置在一起，本文的实验结果证明了这种做法是有效的。</p></li><li><p><strong>基于眼动追踪数据，针对组合视图确定了五种常用视图使用策略。</strong></p></li><li><p><strong>有些人在没有意识的情况下使用互补视图的优势。</strong></p><p>参与者给出的每个任务下对技术的主观偏好与眼动仪追踪数据分析的结果并不完全一致，使用组合视图时，参与者主观偏好某一种可视化技术，但是眼动仪数据表明他们使用组合策略时间更久。这说明参与者其实在没有意识的情况下已经体验了互补视图的优势。</p></li><li><p><strong>当一个视图对于特定任务明显比另一视图更好时，使用组合视图会有更多的时间开销。</strong></p><p>例如分析任务5，SPLOM视图明显比PCP更适合。当使用Combined视图时，会花费更多的时间，但是准确率仍然能够保证。</p></li></ul><h2 id="缺陷与未来工作"><a href="#缺陷与未来工作" class="headerlink" title="缺陷与未来工作"></a>缺陷与未来工作</h2><h3 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h3><ul><li><p>尽管得出组合视图在6个任务中的5个上都表现好，但是标准偏差比较高。</p></li><li><p>整个实验使用的数据密度(100-200)太小，数据结构单一。意味着碰到数据密度很大，或者其他数据结构时，本文的实验结果不一定适用。</p></li></ul><h3 id="未来研究方向"><a href="#未来研究方向" class="headerlink" title="未来研究方向"></a>未来研究方向</h3><ul><li><p>研究互补性对其他类型数据集的影响（例如，对于分层数据和动态网络）。</p></li><li><p>哪些视图可以产生互补效应？有没有有效的分类？一个视图以数据项为中心（例如PCP和节点链接图）和一个视图以关系为中心（如SPLOM和邻接矩阵），这是不是一种有效的分类呢？还需要更多的研究。</p></li><li><p>可以进一步研究训练对人们使用组合图的有效性的影响。有经验的参与者知道利用Combined视图的优势，而无经验的用户则可能只会使用单个视图，说明训练对人们的策略使用是有影响的。还可以进一步确定组合图的使用是否有助于人们学习更有效地使用单个视图。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;报告：多维数据的感知互补视图评估&quot;&gt;&lt;a href=&quot;#报告：多维数据的感知互补视图评估&quot; class=&quot;headerlink&quot; title=&quot;报告：多维数据的感知互补视图评估&quot;&gt;&lt;/a&gt;报告：多维数据的感知互补视图评估&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;论文原文：An 
      
    
    </summary>
    
      <category term="可视化论文 summary" scheme="http://ipine.github.io/categories/%E5%8F%AF%E8%A7%86%E5%8C%96%E8%AE%BA%E6%96%87-summary/"/>
    
    
      <category term="reading notes" scheme="http://ipine.github.io/tags/reading-notes/"/>
    
      <category term="paper" scheme="http://ipine.github.io/tags/paper/"/>
    
  </entry>
  
  <entry>
    <title>Flex布局</title>
    <link href="http://ipine.github.io/2018-05-13/"/>
    <id>http://ipine.github.io/2018-05-13/</id>
    <published>2018-05-13T12:59:00.000Z</published>
    <updated>2018-08-28T04:09:12.806Z</updated>
    
    <content type="html"><![CDATA[<p>最近在做一个关于区块链可视化的前端页面练习，尝试了flex布局，作个简单的summary。</p><h3 id="网页布局"><a href="#网页布局" class="headerlink" title="网页布局"></a>网页布局</h3><p>区块图展示部分刚开始使用的是布局的传统解决方案: 基于盒状模型，依赖<code>display</code>属性+<code>position</code>属性+<code>float</code>属性，后来发现Flex弹性布局更好用，垂直方向居中完全不是问题，盒子换行放置也很easy。</p><p>Flex布局即是一种弹性布局。任何一个容器都可以指定为Flex布局<code>（display:flex）</code>，行内元素也可以使用<code>（display:inline-flex）</code>。</p><blockquote><p>注意：设为Flex布局以后，子元素的float,clear,和vertical-align属性将失去作用。</p></blockquote><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>采用 Flex 布局的元素，称为 Flex 容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称”项目”。</p><h4 id="容器的属性"><a href="#容器的属性" class="headerlink" title="容器的属性"></a>容器的属性</h4><p><img src="http://p8ay1ez22.bkt.clouddn.com/18-5-19/84888199.jpg" alt="容器"></p><p>每个属性对应的含义是：</p><p> • 项目排列方向；可取四个值： <code>row | row-reverse | column | column-reverse</code><br> • 项目是否换行，怎么换；可取三个值： <code>nowrap | wrap | wrap-reverse</code><br> • 前2个属性的简写; 取值： <code>&lt;flex-direction&gt; || &lt;flex-wrap&gt;</code><br> • 项目在主轴上的对齐方式，与主轴的方向有关；可取五个值： <code>flex-start | flex-end | center | space-between | space-around</code><br> • 项目在交叉轴上的对齐方式,与交叉轴的方向有关；可取五个值： <code>flex-start | flex-end | center | baseline | stretch</code><br> • 多根轴线的对齐方式，若项目只有一根轴线，该属性不起作用；可取六个值： <code>flex-start | flex-end | center | space-between | space-around | stretch</code></p><h4 id="项目的属性"><a href="#项目的属性" class="headerlink" title="项目的属性"></a>项目的属性</h4><p><img src="http://p8ay1ez22.bkt.clouddn.com/18-5-19/10672781.jpg" alt="项目"></p><p>每个属性对应的含义是：</p><p> • 项目排列顺序，值越小，排列越靠前；默认为0<br> • 有多余空间时，项目是否放大；默认为0，不放大<br> • 空间不够时，项目是否缩小；默认为1，缩小<br> • 分配多余空间之前，项目占据的主轴空间；默认为auto,即原本大小<br> • <code>flex-grow</code>, <code>flex-shrink</code> 和 <code>flex-basis</code>属性的简写（优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值），常用的两个快捷值： <code>auto(1 1 auto)和none(0 0 auto)</code><br> • 允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性；默认值为auto</p><h3 id="我的布局"><a href="#我的布局" class="headerlink" title="我的布局"></a>我的布局</h3><h4 id="HTML结构"><a href="#HTML结构" class="headerlink" title="HTML结构"></a>HTML结构</h4><p> 1 . 包含所有区块的大div -&gt;.d3layout（容器）；<br> 2 . 大div里包含3个次大div -&gt;.block-row（既是容器又是项目）；<br> 3 . 每个次大div里包含5个或者2个小div -&gt; .block/.block_0（项目）；</p><p><img src="http://p8ay1ez22.bkt.clouddn.com/18-5-19/19741905.jpg" alt="HTML结构"></p><h4 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h4><h5 id="第一层的大div"><a href="#第一层的大div" class="headerlink" title="第一层的大div"></a>第一层的大div</h5><pre><code>.d3layout{    width: 935px;    margin: 20px 0;    height: 740px;/*flex布局容器*/    display: flex;    flex-flow: row wrap;    justify-content: flex-start;    align-items: flex-start;    align-content: space-around;}</code></pre><h5 id="第二层的次大div"><a href="#第二层的次大div" class="headerlink" title="第二层的次大div"></a>第二层的次大div</h5><pre><code>.rowTop,.rowMiddle,.rowBottom{    height: 202px;    width: 935px;/*flex布局项目*/    flex: auto; /*（1，1，auto）*//*flex布局容器*/    display: flex;    flex-flow: row wrap;    justify-content: space-between;    align-items: center;}</code></pre><h5 id="第三层的小div"><a href="#第三层的小div" class="headerlink" title="第三层的小div"></a>第三层的小div</h5><pre><code>.block_0{    width: 703px;    height: 180px;  /*flex布局项目*/     flex: 0 1 auto;}.block{    width: 145px;    height: 180px;/*flex布局项目*/    flex: 0 1 auto;}</code></pre><h4 id="布局效果"><a href="#布局效果" class="headerlink" title="布局效果"></a>布局效果</h4><p>黑色为大div；红色为次大div；灰色为小div</p><p><img src="http://p8ay1ez22.bkt.clouddn.com/18-5-19/86157629.jpg" alt="效果图"></p><p>最终在实践过程中，又添了一层，灰色小div.block里还包括上下两个div，仍然用的flex布局。</p><p>注：<a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html?^%$" target="_blank" rel="noopener">基本概念参考来源</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近在做一个关于区块链可视化的前端页面练习，尝试了flex布局，作个简单的summary。&lt;/p&gt;
&lt;h3 id=&quot;网页布局&quot;&gt;&lt;a href=&quot;#网页布局&quot; class=&quot;headerlink&quot; title=&quot;网页布局&quot;&gt;&lt;/a&gt;网页布局&lt;/h3&gt;&lt;p&gt;区块图展示部分刚开
      
    
    </summary>
    
      <category term="technique summary" scheme="http://ipine.github.io/categories/technique-summary/"/>
    
    
      <category term="javascript" scheme="http://ipine.github.io/tags/javascript/"/>
    
      <category term="css" scheme="http://ipine.github.io/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>Twice linear</title>
    <link href="http://ipine.github.io/2018-05-07/"/>
    <id>http://ipine.github.io/2018-05-07/</id>
    <published>2018-05-07T13:34:00.000Z</published>
    <updated>2018-08-28T04:09:06.331Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>Consider a sequence u where u is defined as follows:<br>1 . The number u(0) = 1 is the first one in u.<br>2 . For each x in u, then y = 2 <em> x + 1 and z = 3 </em> x + 1 must be in utoo.<br>3 . There are no other numbers in u.<br>Ex: u = [1, 3, 4, 7, 9, 10, 13, 15, 19, 21, 22, 27, …]<br>1 gives 3 and 4, then 3 gives 7 and 10, 4 gives 9 and 13, then 7 gives 15 and 22 and so on…</p><ul><li>Task: Given parameter n the function dbl_linear (or dblLinear…) returns the element u(n) of the ordered (with &lt;) sequence u.</li><li>Example: dbl_linear(10) should return 22</li><li>Note: Focus attention on efficiency</li></ul><h3 id="我的代码"><a href="#我的代码" class="headerlink" title="我的代码"></a>我的代码</h3><pre><code>function dblLinear(n) {    // your code    var res = [1];    var i=0,j=0;    while(res.length &lt;= n){      var y = res[i]*2+1;      var z = res[j]*3+1;      if(y&lt;z){        res.push(y);        i++;      }else if(y==z){        res.push(y);        i++;        j++;      }else{        res.push(z);        j++;      }    }    return res[n];}</code></pre><h3 id="Clever"><a href="#Clever" class="headerlink" title="Clever"></a>Clever</h3><pre><code>function dblLinear(n) { var ai = 0, bi = 0, eq = 0; var sequence = [1]; while (ai + bi &lt; n + eq) {  var y = 2 * sequence[ai] + 1;  var z = 3 * sequence[bi] + 1; if (y &lt; z) {   sequence.push(y);  ai++;  } else if (y &gt; z) {  sequence.push(z);  bi++; } else {   sequence.push(y);  ai++; bi++; eq++;  }} return sequence.pop();}</code></pre><h3 id="Key"><a href="#Key" class="headerlink" title="Key"></a>Key</h3><ul><li>考虑效率问题，就不能将所有值都放入数组，再来排序，去重；且这种解法，不好控制循环的次数；</li><li>想到在push元素进数组时就按从小到大的顺序放入，且遇到相同的元素就只push一次进数组</li><li>具体思路就是每次将y和z中较小的一个放入数组，同时其对应的计数器+1；若y和z相等，放任意一个进数组，两个计算器都+1</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;Consider a sequence u where u is defined as follows:&lt;br&gt;1 . Th
      
    
    </summary>
    
      <category term="technique" scheme="http://ipine.github.io/categories/technique/"/>
    
    
      <category term="javascript" scheme="http://ipine.github.io/tags/javascript/"/>
    
      <category term="codewars" scheme="http://ipine.github.io/tags/codewars/"/>
    
  </entry>
  
  <entry>
    <title>Adding Big Numbers</title>
    <link href="http://ipine.github.io/2018-05-06/"/>
    <id>http://ipine.github.io/2018-05-06/</id>
    <published>2018-05-06T12:31:00.000Z</published>
    <updated>2018-08-28T04:08:58.570Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>We need to sum big numbers and we require your help.<br>Write a function that returns the sum of two numbers. The input numbers are strings and the function must return a string.<br>Example<br>add(“123”, “321”); -&gt; “444”<br>add(“11”, “99”); -&gt; “110”</p><p>Notes</p><ul><li>The input numbers are big.</li><li>The input is a string of only digits</li><li>The numbers are positives</li></ul><h3 id="我的代码"><a href="#我的代码" class="headerlink" title="我的代码"></a>我的代码</h3><pre><code>function add(a, b) {  var arra =a.split(&apos;&apos;);  var arrb =b.split(&apos;&apos;);  var len = a.length &gt; b.length?a.length:b.length;  var result = [];  var count = 0;  for(i=0; i&lt;len; i++){    var temp;    if(i&gt;=a.length){      temp = Number(arrb.pop()) + count;    }else if(i&gt;=b.length){      temp = Number(arra.pop()) + count;    }else{      temp = (Number(arra.pop()) + Number(arrb.pop())) + count;    }    temp &gt;= 10?[temp,count]=[temp-10,1]:count=0;    result.push(temp);  }  result.push(count); // console.log(result);  return result.reverse().join(&apos;&apos;).replace(/^0+/,&apos;&apos;);//   return Number(a) + Number(b); // Fix this!}</code></pre><h3 id="Clever"><a href="#Clever" class="headerlink" title="Clever"></a>Clever</h3><pre><code>function add (a, b) { var res = &apos;&apos;, c = 0 ; a = a.split(&apos;&apos;); b = b.split(&apos;&apos;); while (a.length || b.length || c) {   c += ~~a.pop() + ~~b.pop();  res = c % 10 + res;  c = c &gt; 9; }  return res; }</code></pre><h3 id="Key"><a href="#Key" class="headerlink" title="Key"></a>Key</h3><p>1 . 思路是将a和b的最后一位相加，如果相加的结果大于10，取个位数部分，进位值<code>count+1</code>；并将结果放入到数组中。<br>2 . 要一位一位相加，需要把a和b两个字符串转成字符串数组，用到<code>.split()</code>函数。<br>3 . 还要注意判断a串和b串哪个更长，最后循环完后需要将最后一次的进位值放入数组。<br>4 . 以上步骤得到的数组不是最终结果，还要先<code>翻转</code>，再将字符串数组<code>变成字符串</code>，最后用<code>.replace()</code>方法将首位的0去掉。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;We need to sum big numbers and we require your help.&lt;br&gt;Write 
      
    
    </summary>
    
      <category term="technique" scheme="http://ipine.github.io/categories/technique/"/>
    
    
      <category term="javascript" scheme="http://ipine.github.io/tags/javascript/"/>
    
      <category term="codewars" scheme="http://ipine.github.io/tags/codewars/"/>
    
  </entry>
  
  <entry>
    <title>Find the missing term in an Arithmetic Progression</title>
    <link href="http://ipine.github.io/2018-05-02/"/>
    <id>http://ipine.github.io/2018-05-02/</id>
    <published>2018-05-02T05:42:00.000Z</published>
    <updated>2018-08-28T04:08:54.084Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>An Arithmetic Progression is defined as one in which there is a constant difference between the consecutive terms of a given series of numbers. You are provided with consecutive elements of an Arithmetic Progression. There is however one hitch: exactly one term from the original series is missing from the set of numbers which have been given to you. The rest of the given series is the same as the original AP. Find the missing term.<br>You have to write the function findMissing(list), list will always be at least 3 numbers. The missing term will never be the first or last one.</p><p>Example :<br>findMissing([1,3,5,9,11]) == 7</p><blockquote><p>PS: This is a sample question of the facebook engineer challenge on interviewstreet. I found it quite fun to solve on paper using math, derive the algo that way.</p></blockquote><h3 id="我的代码"><a href="#我的代码" class="headerlink" title="我的代码"></a>我的代码</h3><pre><code>var findMissing = function (list) {   var len = list.length;  var x = Math.abs((list[1]-list[0])) &lt; Math.abs((list[len-1]-list[len-2])) ? Math.abs((list[1]-list[0])):Math.abs((list[len-1]-list[len-2]));  console.log(x);  for(i=0; i&lt;len; i++){    if(list[len-1] &gt; list[0]){      if(list.indexOf(list[i]+x) == -1)      return list[i]+x;    }else if(list[len-1] &lt; list[0]){      if(list.indexOf(list[i]-x) == -1)      return list[i]-x;    }  }}</code></pre><h3 id="Clever"><a href="#Clever" class="headerlink" title="Clever"></a>Clever</h3><pre><code>var findMissing = function (list) {     var step = (list[list.length - 1] - list[0]) / (list.length);     return list.filter(function(val, index) { return val !== (list[0] + index * step); })[0] - step; }</code></pre><h3 id="Key"><a href="#Key" class="headerlink" title="Key"></a>Key</h3><ul><li><p>关键点1要找到等差值，利用题目中给的信息：第一个和最后一个数不会缺失；将这两个数分别与它们的后一个和前一个数相减，小的那个差就是等差值；</p></li><li><p>关键点2要注意数列中可能有负数，按照关键点1求等差值的做法，则求解的时候要取绝对值；且需要判断数列是递增还是递减；</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;An Arithmetic Progression is defined as one in which there is 
      
    
    </summary>
    
      <category term="technique" scheme="http://ipine.github.io/categories/technique/"/>
    
    
      <category term="javascript" scheme="http://ipine.github.io/tags/javascript/"/>
    
      <category term="codewars" scheme="http://ipine.github.io/tags/codewars/"/>
    
  </entry>
  
  <entry>
    <title>Range Extraction</title>
    <link href="http://ipine.github.io/2018-05-01/"/>
    <id>http://ipine.github.io/2018-05-01/</id>
    <published>2018-05-01T05:30:00.000Z</published>
    <updated>2018-08-28T04:08:49.626Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>A format for expressing an ordered list of integers is to use a comma separated list of either<br>• individual integers<br>• or a range of integers denoted by the starting integer separated from the end integer in the range by a dash, ‘-‘. The range includes all integers in the interval including both endpoints. It is not considered a range unless it spans at least 3 numbers. For example (“12, 13, 15-17”)<br>Complete the solution so that it takes a list of integers in increasing order and returns a correctly formatted string in the range format.</p><p>Example:<br>solution([-6, -3, -2, -1, 0, 1, 3, 4, 5, 7, 8, 9, 10, 11, 14, 15, 17, 18, 19, 20]);<br>// returns “-6,-3-1,3-5,7-11,14,15,17-20”</p><h3 id="我的代码"><a href="#我的代码" class="headerlink" title="我的代码"></a>我的代码</h3><pre><code>function solution(list){ // TODO: complete solution  var str = [];  for (i = 0; i &lt; list.length; i++) {    if ((list[i]+1) !== list[i+1]) {//完全没有连续的情况      str += list[i].toString() + &apos;,&apos;;    } else if ((list[i]+1) === list[i+1] &amp;&amp; (list[i+1]+1) === list[i+2] &amp;&amp; (list[i-1]+1) !== list[i]) {//有2个及其以上连续的情况      str += list[i].toString() + &apos;-&apos;;    } else if (str[str.length-1] === &apos;-&apos; &amp;&amp; (list[i]+1) !== list[i+1]) {//判断是否是range的最后一个元素      str += list[i].toString() + &apos;,&apos;;    } else if ((list[i]-1) === list[i-1] &amp;&amp; (list[i]+1) === list[i+1]) {      //属于range中的元素    } else if ((list[i]-1) === list[i-1] &amp;&amp; (list[i-1]-1) === list[i-2]) {//只有2个连续的情况      str += list[i].toString() + &apos;,&apos;;    } else {//新range开头      str += list[i].toString() + &apos;,&apos;;    }  }   return str.slice(0, -1);//去掉最后的逗号}</code></pre><h3 id="Clever"><a href="#Clever" class="headerlink" title="Clever"></a>Clever</h3><pre><code>function solution(list){ for(var i = 0; i &lt; list.length; i++){  var j = i;  while(list[j] - list[j+1] == -1)   j++;  if(j != i &amp;&amp; j-i&gt;1)  list.splice(i, j-i+1, list[i] +&apos;-&apos;+list[j]);  } return list.join();}</code></pre><h3 id="Key"><a href="#Key" class="headerlink" title="Key"></a>Key</h3><ul><li><p><code>.slice()</code> 方法可返回一个新的数组，包含从 start 到 end （不包括该元素）的 arrayObject 中的元素。（含头不含尾）</p><blockquote><p>语法：arrayObject.slice(start,end)</p></blockquote></li><li><p>用到了<code>.splice()</code>方法，替换数组中的内容。</p><blockquote><p>参数包含:（起始下标，替换长度，替换内容）</p></blockquote></li><li><p><code>i</code>记录range开始位置，<code>j</code>记录range结束位置。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;A format for expressing an ordered list of integers is to use 
      
    
    </summary>
    
      <category term="technique" scheme="http://ipine.github.io/categories/technique/"/>
    
    
      <category term="javascript" scheme="http://ipine.github.io/tags/javascript/"/>
    
      <category term="codewars" scheme="http://ipine.github.io/tags/codewars/"/>
    
  </entry>
  
  <entry>
    <title>Sudoku Solution Validator</title>
    <link href="http://ipine.github.io/2018-04-30/"/>
    <id>http://ipine.github.io/2018-04-30/</id>
    <published>2018-04-30T05:29:00.000Z</published>
    <updated>2018-08-28T04:08:37.268Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>Sudoku Background：<br>Sudoku is a game played on a 9x9 grid. The goal of the game is to fill all cells of the grid with digits from 1 to 9, so that each column, each row, and each of the nine 3x3 sub-grids (also known as blocks) contain all of the digits from 1 to 9. </p><p><img src="http://p8ay1ez22.bkt.clouddn.com/18-5-6/15442296.jpg" alt="题目描述"></p><h3 id="我的代码"><a href="#我的代码" class="headerlink" title="我的代码"></a>我的代码</h3><pre><code>function validSolution(board){  //TODO  var flag = 1;  for(j=0; j&lt;9; j++){    var sumcol = 0;    var sum = 0;// 计算列和是否为45    for(i=0; i&lt;9; i++){      sumcol += board[i][j];    }    if(sumcol != 45){        flag = 0;        break;    }// 计算行和是否为45，利用数组的方法求和    board[j].some(function(item,i){      sum += item;    })    if(sum != 45){      flag = 0;      break;    }  }// 计算前9个宫格的和是否为45  var sumgrid = 0;  for(k=0; k&lt;3; k++){       for(l=0; l&lt;3; l++){      sumgrid += board[k][l];    }  }  if(sumgrid != 45){    flag = 0;  }  if(flag){    return true;  }else{    return false;  }}</code></pre><h3 id="Clever"><a href="#Clever" class="headerlink" title="Clever"></a>Clever</h3><pre><code>function equals45(n){ return n == 45;} function validSolution(board){var sumh = [0,0,0,0,0,0,0,0,0]; var sumv = [0,0,0,0,0,0,0,0,0]; osums = [[0,0,0],[0,0,0],[0,0,0]]; for (var i=0;i&lt;9;i++){  for (var j=0;j&lt;9;j++){  sumh[i] += board[i][j];   sumv[j] += board[i][j]; // 这里我认为应该是board[j][i]  osums[Math.floor(i/3)][Math.floor(j/3)] += board[i][j];  } } for (var i=0;i&lt;3;i++) if (!osums[i].every(equals45))   return false;return (sumh.every(equals45) &amp;&amp; sumv.every(equals45)); }</code></pre><h3 id="Key"><a href="#Key" class="headerlink" title="Key"></a>Key</h3><ul><li><code>every()</code>方法只有数组中每一项执行回调函数结果合部为true才会返回，不然就会返回false。</li></ul><p><a href="http://www.jb51.net/article/81360.htm" target="_blank" rel="noopener">常见的数组操作方法</a></p><p>-这个题的做法实质上是不能正确验证是否是数独解。因为若每个cell都是5，满足行、列、每个9宫格的和为45的条件，但不满足数独解的条件。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;Sudoku Background：&lt;br&gt;Sudoku is a game played on a 9x9 grid. T
      
    
    </summary>
    
      <category term="technique" scheme="http://ipine.github.io/categories/technique/"/>
    
    
      <category term="javascript" scheme="http://ipine.github.io/tags/javascript/"/>
    
      <category term="codewars" scheme="http://ipine.github.io/tags/codewars/"/>
    
  </entry>
  
  <entry>
    <title>Directions Reduction</title>
    <link href="http://ipine.github.io/2018-04-28/"/>
    <id>http://ipine.github.io/2018-04-28/</id>
    <published>2018-04-28T13:33:00.000Z</published>
    <updated>2018-08-28T04:08:18.428Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>Write a function which will take an array of strings and return an array of strings with the needless directions removed (WEST and EAST, NORTH and SOUTH cancel each other out).<br>If everything cancels out, return an empty array (stay in place);</p><p>For example:</p><blockquote><p>dirReduc([“NORTH”, “SOUTH”, “SOUTH”, “EAST”, “WEST”, “NORTH”, “WEST”]) =&gt; [“WEST”]<br>dirReduc([“NORTH”, “SOUTH”, “SOUTH”, “EAST”, “WEST”, “NORTH”]) =&gt; []</p></blockquote><h3 id="我的代码"><a href="#我的代码" class="headerlink" title="我的代码"></a>我的代码</h3><pre><code>function dirReduc(arr){  // ...  for(i=0; i&lt;arr.length; i++){    if(arr[i] == &quot;NORTH&quot;){      arr[i] = 1;    }else if(arr[i] == &quot;SOUTH&quot;){      arr[i] = -1;    }else if(arr[i] == &quot;EAST&quot;){      arr[i] = 2;    }else if(arr[i] == &quot;WEST&quot;){      arr[i] = -2;    }  }//   console.log(arr);  for(i=0; i&lt;arr.length; i++){        if(arr[i] + arr[i+1] == 0){        arr.splice(i,2);        i -=2;        continue;      }   }  for(i=0; i&lt;arr.length; i++){    if(arr[i] == 1){      arr[i] = &quot;NORTH&quot;;    }else if(arr[i] == -1){      arr[i] = &quot;SOUTH&quot;;    }else if(arr[i] == 2){      arr[i] = &quot;EAST&quot;;    }else if(arr[i] == -2){      arr[i] = &quot;WEST&quot;;    }  }  return arr;}</code></pre><h3 id="Clever"><a href="#Clever" class="headerlink" title="Clever"></a>Clever</h3><pre><code>function dirReduc(arr) { var str = arr.join(&apos;&apos;), pattern = /NORTHSOUTH|EASTWEST|SOUTHNORTH|WESTEAST/;  while (pattern.test(str))   str = str.replace(pattern,&apos;&apos;); return str.match(/(NORTH|SOUTH|EAST|WEST)/g)||[]; }</code></pre><h3 id="Key"><a href="#Key" class="headerlink" title="Key"></a>Key</h3><ul><li><p>如何考虑重复判断数组arr里是否还有符合要求的字符对？<br>解决办法：下标i回到0，跳出当前循环，又从第一个元素开始判断剩余数组中的内容，重复这个过程，直到没有符合条件的元素</p></li><li><p>删除的数组的某一项用：<code>splice(index,len,[item])</code><br><em>注：该方法会改变原始数组</em><br>splice有3个参数，它也可以用来替换/删除/添加数组内某一个或者几个值<br><code>index</code>:数组开始下标（要删除的元素的下标）<br><code>len</code>: 替换/删除的长度<br><code>item</code>:替换的值，删除操作的话 item为空</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;Write a function which will take an array of strings and retur
      
    
    </summary>
    
      <category term="technique" scheme="http://ipine.github.io/categories/technique/"/>
    
    
      <category term="javascript" scheme="http://ipine.github.io/tags/javascript/"/>
    
      <category term="codewars" scheme="http://ipine.github.io/tags/codewars/"/>
    
  </entry>
  
  <entry>
    <title>BuildTower</title>
    <link href="http://ipine.github.io/2018-04-27/"/>
    <id>http://ipine.github.io/2018-04-27/</id>
    <published>2018-04-27T06:49:00.000Z</published>
    <updated>2018-08-28T04:08:10.177Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>Build a tower like this:<br>    <img src="http://p8ay1ez22.bkt.clouddn.com/18-5-6/66768733.jpg" alt="题目描述"></p><h3 id="我的代码"><a href="#我的代码" class="headerlink" title="我的代码"></a>我的代码</h3><pre><code>function towerBuilder(nFloors) {  // build here  var arr = [];  for(var i=0; i&lt;=nFloors-1; i++){    var stars = i*2+1;    var space = nFloors-1-i;    arr.push(&quot; &quot;.repeat(space) + &quot;*&quot;.repeat(stars) + &quot; &quot;.repeat(space));  }  return arr;  }</code></pre><h3 id="Clever"><a href="#Clever" class="headerlink" title="Clever"></a>Clever</h3><p>分别计算出空格个数和星星个数，将这些字符连接起来成串，放入字符串数组中。</p><h3 id="Key"><a href="#Key" class="headerlink" title="Key"></a>Key</h3><ul><li>如何生成重复字符？ <code>&quot;字符&quot;.repeat(n)</code> 方法</li><li>如何将字符放入数组: 每次单考虑字符串数组中的一个元素，每个元素都是一串字符，用<code>+</code>连接形成字符串（元素），再使用<code>arr.push()</code> 方法将每个元素依次放入数组。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;Build a tower like this:&lt;br&gt;    &lt;img src=&quot;http://p8ay1ez22.bkt
      
    
    </summary>
    
      <category term="technique" scheme="http://ipine.github.io/categories/technique/"/>
    
    
      <category term="javascript" scheme="http://ipine.github.io/tags/javascript/"/>
    
      <category term="codewars" scheme="http://ipine.github.io/tags/codewars/"/>
    
  </entry>
  
</feed>
